/**
 * Generated by @skyleague/therefore
 * Do not manually touch this
 */
/* eslint-disable */

import { z } from 'zod'

export const RestError = z.object({
    errorCode: z.number().int().optional(),
    errorReason: z.string().optional(),
    errorSource: z.string().optional(),
})

export type RestError = z.infer<typeof RestError>

export const DuplicateFieldConstraint = z
    .object({
        active: z.boolean().describe('The check will be performed if the field is true').optional(),
        dataField: z.string().describe('The ENUM data field when the field is an ENUM').optional(),
        dataItemType: z
            .enum([
                'LOANS',
                'SAVINGS',
                'CLIENT',
                'CLIENT_ROLE',
                'GROUP',
                'GROUP_ROLE',
                'TRANSACTION',
                'JOURNAL_ENTRY',
                'INTEREST_ACCRUAL_BREAKDOWN',
                'BRANCH',
                'CENTRE',
                'USER',
                'LOAN_PRODUCT',
                'SAVINGS_PRODUCT',
                'NOTIFICATION_MESSAGE',
                'NOTIFICATION_TEMPLATE',
                'REPAYMENT',
                'REPAYMENT_COLLECTION',
                'ACTIVITY',
                'LINE_OF_CREDIT',
                'IDENTIFICATION_DOCUMENT',
                'ATTACHMENT',
                'CURRENCY',
                'PRODUCT',
                'REVENUE',
                'EXPENSE',
                'OUTSTANDING_PORTFOLIO_ACCOUNTS',
                'OUTSTANDING_PORTFOLIO_AMOUNTS',
                'CREATED_ACCOUNTS',
                'WRITTEN_OFF_LOANS',
                'DISBURSED_LOANS',
                'LOAN_GROUP',
                'TRANCHE',
                'DISBURSEMENT_DETAILS',
                'TRANSACTION_DETAILS',
                'TRANSACTION_CHANNEL',
                'CUSTOM_PREDEFINED_FEE',
                'CUSTOM_FIELD_SELECTION',
                'PREDEFINED_FEE',
                'LOAN_TRANSACTION',
                'SAVINGS_TRANSACTION',
                'CARD_TRANSACTION_REVERSAL',
                'COMPOSED_TRANSACTIONS',
                'UNION_TRANSACTIONS',
                'INVESTOR_FUND',
                'PRINCIPAL_PAYMENT_SETTINGS',
                'LOAN_ACCOUNT_GUARANTY',
                'TASK',
                'DOCUMENT_TEMPLATE',
                'INDEX_RATE',
                'INDEX_RATE_SOURCE',
                'INTEREST_PRODUCT_SETTINGS',
                'MCC_EXPIRATION',
                'PRODUCT_ARREARS_SETTINGS',
                'ACCOUNT_INTEREST_RATE_SETTINGS',
                'LENDING_ACCOUNT_CONTRACT',
                'REVOLVING_ACCOUNT',
                'LENDING_PRODUCT_CONTRACT',
            ])
            .describe('The type of the owner (entity) to whom a data field belongs to')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the duplicate field constraint, auto generated, unique').optional(),
        groupIndex: z.number().int().describe('Used for creating an AND clause between constraints').optional(),
    })
    .describe('Represents a duplicate constraint which needs to apply when saving entities')

export type DuplicateFieldConstraint = z.infer<typeof DuplicateFieldConstraint>

export const DashboardConfiguration = z
    .object({
        creationDate: z.string().datetime({ offset: true }).describe('The date dashboard configuration was created').optional(),
        encodedKey: z.string().describe('The encoded key of the dashboard configuration, auto generated, unique').optional(),
        name: z
            .enum([
                'LATEST_ACTIVITY',
                'TASKS',
                'FAVOURITE_VIEWS',
                'INDICATORS',
                'CURRENT_TILLS',
                'CLIENTS',
                'UPCOMING_REPAYMENTS',
                'NONE',
            ])
            .describe('The Dashboard option name')
            .optional(),
    })
    .describe('Response representation of the dashboard configuration')

export type DashboardConfiguration = z.infer<typeof DashboardConfiguration>

export const ErrorResponse = z.object({
    errors: RestError.array().optional(),
})

export type ErrorResponse = z.infer<typeof ErrorResponse>

export const GeneralSetup = z
    .object({
        accountingCutOffTime: z.string().describe('The accounting cut off time.').optional(),
        approvalDisbursalTwoManRuleEnabled: z
            .boolean()
            .describe('`TRUE` if separate users are required for approval and disbursal, `FALSE` otherwise.')
            .optional(),
        arrearsDaysBeforeWriteOff: z
            .number()
            .int()
            .describe('The number of days that are required before an account can be written off.')
            .optional(),
        assignmentConstraints: z
            .enum(['BRANCH', 'CENTRE', 'CREDIT_OFFICER', 'GROUP'])
            .array()
            .describe('The list of required assignments for clients and groups.')
            .optional(),
        automatedAccountingClosuresInterval: z
            .number()
            .int()
            .describe(
                'The interval (number of days) between the execution of automated accounting closures. If this number is 0, automated closure is performed.',
            )
            .optional(),
        clientIdFormat: z.string().describe('The pattern for generating individual client IDs.').optional(),
        dashboardConfigurations: z.set(DashboardConfiguration).describe('The dashboard configuration.').optional(),
        dateFormats: z
            .record(z.string().optional())
            .describe('The date (dd-MM-yyyy) or date time (dd-MM-yyyy HH:mm:ss) formats.')
            .optional(),
        decimalSeparator: z
            .enum(['COMMA', 'POINT'])
            .describe('The symbol used to mark the border between the integral and the fractional parts of a decimal numeral.')
            .optional(),
        defaultClientRoleKey: z.string().describe('The client role used as default.').optional(),
        defaultClientState: z
            .enum(['PENDING_APPROVAL', 'INACTIVE', 'ACTIVE', 'EXITED', 'BLACKLISTED', 'REJECTED'])
            .describe('The client default state.')
            .optional(),
        defaultGroupRoleKey: z.string().describe('The group role used as default.').optional(),
        defaultLineOfCreditState: z
            .enum(['PENDING_APPROVAL', 'APPROVED', 'ACTIVE', 'CLOSED', 'WITHDRAWN', 'REJECTED'])
            .describe('The line of credit default state.')
            .optional(),
        defaultTransactionChannelKey: z.string().describe('The transaction channel that is used as the default.').optional(),
        duplicateClientChecks: DuplicateFieldConstraint.array()
            .describe('The list of duplicate client constraints that are available in the administration and can be performed.')
            .optional(),
        duplicateClientConstraintAction: z
            .enum(['NONE', 'WARNING', 'ERROR'])
            .describe('The action to be taken when the duplicate client validation fails.')
            .optional(),
        enabledComponents: z
            .enum(['LOANS', 'DEPOSITS', 'BRANCHES', 'CENTRES', 'CLIENTS', 'GROUPS', 'ACCOUNTING', 'CREDIT_OFFICERS'])
            .array()
            .describe('The list of all the enabled components for the current tenant.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the general setup, which is auto generated, and unique.').optional(),
        eodProcessingMethod: z
            .enum(['AUTOMATIC', 'MANUAL'])
            .describe(
                'The end of day (EOD) processing settings. The `AUTOMATIC` EOD processing runs every midnight. The `MANUAL` EOD processing runs when the client initiates the action from the Mambu UI.',
            )
            .optional(),
        exposureAmount: z.number().describe('The maximum exposure amount.').optional(),
        exposureType: z
            .enum(['UNLIMITED', 'SUM_OF_LOANS', 'SUM_OF_LOANS_MINUS_SAVINGS'])
            .describe('The maximum exposure a client can have in outstanding loans at any time.')
            .optional(),
        groupIdFormat: z.string().describe('The pattern for generating group client IDs.').optional(),
        groupSizeLimitType: z.enum(['HARD', 'WARNING', 'NONE']).describe('The group size limitation type.').optional(),
        interBranchTransferGLAccountKey: z
            .string()
            .describe('The key of the general ledger (GL) account which will be used for inter-branch transfers.')
            .optional(),
        lineOfCreditIdFormat: z
            .string()
            .describe('The unique pattern after which all the lines of credit IDs should be created.')
            .optional(),
        maxAllowedIdDocumentAttachments: z.number().int().describe('The maximum allowed ID document attachments.').optional(),
        maxAllowedJournalEntryDocumentAttachments: z
            .number()
            .int()
            .describe('The maximum allowed journal entry attachments.')
            .optional(),
        maxAllowedUndoClosurePeriod: z
            .number()
            .int()
            .describe('The maximum number of days users are allowed to undo of close obligations met for a loan account.')
            .optional(),
        maxGroupSizeLimit: z
            .number()
            .int()
            .describe('The maximum group size allowed. A null value means the limit is ignored.')
            .optional(),
        minGroupSizeLimit: z
            .number()
            .int()
            .describe('The minimum group size allowed. A null value means the limit is ignored.')
            .optional(),
        multipleGroupMemberships: z
            .enum(['UNLIMITED', 'ONE_GROUP'])
            .describe('The constraint on whether clients can belong to more than one group or not.')
            .optional(),
        multipleLoans: z
            .enum(['UNLIMITED', 'ONE_LOAN'])
            .describe('The option that shows if multiple loans are allowed or not.')
            .optional(),
        otherIdDocumentsEnabled: z.boolean().describe('`TRUE` if other ID documents are enabled, `FALSE` otherwise.').optional(),
        overdraftInterestEodBalanceDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date used when computing overdraft interest for savings accounts.')
            .optional(),
        tillIdFormat: z.string().describe('The unique pattern after which all the till IDs should be created.').optional(),
    })
    .describe('Represents the general setup for an organization.')

export type GeneralSetup = z.infer<typeof GeneralSetup>
