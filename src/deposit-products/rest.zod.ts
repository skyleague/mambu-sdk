/**
 * Generated by @skyleague/therefore
 * Do not manually touch this
 */
/* eslint-disable */

import { z } from 'zod'

export const DepositProductOverdraftInterestRateTier = z
    .object({
        encodedKey: z.string().describe('The encoded key of the interest rate tier, auto generated, unique').optional(),
        endingBalance: z
            .number()
            .describe('The top-limit value for the account balance in order to determine if this tier is used or not')
            .optional(),
        interestRate: z
            .number()
            .describe(
                'The rate used for computing the interest for an account which has the balance less than the ending balance',
            ),
    })
    .describe('Used for TIERED interest rates, holds the values to define how the interest is computed')

export type DepositProductOverdraftInterestRateTier = z.infer<typeof DepositProductOverdraftInterestRateTier>

export const DecimalInterval = z
    .object({
        defaultValue: z
            .number()
            .describe('The default value, will be used in case no other value was filled in by the user.')
            .optional(),
        maxValue: z.number().describe('The maximum value.').optional(),
        minValue: z.number().describe('The minimum value.').optional(),
    })
    .describe('Decimal constraints, like min/max/default.')

export type DecimalInterval = z.infer<typeof DecimalInterval>

export const DepositProductInterestRateTier = z
    .object({
        encodedKey: z.string().describe('The encoded key of the interest rate tier, auto generated, unique').optional(),
        endingBalance: z
            .number()
            .describe('The top-limit value for the account balance in order to determine if this tier is used or not')
            .optional(),
        endingDay: z
            .number()
            .int()
            .describe(
                'The top-limit value for the account period since activation in order to determine if this tier is used or not',
            )
            .optional(),
        interestRate: z
            .number()
            .describe(
                'The rate used for computing the interest for an account which has the balance less than the ending balance',
            ),
    })
    .describe('Used or TIERED interest rates, holds the values to define how the interest is computed')

export type DepositProductInterestRateTier = z.infer<typeof DepositProductInterestRateTier>

export const MonthAndDay = z
    .object({
        day: z.number().int().describe('The day in the month').optional(),
        month: z.number().int().describe('The month of the year').optional(),
    })
    .describe(`Wrapper for month and day for instances where the year isn't needed`)

export type MonthAndDay = z.infer<typeof MonthAndDay>

export const DepositGLAccountingRule = z
    .object({
        encodedKey: z.string().describe('The encoded key of the accounting rule, auto generated, unique.').optional(),
        financialResource: z
            .enum([
                'PORTFOLIO_CONTROL',
                'FUND_SOURCE',
                'WRITE_OFF_EXPENSE',
                'INTEREST_INCOME',
                'PAYMENT_HOLIDAY_INTEREST_INCOME',
                'TAXES_PAYABLE',
                'FEE_INCOME',
                'PENALTY_INCOME',
                'NEGATIVE_INTEREST_PAYABLE_RECEIVABLE',
                'NEGATIVE_INTEREST_PAYABLE',
                'INTEREST_RECEIVABLE',
                'PAYMENT_HOLIDAY_INTEREST_RECEIVABLE',
                'FEE_RECEIVABLE',
                'PENALTY_RECEIVABLE',
                'TAXES_RECEIVABLE',
                'DEFERRED_INTERESTS_INCOME',
                'DEFERRED_FEE_INCOME',
                'DEFERRED_TAXES',
                'DEPOSIT_REFERENCE',
                'SAVINGS_CONTROL',
                'INTEREST_EXPENSE',
                'INTEREST_PAYABLE',
                'NEGATIVE_INTEREST_INCOME',
                'NEGATIVE_INTEREST_RECEIVABLE',
                'OVERDRAFT_PORTFOLIO_CONTROL',
                'OVERDRAFT_INTEREST_INCOME',
                'OVERDRAFT_WRITE_OFF_EXPENSE',
                'OVERDRAFT_INTEREST_RECEIVABLE',
                'INTER_BRANCH_TRANSFER',
                'INTEREST_FROM_ARREARS_INCOME',
                'INTEREST_FROM_ARREARS_RECEIVABLE',
                'INTEREST_FROM_ARREARS_WRITE_OFF_EXPENSE',
                'PROFIT_EXPENSE',
                'PROFIT_PAYABLE',
            ])
            .describe(
                'General Ledger Financial Resources used to setup the product accounting rules and determine the credit and debit accounts when logging journal entries',
            ),
        glAccountKey: z.string().describe('The encoded key of the account that is mapped to the financialResource'),
    })
    .describe(
        'The GL accounting rule, it maps a financial resource with a GL account for a specific product (i.e loan or saving).',
    )

export type DepositGLAccountingRule = z.infer<typeof DepositGLAccountingRule>

export const DepositProductOverdraftInterestRateSettings = z
    .object({
        indexSourceKey: z.string().describe('Index rate source key.').optional(),
        interestChargeFrequency: z
            .enum(['ANNUALIZED', 'EVERY_MONTH', 'EVERY_FOUR_WEEKS', 'EVERY_WEEK', 'EVERY_DAY', 'EVERY_X_DAYS'])
            .describe('The interval used for determining how often is interest charged')
            .optional(),
        interestChargeFrequencyCount: z.number().int().describe('the count of units to apply over the interval').optional(),
        interestRate: DecimalInterval.optional(),
        interestRateReviewCount: z.number().int().describe('Interest rate review frequency unit count').optional(),
        interestRateReviewUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS'])
            .describe('Interest rate review frequency measurement unit')
            .optional(),
        interestRateSource: z
            .enum(['FIXED_INTEREST_RATE', 'INDEX_INTEREST_RATE'])
            .describe('Interest calculation method: fixed or (interest spread + active organization index interest rate)')
            .optional(),
        interestRateTerms: z
            .enum(['FIXED', 'TIERED', 'TIERED_PERIOD', 'TIERED_BAND'])
            .describe('The option for how is the interest rate determined when being accrued for an account')
            .optional(),
        interestRateTiers: DepositProductOverdraftInterestRateTier.array()
            .describe('The list of interest rate tiers available for the current settings instance')
            .optional(),
    })
    .describe(
        'The overdraft interest settings, defines constraints regarding interest that will be used on the account created based on this product.',
    )

export type DepositProductOverdraftInterestRateSettings = z.infer<typeof DepositProductOverdraftInterestRateSettings>

export const IntegerInterval = z
    .object({
        defaultValue: z
            .number()
            .int()
            .describe('The default value, will be used in case no other value was filled in by the user.')
            .optional(),
        maxValue: z.number().int().describe('The maximum value.').optional(),
        minValue: z.number().int().describe('The minimum value.').optional(),
    })
    .describe('Decimal integer, like min/max/default.')

export type IntegerInterval = z.infer<typeof IntegerInterval>

export const AmountDecimalInterval = z
    .object({
        defaultValue: z
            .number()
            .describe('The default value, will be used in case no other value was filled in by the user.')
            .optional(),
        maxValue: z.number().describe('The maximum value.').optional(),
        minValue: z.number().describe('The minimum value.').optional(),
    })
    .describe('Decimal constraints, like min/max/default.')

export type AmountDecimalInterval = z.infer<typeof AmountDecimalInterval>

export const DepositProductInterestRateSettings = z
    .object({
        accrueInterestAfterMaturity: z
            .boolean()
            .describe(
                'If the product supports this option, specify if the interest should be accrued after the account maturity date',
            )
            .optional(),
        allowNegativeInterestRate: z
            .boolean()
            .describe('Indicator whether the deposit product allows negative values for interest rate')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the interest rate tier, auto generated, unique').optional(),
        indexSourceKey: z.string().describe('Index rate source key.').optional(),
        interestChargeFrequency: z
            .enum(['ANNUALIZED', 'EVERY_MONTH', 'EVERY_FOUR_WEEKS', 'EVERY_WEEK', 'EVERY_DAY', 'EVERY_X_DAYS'])
            .describe('The interval used for determining how often is interest charged')
            .optional(),
        interestChargeFrequencyCount: z.number().int().describe('the count of units to apply over the interval').optional(),
        interestRate: DecimalInterval.optional(),
        interestRateReviewCount: z.number().int().describe('Interest rate review frequency unit count').optional(),
        interestRateReviewUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS'])
            .describe('Interest rate review frequency measurement unit')
            .optional(),
        interestRateSource: z
            .enum(['FIXED_INTEREST_RATE', 'INDEX_INTEREST_RATE'])
            .describe('Interest calculation method: fixed or (interest spread + active organization index interest rate)')
            .optional(),
        interestRateTerms: z
            .enum(['FIXED', 'TIERED', 'TIERED_PERIOD', 'TIERED_BAND'])
            .describe('The option for how is the interest rate determined when being accrued for an account')
            .optional(),
        interestRateTiers: DepositProductInterestRateTier.array()
            .describe('The list of interest rate tiers available for the current settings instance')
            .optional(),
    })
    .describe(
        'The interest settings, defines constraints regarding interest that will be used on the deposit created based on this product.',
    )

export type DepositProductInterestRateSettings = z.infer<typeof DepositProductInterestRateSettings>

export const InterestPaymentSettings = z
    .object({
        interestPaymentDates: MonthAndDay.array()
            .describe('List of all dates on which the interest is payed into deposit account')
            .optional(),
        interestPaymentPoint: z
            .enum([
                'FIRST_DAY_OF_MONTH',
                'EVERY_WEEK',
                'EVERY_OTHER_WEEK',
                'EVERY_MONTH',
                'EVERY_3_MONTHS',
                'ON_FIXED_DATES',
                'DAILY',
                'ANNUALLY',
                'BI_ANNUALLY',
                'ON_ACCOUNT_MATURITY',
            ])
            .describe('Specifies when the interest should be paid to the deposit account')
            .optional(),
    })
    .describe('Defines the interest payment settings for the deposit product and for deposits created based on this product')

export type InterestPaymentSettings = z.infer<typeof InterestPaymentSettings>

export const DepositProductPredefinedFee = z
    .object({
        accountingRules: DepositGLAccountingRule.array()
            .describe('A list of accounting rules defined for this fee. If null, product default rules are selected.')
            .optional(),
        amount: z.number().describe('The amount of the fee').optional(),
        amountCalculationFunctionName: z.string().describe('External function').optional(),
        amountCalculationMethod: z
            .enum(['FLAT', 'MAMBU_FUNCTION'])
            .describe('The amount from which the fee is calculated using percentageAmount')
            .optional(),
        applyDateMethod: z
            .enum(['MONTHLY_FROM_ACTIVATION', 'FIRST_OF_EVERY_MONTH'])
            .describe('Shows when a fee should be applied; to be used with monthly deposit fees')
            .optional(),
        creationDate: z.string().datetime({ offset: true }).describe('Shows the creation date of the fee').optional(),
        encodedKey: z.string().describe('The encoded key of the predefined fee, auto generated, unique').optional(),
        feeApplication: z.enum(['REQUIRED', 'OPTIONAL']).describe('The type of fee application when disbursement is applied'),
        id: z.string().describe('The id of the fee').optional(),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('Shows the last modified date of the fee').optional(),
        name: z.string().describe('The name of the fee').optional(),
        state: z.enum(['ACTIVE', 'INACTIVE']).describe('Indicates the state of the fee'),
        trigger: z.enum(['MANUAL', 'MONTHLY_FEE', 'ARBITRARY']).describe('Shows the event that will trigger a fee'),
    })
    .describe('The response representation of the PredefinedFee. Represents a fee with a defined name and a fixed value.')

export type DepositProductPredefinedFee = z.infer<typeof DepositProductPredefinedFee>

export const Currency = z
    .object({
        code: z
            .enum([
                'AED',
                'AFN',
                'ALL',
                'AMD',
                'ANG',
                'AOA',
                'ARS',
                'AUD',
                'AWG',
                'AZN',
                'BAM',
                'BBD',
                'BDT',
                'BGN',
                'BHD',
                'BIF',
                'BMD',
                'BND',
                'BOB',
                'BOV',
                'BRL',
                'BSD',
                'BTN',
                'BWP',
                'BYR',
                'BYN',
                'BZD',
                'CAD',
                'CDF',
                'CHE',
                'CHF',
                'CHW',
                'CLF',
                'CLP',
                'CNY',
                'COP',
                'COU',
                'CRC',
                'CUC',
                'CUP',
                'CVE',
                'CZK',
                'DJF',
                'DKK',
                'DOP',
                'DZD',
                'EGP',
                'ERN',
                'ETB',
                'EUR',
                'FJD',
                'FKP',
                'GBP',
                'GEL',
                'GHS',
                'GIP',
                'GMD',
                'GNF',
                'GTQ',
                'GYD',
                'HKD',
                'HNL',
                'HRK',
                'HTG',
                'HUF',
                'IDR',
                'ILS',
                'INR',
                'IQD',
                'IRR',
                'ISK',
                'JMD',
                'JOD',
                'JPY',
                'KES',
                'KGS',
                'KHR',
                'KMF',
                'KPW',
                'KRW',
                'KWD',
                'KYD',
                'KZT',
                'LAK',
                'LBP',
                'LKR',
                'LRD',
                'LSL',
                'LTL',
                'LVL',
                'LYD',
                'MAD',
                'MDL',
                'MGA',
                'MKD',
                'MMK',
                'MNT',
                'MOP',
                'MRO',
                'MRU',
                'MUR',
                'MVR',
                'MWK',
                'MXN',
                'MXV',
                'MYR',
                'MZN',
                'NAD',
                'NGN',
                'NIO',
                'NOK',
                'NPR',
                'NZD',
                'OMR',
                'PAB',
                'PEN',
                'PGK',
                'PHP',
                'PKR',
                'PLN',
                'PYG',
                'QAR',
                'RON',
                'RSD',
                'RUB',
                'RWF',
                'SAR',
                'SBD',
                'SCR',
                'SDG',
                'SEK',
                'SGD',
                'SHP',
                'SLL',
                'SOS',
                'SRD',
                'STD',
                'STN',
                'SVC',
                'SYP',
                'SZL',
                'THB',
                'TJS',
                'TMT',
                'TND',
                'TOP',
                'TRY',
                'TTD',
                'TWD',
                'TZS',
                'UAH',
                'UGX',
                'USD',
                'USN',
                'UYI',
                'UYU',
                'UYW',
                'UZS',
                'VED',
                'VEF',
                'VES',
                'VND',
                'VUV',
                'WST',
                'XAG',
                'XAU',
                'XAF',
                'XBA',
                'XBB',
                'XBC',
                'XBD',
                'XCD',
                'XDR',
                'XOF',
                'XPD',
                'XPF',
                'XPT',
                'XSU',
                'XTS',
                'XUA',
                'XXX',
                'YER',
                'ZAR',
                'ZIG',
                'ZMK',
                'ZWL',
                'ZMW',
                'SSP',
                'NON_FIAT',
            ])
            .describe('Fiat(ISO-4217) currency code or NON_FIAT for non fiat currencies.')
            .optional(),
        currencyCode: z.string().describe('Currency code for NON_FIAT currency.').optional(),
    })
    .describe('Represents a currency eg. USD, EUR.')

export type Currency = z.infer<typeof Currency>

export const BranchSettings = z
    .object({
        availableProductBranches: z
            .string()
            .array()
            .describe('Holds the encoded keys of the branches this product should be available for.')
            .optional(),
        forAllBranches: z.boolean().describe('Indicates if this product should be available for all branches').optional(),
    })
    .describe('Holds information about branch availability for the product.')

export type BranchSettings = z.infer<typeof BranchSettings>

export const DocumentTemplate = z
    .object({
        creationDate: z.string().datetime({ offset: true }).describe('The creation date of the document').optional(),
        encodedKey: z.string().describe('The document encodedKey').optional(),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('The last modified date of the document').optional(),
        name: z.string().describe('The name the document').optional(),
        type: z.enum(['ACCOUNT', 'TRANSACTION', 'ACCOUNT_WITH_TRANSACTIONS']).describe('The type of the template').optional(),
    })
    .describe('Template documents of the product.')

export type DocumentTemplate = z.infer<typeof DocumentTemplate>

export const DepositProductTaxSettings = z
    .object({
        withholdingTaxEnabled: z.boolean().describe('Whether withholding taxes are enabled for this product or not').optional(),
    })
    .describe('Tax settings, defines some settings for taxes on the loan product')

export type DepositProductTaxSettings = z.infer<typeof DepositProductTaxSettings>

export const DepositProductOverdraftSettings = z
    .object({
        allowOverdraft: z.boolean().describe('Whether the accounts for this product may have overdraft').optional(),
        allowTechnicalOverdraft: z
            .boolean()
            .describe('Whether the accounts for this product may have technical overdraft')
            .optional(),
        maxOverdraftLimit: z.number().describe('How much money may be taken out for the account to go negative').optional(),
    })
    .describe('The overdraft settings of the deposit product')

export type DepositProductOverdraftSettings = z.infer<typeof DepositProductOverdraftSettings>

export const OverdraftInterestSettings = z
    .object({
        daysInYear: z
            .enum(['ACTUAL_365_FIXED', 'ACTUAL_360', 'ACTUAL_ACTUAL_ISDA', 'E30_360', 'E30_42_365', 'BUS_252'])
            .describe('How many days in a year should be used for interest calculations')
            .optional(),
        interestCalculationBalance: z
            .enum(['MINIMUM', 'AVERAGE', 'END_OF_DAY', 'MINIMUM_TO_END_OF_DAY', 'FRENCH_INTEREST_ACCRUAL'])
            .describe(
                'The balance which is used for the overdraft interest calculation. Default value is MINIMUM. If set to null on a PUT call and the product allows overdrafts, the null value is ignored and not changed.',
            )
            .optional(),
        interestRateSettings: DepositProductOverdraftInterestRateSettings.optional(),
    })
    .describe('Overdraft settings for the product')

export type OverdraftInterestSettings = z.infer<typeof OverdraftInterestSettings>

export const DepositProductOffsetSettings = z
    .object({
        allowOffset: z
            .boolean()
            .describe('Specify if the product allow to create accounts which can be used as offset for loans')
            .optional(),
    })
    .describe('The offset settings, holds information about offset.')

export type DepositProductOffsetSettings = z.infer<typeof DepositProductOffsetSettings>

export const DepositNewAccountSettings = z
    .object({
        idGeneratorType: z
            .enum(['INCREMENTAL_NUMBER', 'RANDOM_PATTERN'])
            .describe('The type of generator used for IDs creation.'),
        idPattern: z.string().describe('The pattern that will be used for ID validation (as referred to as an input mask).'),
    })
    .describe('New Account settings for deposit accounts')

export type DepositNewAccountSettings = z.infer<typeof DepositNewAccountSettings>

export const DepositMaturitySettings = z
    .object({
        maturityPeriod: IntegerInterval.optional(),
        maturityPeriodUnit: z.enum(['DAYS', 'WEEKS', 'MONTHS']).describe('maturity period measurement unit').optional(),
    })
    .describe('The maturity settings for the product.')

export type DepositMaturitySettings = z.infer<typeof DepositMaturitySettings>

export const DepositProductInternalControls = z
    .object({
        dormancyPeriodDays: z
            .number()
            .int()
            .describe('Specifies the number of days for an account to be fully paid in order to auto close it.')
            .optional(),
        maxWithdrawalAmount: z.number().describe('Max amount per withdrawal').optional(),
        openingBalance: AmountDecimalInterval.optional(),
        recommendedDepositAmount: z.number().describe('Recommended amount for a deposit').optional(),
    })
    .describe('Constraints and automated actions and that will be applied on the accounts.')

export type DepositProductInternalControls = z.infer<typeof DepositProductInternalControls>

export const DepositProductInterestSettings = z
    .object({
        collectInterestWhenLocked: z.boolean().describe('Whether locked accounts still collect Interest or not').optional(),
        daysInYear: z
            .enum(['ACTUAL_365_FIXED', 'ACTUAL_360', 'ACTUAL_ACTUAL_ISDA', 'E30_360', 'E30_42_365', 'BUS_252'])
            .describe('How many days in a year should be used for interest calculations')
            .optional(),
        interestCalculationBalance: z
            .enum(['MINIMUM', 'AVERAGE', 'END_OF_DAY', 'MINIMUM_TO_END_OF_DAY', 'FRENCH_INTEREST_ACCRUAL'])
            .describe('The balance which is used for the Interest calculation')
            .optional(),
        interestGainsProvidedEndDate: z
            .string()
            .date()
            .describe('The date when the accounts under this product, will no longer have interest gains provided')
            .optional(),
        interestGainsProvidedStartDate: z
            .string()
            .date()
            .describe(
                'The date when the accounts of this product will start to have interest gains provided. Starting with this date 0 interest rate is enforced on the accounts of this product.',
            )
            .optional(),
        interestPaidIntoAccount: z.boolean().describe('If interest should be payed into the deposit account').optional(),
        interestPaymentSettings: InterestPaymentSettings.optional(),
        interestRateSettings: DepositProductInterestRateSettings.optional(),
        maximumBalance: z.number().describe('The maximum balance used for Interest calculation').optional(),
    })
    .describe(
        'The interest settings, defines constraints regarding interest that will be used on the deposit account based on this product.',
    )

export type DepositProductInterestSettings = z.infer<typeof DepositProductInterestSettings>

export const DepositProductFeeSettings = z
    .object({
        allowArbitraryFees: z
            .boolean()
            .describe(
                `Only if true users will be able to apply fees, for current object, of type 'Other'; these fees can have any amount.`,
            )
            .optional(),
        fees: DepositProductPredefinedFee.array()
            .describe('List of all fees that can be applied for accounts of this loan product.')
            .optional(),
    })
    .describe('Defines fees settings for the product.')

export type DepositProductFeeSettings = z.infer<typeof DepositProductFeeSettings>

export const DepositProductCurrencySettings = z
    .object({
        currencies: Currency.array().describe('Currencies that can be used by accounts of this product').optional(),
    })
    .describe('Currency settings for the product.')

export type DepositProductCurrencySettings = z.infer<typeof DepositProductCurrencySettings>

export const CreditArrangementSettings = z
    .object({
        creditArrangementRequirement: z
            .enum(['OPTIONAL', 'REQUIRED', 'NOT_REQUIRED'])
            .describe('Shows whether accounts created after this product can/should be part of a line of credit.')
            .optional(),
    })
    .describe('The funding settings, holds the settings regarding the funding for the loan product.')

export type CreditArrangementSettings = z.infer<typeof CreditArrangementSettings>

export const DepositProductAvailabilitySettings = z
    .object({
        availableFor: z
            .enum(['INDIVIDUALS', 'PURE_GROUPS'])
            .array()
            .describe('Holds the entities this product is available for. i.e Individuals')
            .optional(),
        branchSettings: BranchSettings.optional(),
    })
    .describe('Holds information about product availability.')

export type DepositProductAvailabilitySettings = z.infer<typeof DepositProductAvailabilitySettings>

export const DepositProductAccountingSettings = z
    .object({
        accountingMethod: z.enum(['NONE', 'CASH', 'ACCRUAL']).describe('The calculation method used for accounting.'),
        accountingRules: DepositGLAccountingRule.array().describe('A list of accounting rules for the product.').optional(),
        interestAccrualCalculation: z
            .enum(['NONE', 'AGGREGATED_AMOUNT', 'BREAKDOWN_PER_ACCOUNT'])
            .describe('The accounting interest calculation option selected for the product.')
            .optional(),
        interestAccruedAccountingMethod: z
            .enum(['NONE', 'DAILY', 'END_OF_MONTH'])
            .describe('The interval defined for a product when the interest accrues should be maintained.')
            .optional(),
    })
    .describe('Accounting settings, defines the accounting settings for the product.')

export type DepositProductAccountingSettings = z.infer<typeof DepositProductAccountingSettings>

export const RestError = z.object({
    errorCode: z.number().int().optional(),
    errorReason: z.string().optional(),
    errorSource: z.string().optional(),
})

export type RestError = z.infer<typeof RestError>

export const DepositProduct = z
    .object({
        accountingSettings: DepositProductAccountingSettings,
        availabilitySettings: DepositProductAvailabilitySettings.optional(),
        category: z
            .enum([
                'PERSONAL_DEPOSIT',
                'BUSINESS_DEPOSIT',
                'DAILY_BANKING_ACCOUNTS',
                'BUSINESS_BANKING_ACCOUNTS',
                'STORED_VALUE_ACCOUNTS',
                'UNCATEGORIZED',
            ])
            .describe('Indicates the category that the product belongs to')
            .optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The date this product was created').optional(),
        creditArrangementSettings: CreditArrangementSettings.optional(),
        currencySettings: DepositProductCurrencySettings.optional(),
        encodedKey: z.string().describe('The encoded key of the deposit product, auto generated, unique').optional(),
        feesSettings: DepositProductFeeSettings.optional(),
        id: z.string().describe('The id of the product, can be generated and customized, unique'),
        interestSettings: DepositProductInterestSettings.optional(),
        internalControls: DepositProductInternalControls.optional(),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('The last date the product was updated').optional(),
        maturitySettings: DepositMaturitySettings.optional(),
        name: z.string().describe('The name of the product'),
        newAccountSettings: DepositNewAccountSettings,
        notes: z.string().describe('Some notes/a description about the product').optional(),
        offsetSettings: DepositProductOffsetSettings.optional(),
        overdraftInterestSettings: OverdraftInterestSettings.optional(),
        overdraftSettings: DepositProductOverdraftSettings.optional(),
        state: z.enum(['ACTIVE', 'INACTIVE']).describe('Indicates the current state of the product'),
        taxSettings: DepositProductTaxSettings.optional(),
        templates: DocumentTemplate.array().describe('Template documents of the product.').optional(),
        type: z
            .enum(['CURRENT_ACCOUNT', 'REGULAR_SAVINGS', 'FIXED_DEPOSIT', 'SAVINGS_PLAN', 'INVESTOR_ACCOUNT'])
            .describe('Indicates the type of product.'),
    })
    .passthrough()
    .describe('A deposit product defines the terms and constraints on deposit accounts')

export type DepositProduct = z.infer<typeof DepositProduct>

export const PatchOperation = z
    .object({
        from: z.string().describe('The field from where a value should be moved, when using move').optional(),
        op: z.enum(['ADD', 'REPLACE', 'REMOVE', 'MOVE']).describe('The change to perform'),
        path: z.string().describe('The field to perform the operation on'),
        value: z.unknown().describe('The value of the field, can be null').optional(),
    })
    .describe('A single change that needs to be made to a resource')

export type PatchOperation = z.infer<typeof PatchOperation>

export const DepositProductAction = z
    .object({
        action: z
            .literal('UPDATE_INTEREST_SETTINGS')
            .describe(
                'The action type to be applied. When UPDATE_INTEREST_SETTINGS action type is used, all the existing deposit accounts will be updated with the latest interest-related fields at the end of day job execution',
            ),
    })
    .describe('Specify the batch update action details for a deposit product.')

export type DepositProductAction = z.infer<typeof DepositProductAction>

export const DepositProductActionResponse = z
    .object({
        state: z.literal('QUEUED').describe('The state of the deposit product action').optional(),
    })
    .describe('Represents the response returned after a batch update action for a deposit product.')

export type DepositProductActionResponse = z.infer<typeof DepositProductActionResponse>

export const ErrorResponse = z.object({
    errors: RestError.array().optional(),
})

export type ErrorResponse = z.infer<typeof ErrorResponse>

export const GetAllResponse = DepositProduct.array()

export type GetAllResponse = z.infer<typeof GetAllResponse>

export const PatchRequest = PatchOperation.array()

export type PatchRequest = z.infer<typeof PatchRequest>
