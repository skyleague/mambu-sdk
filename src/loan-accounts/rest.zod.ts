/**
 * Generated by @skyleague/therefore@v1.0.0-local
 * Do not manually touch this
 */
/* eslint-disable */

import { z } from 'zod'

export const TransactionInterestSettings = z
    .object({
        indexInterestRate: z.number().describe('The value of the index interest rate').optional(),
        interestRate: z
            .number()
            .describe(
                'The interest rate. Represents the interest rate for the loan account. The interest on loans is accrued on a daily basis, which allows charging the clients only for the days they actually used the loan amount.',
            )
            .optional(),
    })
    .describe('The interest settings, holds all the properties regarding interests for the loan account.')

export const CardAcceptor = z
    .object({
        city: z.string().describe('The city in which the card acceptor has the business.').optional(),
        country: z.string().describe('The country in which the card acceptor has the business.').optional(),
        mcc: z.number().int().describe('The Merchant Category Code of the card acceptor.').optional(),
        name: z.string().describe('The name of the card acceptor.').optional(),
        state: z.string().describe('The state in which the card acceptor has the business.').optional(),
        street: z.string().describe('The street in which the card acceptor has the business.').optional(),
        zip: z.string().describe('The ZIP code of the location in which the card acceptor has the business.').optional(),
    })
    .describe('The details of the card acceptor (merchant) in a transaction hold.')

export const CustomPredefinedFee = z
    .object({
        amount: z.number().describe('The amount of the custom fee.').optional(),
        encodedKey: z.string().describe('The encoded key of the custom predefined fee, auto generated, unique.').optional(),
        percentage: z.number().describe('The percentage of the custom fee.').optional(),
        predefinedFeeEncodedKey: z.string().describe('The encoded key of the predefined fee').optional(),
    })
    .describe(
        'The custom predefined fees, they may be used as the expected predefined fees that will be applied on the disbursement.',
    )

export const TrancheDisbursementDetails = z
    .object({
        disbursementTransactionKey: z
            .string()
            .describe(
                'The key of the disbursement transaction logged when this tranche was disbursed. This field will be null until the tranche disbursement',
            )
            .optional(),
        expectedDisbursementDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when this tranche is supposed to be disbursed (as Organization Time)')
            .optional(),
    })
    .describe('The disbursement details regarding a loan tranche.')

export const RevolvingAccountSettings = z
    .object({
        numberOfPreviewedInstalments: z.number().int().describe('The number of previewed instalments').optional(),
    })
    .describe('The number of previewed instalments for an account')

export const PeriodicPayment = z
    .object({
        amount: z.number().describe('The PMT value used in periodic payment'),
        encodedKey: z.string().describe('The encoded key of the periodic payment, auto generated, unique.').optional(),
        toInstallment: z.number().int().describe(`The installment's position up to which the PMT will be used`),
    })
    .describe(
        'For fixed term loans there is the possibility to define a payment plan. A payment plan consists of multiple periodic payments. This class holds information about a periodic payment.',
    )

export const BillingCycleDays = z
    .object({
        days: z.set(z.number().int()).describe('The billing cycle start days in case it is enabled').optional(),
    })
    .describe('Defines the billing cycles settings for a loan account')

export const PMTAdjustmentThreshold = z
    .object({
        method: z
            .enum(['WORKING_DAYS', 'CALENDAR_DAYS'])
            .describe('The method used to calculate the PMT Adjustment threshold. Supported value is CALENDAR_DAYS')
            .optional(),
        numberOfDays: z.number().int().describe('The number of days that trigger a PMT Adjustment.').optional(),
    })
    .describe('Represents PMT Adjustment threshold settings for loan accounts and loan products.')

export const DaysInMonth = z
    .object({
        daysInMonth: z
            .number()
            .int()
            .array()
            .describe(
                ' Specifies the day(s) of the month when the interest application dates should be. Only available if the Interest Application Method is InterestApplicationMethodDTO#FIXED_DAYS_OF_MONTH. Currently only 1 value can be specified.',
            )
            .optional(),
        shortMonthHandlingMethod: z
            .enum(['LAST_DAY_IN_MONTH', 'FIRST_DAY_OF_NEXT_MONTH'])
            .describe(
                'Determines how to handle the short months, if they select a fixed day of month > 28. Will be null if no such date is selected. Only available if the Interest Application Method is InterestApplicationMethodDTO#FIXED_DAYS_OF_MONTH.',
            )
            .optional(),
    })
    .describe('Enumeration for days of month and method of handling shorter months.')

export const AccountInterestRateSettings = z
    .object({
        encodedKey: z.string().describe('The encoded key of the interest rate settings, auto generated, unique').optional(),
        indexSourceKey: z.string().describe('Index rate source key.').optional(),
        interestRate: z.number().describe('Interest rate value.').optional(),
        interestRateCeilingValue: z
            .number()
            .describe('Maximum value allowed for index based interest rate. Valid only for index interest rate.')
            .optional(),
        interestRateFloorValue: z
            .number()
            .describe('Minimum value allowed for index based interest rate. Valid only for index interest rate.')
            .optional(),
        interestRateReviewCount: z
            .number()
            .int()
            .describe('Interest rate review frequency unit count. Valid only for index interest rate.')
            .optional(),
        interestRateReviewUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS'])
            .describe('Interest rate review frequency measurement unit. Valid only for index interest rate.')
            .optional(),
        interestRateSource: z
            .enum(['FIXED_INTEREST_RATE', 'INDEX_INTEREST_RATE'])
            .describe('Interest calculation method: fixed or indexed(interest spread + active organization index interest rate)'),
        interestSpread: z.number().describe('Interest spread value.').optional(),
        validFrom: z.string().datetime({ offset: true }).describe('Date since an interest rate is valid'),
    })
    .describe('Adjustable interest rates settings for loan account')

export const LoanTransactionDetails = z
    .object({
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        internalTransfer: z
            .boolean()
            .describe('Whether the transaction was transferred between loans or deposit accounts')
            .optional(),
        targetDepositAccountKey: z
            .string()
            .describe(
                'In case of a transaction to a deposit account this represent the deposit account key to which the transaction was made.',
            )
            .optional(),
        transactionChannelId: z
            .string()
            .describe('The ID of the transaction channel associated with the transaction details.')
            .optional(),
        transactionChannelKey: z
            .string()
            .describe('The encoded key of the transaction channel associated with the transaction details.')
            .optional(),
    })
    .describe('Represents the loan transaction details.')

export const Currency = z
    .object({
        code: z
            .enum([
                'AED',
                'AFN',
                'ALL',
                'AMD',
                'ANG',
                'AOA',
                'ARS',
                'AUD',
                'AWG',
                'AZN',
                'BAM',
                'BBD',
                'BDT',
                'BGN',
                'BHD',
                'BIF',
                'BMD',
                'BND',
                'BOB',
                'BOV',
                'BRL',
                'BSD',
                'BTN',
                'BWP',
                'BYR',
                'BYN',
                'BZD',
                'CAD',
                'CDF',
                'CHE',
                'CHF',
                'CHW',
                'CLF',
                'CLP',
                'CNY',
                'COP',
                'COU',
                'CRC',
                'CUC',
                'CUP',
                'CVE',
                'CZK',
                'DJF',
                'DKK',
                'DOP',
                'DZD',
                'EGP',
                'ERN',
                'ETB',
                'EUR',
                'FJD',
                'FKP',
                'GBP',
                'GEL',
                'GHS',
                'GIP',
                'GMD',
                'GNF',
                'GTQ',
                'GYD',
                'HKD',
                'HNL',
                'HRK',
                'HTG',
                'HUF',
                'IDR',
                'ILS',
                'INR',
                'IQD',
                'IRR',
                'ISK',
                'JMD',
                'JOD',
                'JPY',
                'KES',
                'KGS',
                'KHR',
                'KMF',
                'KPW',
                'KRW',
                'KWD',
                'KYD',
                'KZT',
                'LAK',
                'LBP',
                'LKR',
                'LRD',
                'LSL',
                'LTL',
                'LVL',
                'LYD',
                'MAD',
                'MDL',
                'MGA',
                'MKD',
                'MMK',
                'MNT',
                'MOP',
                'MRO',
                'MRU',
                'MUR',
                'MVR',
                'MWK',
                'MXN',
                'MXV',
                'MYR',
                'MZN',
                'NAD',
                'NGN',
                'NIO',
                'NOK',
                'NPR',
                'NZD',
                'OMR',
                'PAB',
                'PEN',
                'PGK',
                'PHP',
                'PKR',
                'PLN',
                'PYG',
                'QAR',
                'RON',
                'RSD',
                'RUB',
                'RWF',
                'SAR',
                'SBD',
                'SCR',
                'SDG',
                'SEK',
                'SGD',
                'SHP',
                'SLL',
                'SOS',
                'SRD',
                'STD',
                'STN',
                'SVC',
                'SYP',
                'SZL',
                'THB',
                'TJS',
                'TMT',
                'TND',
                'TOP',
                'TRY',
                'TTD',
                'TWD',
                'TZS',
                'UAH',
                'UGX',
                'USD',
                'USN',
                'UYI',
                'UYU',
                'UYW',
                'UZS',
                'VED',
                'VEF',
                'VES',
                'VND',
                'VUV',
                'WST',
                'XAG',
                'XAU',
                'XAF',
                'XBA',
                'XBB',
                'XBC',
                'XBD',
                'XCD',
                'XDR',
                'XOF',
                'XPD',
                'XPF',
                'XPT',
                'XSU',
                'XTS',
                'XUA',
                'XXX',
                'YER',
                'ZAR',
                'ZIG',
                'ZMK',
                'ZWL',
                'ZMW',
                'SSP',
                'NON_FIAT',
            ])
            .describe('Fiat(ISO-4217) currency code or NON_FIAT for non fiat currencies.')
            .optional(),
        currencyCode: z.string().describe('Currency code for NON_FIAT currency.').optional(),
    })
    .describe('Represents a currency eg. USD, EUR.')

export const Amount = z
    .object({
        due: z.number().describe('The due amount.').optional(),
        expected: z.number().describe('The expected amount, which is sum of paid and due amounts.').optional(),
        paid: z.number().describe('The paid amount.').optional(),
    })
    .describe('Represents a simple installment amount structure.')

export const AmountWithReduced = z
    .object({
        due: z.number().describe('The due amount.').optional(),
        expected: z.number().describe('The expected amount, which is sum of paid and due amounts.').optional(),
        paid: z.number().describe('The paid amount.').optional(),
        reduced: z.number().describe('The reduced amount.').optional(),
    })
    .describe('Represents a simple installment amount structure.')

export const FeeAmount = z
    .object({
        due: z.number().describe('The due amount.').optional(),
        expected: z.number().describe('The expected amount, which is sum of paid and due amounts.').optional(),
        expectedUnapplied: z
            .number()
            .describe('The expected amount, which is the sum of unapplied fee and planned fee due amounts.')
            .optional(),
        paid: z.number().describe('The paid amount.').optional(),
    })
    .describe('Represents a fee amount.')

export const TransferDetails = z
    .object({
        linkedDepositTransactionKey: z.string().describe('The key of the related deposit transaction').optional(),
        linkedLoanTransactionKey: z.string().describe('The key of the related loan transaction').optional(),
    })
    .describe('Represents the transfer details, such as the linked transaction key')

export const TransactionDetails = z
    .object({
        transactionChannelId: z
            .string()
            .describe('The id of the transaction channel associated with the transaction details.')
            .optional(),
        transactionChannelKey: z
            .string()
            .describe('The encoded key of the transaction channel associated with the transaction details.')
            .optional(),
    })
    .describe('Contains the details about transaction including fields like transaction channel key and channel id')

export const LoanTerms = z
    .object({
        interestSettings: TransactionInterestSettings.optional(),
        periodicPayment: z
            .number()
            .describe('The periodic payment value logged when changing it for a Balloon Payments account')
            .optional(),
        principalPaymentAmount: z
            .number()
            .describe('The principal payment flat amount logged when changing it for a Revolving Credit account')
            .optional(),
        principalPaymentPercentage: z
            .number()
            .describe('The principal payment percentage value logged when changing it for a Revolving Credit account')
            .optional(),
    })
    .describe('The loan transaction terms')

export const Taxes = z
    .object({
        deferredTaxOnInterestAmount: z
            .number()
            .describe(
                'How much taxes on the interest that was pre-paid were added/removed in account, within this transaction. If there is any deferred tax on interest amount set in this transaction, that amount should be included in this field.',
            )
            .optional(),
        taxOnFeesAmount: z
            .number()
            .describe(
                'How much taxes on the fees that were paid in this transaction were added/removed in account, within this transaction.',
            )
            .optional(),
        taxOnInterestAmount: z
            .number()
            .describe(
                'How much taxes on the interest that was paid in this transaction were added/removed in account, within this transaction.',
            )
            .optional(),
        taxOnInterestFromArrearsAmount: z
            .number()
            .describe(
                'The amount of taxes on the interest from arrears that were applied/paid in account, within this transaction.',
            )
            .optional(),
        taxOnPaymentHolidaysInterest: z
            .number()
            .describe(
                'The amount of taxes on the Payment Holidays interest that were added/removed in account, within this transaction.',
            )
            .optional(),
        taxOnPenaltyAmount: z
            .number()
            .describe(
                'How much taxes on the penalties that were paid in this transaction were added/removed in account, within this transaction.',
            )
            .optional(),
        taxRate: z.number().describe('The tax rate that was set or changed in this transaction.').optional(),
    })
    .describe('The taxes applied within a transaction.')

export const Fee = z
    .object({
        amount: z
            .number()
            .describe('The amount of the fee that was applied/paid in the transaction for the given predefined fee.')
            .optional(),
        name: z.string().describe('The name of the predefined fee').optional(),
        predefinedFeeKey: z.string().describe('The encoded key of the predefined fee, auto generated, unique'),
        taxAmount: z.number().describe('The amount of the taxes on fee that was applied/paid in the transaction.').optional(),
        trigger: z
            .enum([
                'MANUAL',
                'MANUAL_PLANNED',
                'DISBURSEMENT',
                'CAPITALIZED_DISBURSEMENT',
                'UPFRONT_DISBURSEMENT',
                'LATE_REPAYMENT',
                'PAYMENT_DUE',
                'PAYMENT_DUE_APPLIED_ON_DUE_DATES',
                'ARBITRARY',
                'IOF',
                'EARLY_REPAYMENT_CHARGE',
            ])
            .describe('Shows the event that will trigger a fee')
            .optional(),
    })
    .describe('An amount of predefined fee that was applied or paid on an account.')

export const CustomPaymentAmount = z
    .object({
        amount: z.number().describe('The amount of the payment paid in the transaction for the given type.'),
        customPaymentAmountType: z
            .enum([
                'PRINCIPAL',
                'INTEREST',
                'MANUAL_FEE',
                'UPFRONT_DISBURSEMENT_FEE',
                'LATE_REPAYMENT_FEE',
                'PAYMENT_DUE_FEE',
                'PENALTY',
                'INTEREST_FROM_ARREARS',
            ])
            .describe('The type of the custom payment'),
        predefinedFeeKey: z.string().describe('The encodedKey of the predefined fee to be paid.').optional(),
        taxOnAmount: z.number().describe('The amount of the taxes paid in the transaction for the given type.').optional(),
    })
    .describe('Custom payment amount for a specific element type')

export const CardTransaction = z
    .object({
        advice: z.boolean().describe('Whether the given request should be accepted without balance validations.'),
        amount: z.number().describe('The amount of money to be withdrawn in the financial transaction.'),
        cardAcceptor: CardAcceptor.optional(),
        cardToken: z.string().describe('The reference token of the card.').optional(),
        currencyCode: z
            .string()
            .describe(
                'The ISO currency code in which the card reversal transaction is posted. The amounts are stored in the base currency, but the transaction can be created with a foreign currency.',
            )
            .optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        externalAuthorizationReferenceId: z
            .string()
            .describe(
                'The external authorization hold reference ID, which relates this card transaction to a previous authorization hold.',
            )
            .optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID to be used to reference the card transaction in subsequent requests.'),
        userTransactionTime: z.string().describe('The formatted time at which the user made this card transaction.').optional(),
    })
    .describe('A card transaction entry which will have a corresponding a financial transaction performed.')

export const LoanAffectedAmounts = z
    .object({
        deferredInterestAmount: z
            .number()
            .describe('How much interest pre-paid was added/removed in account, within this transaction (including taxes).')
            .optional(),
        feesAmount: z.number().describe(' How much fees was added/removed in account, within this transaction.').optional(),
        fundersInterestAmount: z
            .number()
            .describe('How much interest is given to the investors, within this transaction (only for p2p products)')
            .optional(),
        interestAmount: z
            .number()
            .describe(
                'How much interest was added/removed in account, within this transaction (including taxes). If there is any deferred interest amount set in this transaction, that amount should be included in this field.',
            )
            .optional(),
        interestFromArrearsAmount: z
            .number()
            .describe('How much interest from arrears was added/removed in account, within this transaction (including taxes).')
            .optional(),
        organizationCommissionAmount: z
            .number()
            .describe('How much interest is given to the organization, within this transaction (only for p2p products)')
            .optional(),
        paymentHolidaysInterestAmount: z
            .number()
            .describe(
                'How much Payment Holidays interest was added/removed in account, within this transaction (including taxes).',
            )
            .optional(),
        penaltyAmount: z
            .number()
            .describe('How much penalties was added/removed in account, within this transaction.')
            .optional(),
        principalAmount: z
            .number()
            .describe('How much principal was added/removed in account, within this transaction.')
            .optional(),
    })
    .describe('The amounts affected after completing the loan transaction')

export const TransactionBalances = z
    .object({
        advancePosition: z.number().describe('Captures the advance (prepaid) amount.').optional(),
        arrearsPosition: z.number().describe('Captures the arrears position amount for the account in arrears.').optional(),
        expectedPrincipalRedraw: z
            .number()
            .describe(
                'The difference between principal balance and redraw balance after each transaction performed on the loan account.',
            )
            .optional(),
        principalBalance: z.number().describe('The account redraw balance captured after the transaction update.').optional(),
        redrawBalance: z.number().describe('The account redraw balance captured after the transaction update.').optional(),
        totalBalance: z.number().describe('The running balance still owed for the loan.').optional(),
    })
    .describe('The balances changed within a transaction.')

export const AccountBalances = z
    .object({
        accountId: z.string().describe('The unique account identifier').optional(),
        availableBalance: z.number().describe('The available balance of a deposit or credit account').optional(),
        cardType: z.enum(['DEBIT', 'CREDIT']).describe('The card type either DEBIT or CREDIT').optional(),
        creditLimit: z
            .number()
            .describe('The overdraft limit of a deposit account or the loan amount in case of a credit account')
            .optional(),
        currencyCode: z.string().describe('Currency code used for the account').optional(),
        totalBalance: z
            .number()
            .describe('The current balance of a deposit account or principal balance of a revolving credit')
            .optional(),
    })
    .describe('Account balances presented to inquirer such as card processor')

export const LoanTranche = z
    .object({
        amount: z.number().describe('The amount this tranche has available for disburse'),
        disbursementDetails: TrancheDisbursementDetails.optional(),
        encodedKey: z.string().describe('The encoded key of the transaction details , auto generated, unique.').optional(),
        fees: CustomPredefinedFee.array().describe('Fees that are associated with this tranche').optional(),
        trancheNumber: z.number().int().describe('Index indicating the tranche number').optional(),
    })
    .describe(
        `In some cases organizations may approve loans but not disburse the full amount initially. They would like to spread the disbursement (and risk) over time. Likewise for the client, they may not need the full loan amount up front. They may want to have a loan to buy some equipment for their business but will make one purchase today and another purchase in a few months.  In these cases, they don't need the full amount and wouldn't want to pay interest on cash they don't need yet. A solution for this matter is the usage of disbursement in tranches. This class holds the information required for one of this tranche. `,
    )

export const ScheduleSettings = z
    .object({
        amortizationPeriod: z
            .number()
            .int()
            .describe('The PMT is calculated as the loan would have [amortizationPeriod] installments.')
            .optional(),
        billingCycle: BillingCycleDays.optional(),
        defaultFirstRepaymentDueDateOffset: z
            .number()
            .int()
            .describe(
                'The default first repayment due date offset, indicates how many days the first repayment due date should be extended(all other due dates from the schedule are relative to first repayment due date - they will also be affected by the offset)',
            )
            .optional(),
        fixedDaysOfMonth: z
            .number()
            .int()
            .array()
            .describe(
                'Specifies the days of the month when the repayment due dates should be. Only available if the Repayment Methodology is FIXED_DAYS_OF_MONTH.',
            )
            .optional(),
        gracePeriod: z
            .number()
            .int()
            .describe('The grace period. Represents the grace period for loan repayment - in number of installments.'),
        gracePeriodType: z
            .enum(['NONE', 'PAY_INTEREST_ONLY', 'INTEREST_FORGIVENESS'])
            .describe('The grace period type. Representing the type of grace period which is possible for a loan account.')
            .optional(),
        hasCustomSchedule: z
            .boolean()
            .describe(
                'Flag used when the repayments schedule for the current account was determined by the user, by editing the due dates or the principal due',
            )
            .optional(),
        paymentPlan: PeriodicPayment.array().describe('A list of periodic payments for the current loan account.').optional(),
        periodicPayment: z
            .number()
            .describe(
                'The periodic payment amount for the accounts which have balloon payments or Reduce Number of Installments and Optimized Payments',
            )
            .optional(),
        previewSchedule: RevolvingAccountSettings.optional(),
        principalRepaymentInterval: z
            .number()
            .int()
            .describe('The principal repayment interval. Indicates the interval of repayments that the principal has to be paid.')
            .optional(),
        repaymentInstallments: z
            .number()
            .int()
            .describe('The repayment installments. Represents how many installments are required to pay back the loan.')
            .optional(),
        repaymentPeriodCount: z
            .number()
            .int()
            .describe(
                'The repayment period count. Represents how often the loan is to be repaid: stored based on the type repayment option.',
            )
            .optional(),
        repaymentPeriodUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS', 'YEARS'])
            .describe('The repayment period unit. Represents the frequency of loan repayment.')
            .optional(),
        repaymentScheduleMethod: z
            .enum(['NONE', 'FIXED', 'DYNAMIC'])
            .describe(
                `The repayment schedule method. Represents the method that determines whether the schedule will be fixed all over the loan account's life cycle or will be dynamically recomputed when required.`,
            )
            .optional(),
        scheduleDueDatesMethod: z
            .enum(['INTERVAL', 'FIXED_DAYS_OF_MONTH'])
            .describe(
                'The schedule due dates method. Represents the methodology used by this account to compute the due dates of the repayments.',
            )
            .optional(),
        shortMonthHandlingMethod: z
            .enum(['LAST_DAY_IN_MONTH', 'FIRST_DAY_OF_NEXT_MONTH'])
            .describe(
                'The short handling method. Determines how to handle the short months, if they select a fixed day of month > 28. Will be null if no such date is selected and also for the Interval methodology. Only available if the Repayment Methodology is FIXED_DAYS_OF_MONTH.',
            )
            .optional(),
    })
    .describe('The schedule settings, holds all schedule properties.')

export const LoanAccountRedrawSettings = z
    .object({
        restrictNextDueWithdrawal: z
            .boolean()
            .describe(
                '`TRUE` if withdrawing amounts that reduce the next due instalment repayment is restricted, `FALSE` otherwise.',
            ),
    })
    .describe('Represents the redraw settings for a loan account.')

export const PrincipalPaymentAccountSettings = z
    .object({
        amount: z.number().describe('Fixed amount for being used for the repayments principal due.').optional(),
        encodedKey: z
            .string()
            .describe('The encoded key of the principal payment base settings, auto generated, unique.')
            .optional(),
        includeFeesInFloorAmount: z
            .boolean()
            .describe(
                'Boolean flag, if true, the fees will be included along with the principal in the repayment floor amount, for a revolving credit account',
            )
            .optional(),
        includeInterestInFloorAmount: z
            .boolean()
            .describe(
                'Boolean flag, if true, the interest will be included along with the principal in the repayment floor amount, for a revolving credit account',
            )
            .optional(),
        percentage: z.number().describe('Percentage of principal amount used for the repayments principal due.').optional(),
        principalCeilingValue: z
            .number()
            .describe('The maximum principal due amount a repayment made with this settings can have')
            .optional(),
        principalFloorValue: z
            .number()
            .describe('The minimum principal due amount a repayment made with this settings can have')
            .optional(),
        principalPaymentMethod: z
            .enum([
                'FLAT',
                'OUTSTANDING_PRINCIPAL_PERCENTAGE',
                'PRINCIPAL_PERCENTAGE_LAST_DISB',
                'TOTAL_BALANCE_PERCENTAGE',
                'TOTAL_BALANCE_FLAT',
                'TOTAL_PRINCIPAL_PERCENTAGE',
            ])
            .describe('The method of principal payment for revolving credit.')
            .optional(),
        totalDueAmountFloor: z
            .number()
            .describe('The minimum total due amount a repayment made with this settings can have')
            .optional(),
        totalDuePayment: z
            .enum([
                'FLAT',
                'OUTSTANDING_PRINCIPAL_PERCENTAGE',
                'PRINCIPAL_PERCENTAGE_LAST_DISB',
                'TOTAL_BALANCE_PERCENTAGE',
                'TOTAL_BALANCE_FLAT',
                'TOTAL_PRINCIPAL_PERCENTAGE',
            ])
            .describe('The method of total due payment for revolving credit')
            .optional(),
    })
    .describe(
        'The principal payment account settings, holds the required information for the principal payment process of an account.',
    )

export const PrepaymentSettings = z
    .object({
        applyInterestOnPrepaymentMethod: z
            .enum(['AUTOMATIC', 'MANUAL'])
            .describe('Apply interest on prepayment method copied from loan product on which this account is based.')
            .optional(),
        elementsRecalculationMethod: z
            .enum(['PRINCIPAL_EXPECTED_FIXED', 'TOTAL_EXPECTED_FIXED'])
            .describe(
                'The elements recalculation method, indicates how the declining balance with equal installments repayments are recalculated.',
            )
            .optional(),
        ercFreeAllowanceAmount: z.number().optional(),
        ercFreeAllowancePercentage: z
            .number()
            .describe('Early repayment charge fee free allowance in percentage per year')
            .optional(),
        prepaymentRecalculationMethod: z
            .enum([
                'NO_RECALCULATION',
                'RESCHEDULE_REMAINING_REPAYMENTS',
                'RECALCULATE_SCHEDULE_KEEP_SAME_NUMBER_OF_TERMS',
                'RECALCULATE_SCHEDULE_KEEP_SAME_PRINCIPAL_AMOUNT',
                'RECALCULATE_SCHEDULE_KEEP_SAME_TOTAL_REPAYMENT_AMOUNT',
                'REDUCE_AMOUNT_PER_INSTALLMENT',
                'REDUCE_NUMBER_OF_INSTALLMENTS',
                'REDUCE_NUMBER_OF_INSTALLMENTS_NEW',
            ])
            .describe('Prepayment recalculation method copied from the loan product on which this account is based.')
            .optional(),
        principalPaidInstallmentStatus: z
            .enum(['PARTIALLY_PAID', 'PAID', 'ORIGINAL_TOTAL_EXPECTED_PAID'])
            .describe('Installment status for the case when principal is paid off (copied from loan product).')
            .optional(),
    })
    .describe('The prepayment settings, holds all prepayment properties.')

export const PlannedInstallmentFee = z
    .object({
        amount: z.number().describe('The amount of the planned fee.').optional(),
        applyOnDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                `The date when a planned fee should be applied, overriding installment's due date. It should match the interval of the installment. If it belong to first installment, it should be between disbursement date and installment due date.`,
            )
            .optional(),
        encodedKey: z.string().describe('The encoded key of the planned installment fee, auto generated, unique.').optional(),
        installmentKey: z
            .string()
            .describe('The encoded key of the installment on which the predefined fee is planned.')
            .optional(),
        installmentNumber: z
            .number()
            .int()
            .describe(
                'The number of the installment on which the predefined fee is planned. It is used only in the case when fees are created at the same time with the loan account creation or during preview schedule, before account creation, otherwise this should be empty and installmentKey will be used to identify an installment.',
            )
            .optional(),
        predefinedFeeKey: z.string().describe('The encoded key of the predefined fee which is planned.'),
    })
    .describe('The planned fee details holds the information related to the installment key, predefined fee key and amount')

export const PenaltySettings = z
    .object({
        loanPenaltyCalculationMethod: z
            .enum(['NONE', 'OVERDUE_BALANCE', 'OVERDUE_BALANCE_AND_INTEREST', 'OUTSTANDING_PRINCIPAL'])
            .describe('The last penalty calculation method, represents on what amount are the penalties calculated.')
            .optional(),
        penaltyRate: z
            .number()
            .describe('The penalty rate, represents the rate (in percent) which is charged as a penalty.')
            .optional(),
    })
    .describe('The penalty settings, holds all the fields regarding penalties')

export const InterestSettings = z
    .object({
        accountInterestRateSettings: AccountInterestRateSettings.array()
            .describe('Adjustable interest rates settings for loan account')
            .optional(),
        accrueInterestAfterMaturity: z
            .boolean()
            .describe(
                'The accrue interest after maturity. If the product support this option, specify if the interest should be accrued after the account maturity date.',
            )
            .optional(),
        accrueLateInterest: z.boolean().describe('Indicates whether late interest is accrued for this loan account').optional(),
        effectiveInterestRate: z
            .number()
            .describe(
                'The effective interest rate. Represents the interest rate for the loan accounts with semi-annually compounding product.',
            )
            .optional(),
        interestApplicationDays: DaysInMonth.optional(),
        interestApplicationMethod: z
            .enum(['AFTER_DISBURSEMENT', 'REPAYMENT_DUE_DATE', 'FIXED_DAYS_OF_MONTH'])
            .describe(
                `The interest application method. Represents the interest application method that determines whether the interest gets applied on the account's disbursement or on each repayment.`,
            )
            .optional(),
        interestBalanceCalculationMethod: z
            .enum(['ONLY_PRINCIPAL', 'PRINCIPAL_AND_INTEREST'])
            .describe(
                `The interest balance calculation method. Represents the option which determines the way the balance for the account's interest is computed.`,
            )
            .optional(),
        interestCalculationMethod: z
            .enum(['FLAT', 'DECLINING_BALANCE', 'DECLINING_BALANCE_DISCOUNTED', 'EQUAL_INSTALLMENTS'])
            .describe('The interest calculation method. Holds the type of interest calculation method.')
            .optional(),
        interestChargeFrequency: z
            .enum(['ANNUALIZED', 'EVERY_MONTH', 'EVERY_FOUR_WEEKS', 'EVERY_WEEK', 'EVERY_DAY', 'EVERY_X_DAYS'])
            .describe(
                'The interest change frequency. Holds the possible values for how often is interest charged on loan or deposit accounts',
            )
            .optional(),
        interestRate: z
            .number()
            .describe(
                'The interest rate. Represents the interest rate for the loan account. The interest on loans is accrued on a daily basis, which allows charging the clients only for the days they actually used the loan amount.',
            )
            .optional(),
        interestRateReviewCount: z.number().int().describe('Interest rate update frequency unit count.').optional(),
        interestRateReviewUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS'])
            .describe('The interest rate review unit. Defines the interest rate update frequency measurement unit.')
            .optional(),
        interestRateSource: z
            .enum(['FIXED_INTEREST_RATE', 'INDEX_INTEREST_RATE'])
            .describe(
                'The interest rate source. Represents the interest calculation method: fixed or (interest spread + active organization index interest rate)',
            )
            .optional(),
        interestSpread: z
            .number()
            .describe('Interest to be added to active organization index interest rate in order to find out actual interest rate')
            .optional(),
        interestType: z
            .enum(['SIMPLE_INTEREST', 'CAPITALIZED_INTEREST', 'COMPOUNDING_INTEREST'])
            .describe('The possible values for how we compute and apply the interest')
            .optional(),
        pmtAdjustmentThreshold: PMTAdjustmentThreshold.optional(),
    })
    .describe('The interest settings, holds all the properties regarding interests for the loan account.')

export const Guarantor = z
    .object({
        amount: z.number().describe('The amount used by the client for the guaranty'),
        assetName: z
            .string()
            .describe('The name of a value the client guarantees with (populated when the guaranty type is ASSET)')
            .optional(),
        depositAccountKey: z
            .string()
            .describe(
                'The key of the deposit account used by the guarantor (populated when the guaranty type is GUARANTOR). It can be null.',
            )
            .optional(),
        encodedKey: z.string().describe('The encoded key of the security, auto generated, unique.').optional(),
        guarantorKey: z.string().describe('The key of the client/group used as the guarantor.'),
        guarantorType: z.enum(['CLIENT', 'GROUP']).describe('The type of the guarantor (client/group)'),
    })
    .describe(
        'Guarantor, holds information about a client guaranty entry. It can be defined based on another client which guarantees (including or not a savings account whether it is a client of the organization using Mambu or not) or based on a value the client holds (an asset)',
    )

export const InvestorFund = z
    .object({
        amount: z.number().describe('The amount used by the client for the guaranty'),
        assetName: z
            .string()
            .describe('The name of a value the client guarantees with (populated when the guaranty type is ASSET)')
            .optional(),
        depositAccountKey: z
            .string()
            .describe(
                'The key of the deposit account used by the guarantor (populated when the guaranty type is GUARANTOR). It can be null.',
            )
            .optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        guarantorKey: z.string().describe('The key of the client/group used as the guarantor.'),
        guarantorType: z.enum(['CLIENT', 'GROUP']).describe('The type of the guarantor (client/group)'),
        id: z
            .string()
            .describe('Investor fund unique identifier. All versions of an investor fund will have same id.')
            .optional(),
        interestCommission: z.number().describe('The constraint minimum value').optional(),
        sharePercentage: z.number().describe('Percentage of loan shares this investor owns').optional(),
    })
    .describe(
        'Contains the details about an investor fund including fields like encoded key, guarantor type, amount and guarantor key',
    )

export const DisbursementDetails = z
    .object({
        disbursementDate: z
            .string()
            .datetime({ offset: true })
            .describe('The activation date, the date when the disbursement actually took place.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the disbursement details, auto generated, unique').optional(),
        expectedDisbursementDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the expected disbursement.Stored as Organization Time.')
            .optional(),
        fees: CustomPredefinedFee.array().describe('List of fees that should be applied at the disbursement time.').optional(),
        firstRepaymentDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the expected first repayment. Stored as Organization Time.')
            .optional(),
        transactionDetails: LoanTransactionDetails.optional(),
    })
    .describe(
        'The the disbursement details it holds the information related to the disbursement details as disbursement date, first repayment date, disbursement fees.',
    )

export const Balances = z
    .object({
        feesBalance: z
            .number()
            .describe('The fees balance. Represents the total fees expected to be paid on this account at a given moment.')
            .optional(),
        feesDue: z.number().describe('The fees due. Representing the total fees due for the account.').optional(),
        feesPaid: z.number().describe('The fees paid. Represents the total fees paid for the account.').optional(),
        holdBalance: z.number().describe('The sum of all the authorization hold amounts on this account.').optional(),
        interestBalance: z
            .number()
            .describe(
                'Represents the total interest owed by the client (total interest applied for account minus interest paid).',
            )
            .optional(),
        interestDue: z
            .number()
            .describe(`The interest due. Indicates how much interest it's due for the account at this moment.`)
            .optional(),
        interestFromArrearsBalance: z
            .number()
            .describe(
                'The interest from arrears balance. Indicates interest from arrears owned by the client, from now on. (total interest from arrears accrued for account - interest from arrears paid).',
            )
            .optional(),
        interestFromArrearsDue: z
            .number()
            .describe(
                `The interest from arrears due. Indicates how much interest from arrears it's due for the account at this moment.`,
            )
            .optional(),
        interestFromArrearsPaid: z
            .number()
            .describe('The interest from arrears paid, indicates total interest from arrears paid into the account.')
            .optional(),
        interestPaid: z.number().describe('The interest paid, indicates total interest paid into the account.').optional(),
        penaltyBalance: z
            .number()
            .describe('The penalty balance. Represents the total penalty expected to be paid on this account at a given moment.')
            .optional(),
        penaltyDue: z.number().describe('The penalty due. Represents the total penalty amount due for the account.').optional(),
        penaltyPaid: z
            .number()
            .describe('The Penalty paid. Represents the total penalty amount paid for the account.')
            .optional(),
        principalBalance: z
            .number()
            .describe('The total principal owned by the client, from now on (principal disbursed - principal paid).')
            .optional(),
        principalDue: z.number().describe(`The principal due, indicates how much principal it's due at this moment.`).optional(),
        principalPaid: z.number().describe('The principal paid, holds the value of the total paid into the account.').optional(),
        redrawBalance: z.number().describe('The total redraw amount owned by the client, from now on.').optional(),
    })
    .describe('The loan account balance details.')

export const Asset = z
    .object({
        amount: z.number().describe('The amount used by the client for the guaranty'),
        assetName: z
            .string()
            .describe('The name of a value the client guarantees with (populated when the guaranty type is ASSET)'),
        depositAccountKey: z
            .string()
            .describe(
                'The key of the deposit account used by the guarantor (populated when the guaranty type is GUARANTOR). It can be null.',
            )
            .optional(),
        encodedKey: z.string().describe('The encoded key of the security, auto generated, unique.').optional(),
        guarantorKey: z.string().describe('The key of the client/group used as the guarantor.').optional(),
        guarantorType: z.enum(['CLIENT', 'GROUP']).describe('The type of the guarantor (client/group)').optional(),
        originalAmount: z.number().describe('The original amount used by the client for a collateral asset').optional(),
        originalCurrency: Currency.optional(),
    })
    .describe('Asset, holds information about a client asset entry.')

export const AccountArrearsSettings = z
    .object({
        dateCalculationMethod: z
            .enum(['ACCOUNT_FIRST_WENT_TO_ARREARS', 'LAST_LATE_REPAYMENT', 'ACCOUNT_FIRST_BREACHED_MATERIALITY_THRESHOLD'])
            .describe('The arrears date calculation method.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the arrears base settings, auto generated, unique.').optional(),
        monthlyToleranceDay: z.number().int().describe('Defines monthly arrears tolerance day value.').optional(),
        nonWorkingDaysMethod: z
            .enum(['INCLUDED', 'EXCLUDED'])
            .describe(
                'Shows whether the non working days are taken in consideration or not when applying penaltees/late fees or when setting an account into arrears',
            )
            .optional(),
        toleranceCalculationMethod: z
            .enum(['ARREARS_TOLERANCE_PERIOD', 'MONTHLY_ARREARS_TOLERANCE_DAY'])
            .describe('Defines the tolerance calculation method')
            .optional(),
        toleranceFloorAmount: z.number().describe('The tolerance floor amount.').optional(),
        tolerancePercentageOfOutstandingPrincipal: z.number().describe('Defines the arrears tolerance amount.').optional(),
        tolerancePeriod: z.number().int().describe('Defines the arrears tolerance period value.').optional(),
    })
    .describe('The account arrears settings, holds the required information for the arrears settings of an account.')

export const InstallmentAllocationElementAmount = z
    .object({
        amount: Amount.optional(),
    })
    .describe('Represents an installment allocation element amount structure.')

export const InstallmentAllocationElementTaxableAmount = z
    .object({
        amount: Amount.optional(),
        tax: Amount.optional(),
    })
    .describe('Represents an installment allocation element taxable amount structure.')

export const InstallmentFeeDetails = z
    .object({
        amount: AmountWithReduced.optional(),
        encodedKey: z.string().describe('The encoded key of the predefined fee, auto generated, unique').optional(),
        id: z.string().describe('The id of the fee, provided by the client').optional(),
        name: z.string().describe('The name of the fee').optional(),
        tax: AmountWithReduced.optional(),
    })
    .describe('Represents fee details for an installment.')

export const InstallmentFee = z
    .object({
        amount: FeeAmount.optional(),
        tax: Amount.optional(),
    })
    .describe('Represents an installment fee structure.')

export const PeriodicPaymentForSchedulePreview = z
    .object({
        amount: z.number().describe('The PMT value used in periodic payment'),
        toInstallment: z.number().int().describe(`The installment's position up to which the PMT will be used`),
    })
    .describe(
        'For fixed term loans there is the possibility to define a payment plan. A payment plan consists of multiple periodic payments. This class holds information about a periodic payment for schedule preview.',
    )

export const RestructureScheduleSettings = z
    .object({
        amortizationPeriod: z
            .number()
            .int()
            .describe('The PMT is calculated as the loan would have [amortizationPeriod] installments.')
            .optional(),
        billingCycleDays: BillingCycleDays.optional(),
        fixedDaysOfMonth: z
            .number()
            .int()
            .array()
            .describe('The days of the month, when the repayment due dates should be')
            .optional(),
        gracePeriod: z.number().int().describe('The grace period').optional(),
        paymentPlan: PeriodicPayment.array().describe('A list of periodic payments for the current loan account.').optional(),
        periodicPayment: z.number().describe('The periodic payment').optional(),
        previewSchedule: RevolvingAccountSettings.optional(),
        repaymentInstallments: z.number().int().describe('The number of installments').optional(),
        repaymentPeriodCount: z.number().int().describe('The payments frequency per set period of time').optional(),
        repaymentPeriodUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS', 'YEARS'])
            .describe('The period of time, within which the payments frequency is set')
            .optional(),
    })
    .describe('The schedule settings, allowed on the loan account restructure')

export const RestructurePrincipalPaymentAccountSettings = z
    .object({
        amount: z.number().describe('Fixed principal payment amount').optional(),
        percentage: z.number().describe('Principal payment percentage').optional(),
    })
    .describe('The principal payment account settings, allowed on the loan account restructure')

export const RestructurePenaltySettings = z
    .object({
        penaltyRate: z.number().describe('The penalty rate').optional(),
    })
    .describe('The penalty settings, allowed on the loan account restructure.')

export const RestructureInterestSettings = z
    .object({
        accountInterestRateSettings: AccountInterestRateSettings.array()
            .describe('Adjustable interest rates settings for loan account')
            .optional(),
        interestRate: z.number().describe('The interest rate for the restructured loan account').optional(),
        interestSpread: z.number().describe('The interest spread for the restructured loan account').optional(),
        pmtAdjustmentThreshold: PMTAdjustmentThreshold.optional(),
    })
    .describe('The interest settings, allowed on the loan account restructure')

export const RefinanceDisbursementDetails = z
    .object({
        expectedDisbursementDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the expected disbursement')
            .optional(),
        fees: CustomPredefinedFee.array().describe('List of fees that should be applied at the disbursement time.').optional(),
        firstRepaymentDate: z.string().datetime({ offset: true }).describe('The date of the expected first payment'),
    })
    .describe('The disbursement details, allowed on the loan account refinance')

export const RestructureAccountArrearsSettings = z
    .object({
        tolerancePercentageOfOutstandingPrincipal: z.number().describe('The arrears tolerance amount').optional(),
        tolerancePeriod: z.number().int().describe('The arrears tolerance period value').optional(),
    })
    .describe('The arrears settings, allowed on the loan account restructure')

export const RescheduleDisbursementDetails = z
    .object({
        firstRepaymentDate: z.string().datetime({ offset: true }).describe('The date of the expected first payment'),
    })
    .describe('The disbursement details, allowed on the loan account restructure')

export const LoanTransaction = z
    .object({
        accountBalances: TransactionBalances.optional(),
        adjustmentTransactionKey: z
            .string()
            .describe(
                'The key of the loan transaction where the adjustment for the transaction was made (if any adjustment was involved).',
            )
            .optional(),
        affectedAmounts: LoanAffectedAmounts.optional(),
        amount: z.number().describe('The amount that was added or removed on the loan account.').optional(),
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when the corresponding journal entry is booked.')
            .optional(),
        branchKey: z.string().describe('The branch where the transaction was performed.').optional(),
        cardTransaction: CardTransaction.optional(),
        centreKey: z.string().describe('The center where the transaction was performed.').optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when this loan transaction was created.')
            .optional(),
        currency: Currency.optional(),
        customPaymentAmounts: CustomPaymentAmount.array()
            .describe('The list of custom amounts which the user has paid as part of this transaction.')
            .optional(),
        encodedKey: z
            .string()
            .describe('The encoded key of the loan transaction, which is auto generated, and must be unique.')
            .optional(),
        externalId: z
            .string()
            .describe('The external ID of the loan transaction, it is customizable, and must be unique.')
            .optional(),
        fees: Fee.array()
            .describe('The amounts that have been applied or paid as part of this transaction and involved predefined fees.')
            .optional(),
        id: z
            .string()
            .describe('The ID of the loan transaction, can be generated and customized, and must be unique.')
            .optional(),
        installmentEncodedKey: z
            .string()
            .describe('The specific installment encoded key associated to the loan transaction.')
            .optional(),
        migrationEventKey: z
            .string()
            .describe(
                `The migration event encoded key associated with the loan account. If the account was imported, track which 'migration event' it came from.`,
            )
            .optional(),
        notes: z.string().describe('The notes or description for the loan transaction.').optional(),
        originalAmount: z
            .number()
            .describe(
                'The amount that was posted in a foreign currency. This amount was converted using the exchange rate available at entry date and set into the amount field.',
            )
            .optional(),
        originalCurrencyCode: z
            .string()
            .describe(
                'The currency in which this transaction was posted. The amounts are stored in the base currency, but the user may enter it in a foreign currency.',
            )
            .optional(),
        originalTransactionKey: z
            .string()
            .describe(
                'The encoded key of the transaction that was adjusted as part of this one. Available only for adjustment transactions.',
            )
            .optional(),
        parentAccountKey: z.string().describe('The key of the parent loan account.').optional(),
        parentLoanTransactionKey: z.string().describe('The key of the parent loan transaction.').optional(),
        prepaymentRecalculationMethod: z
            .enum([
                'NO_RECALCULATION',
                'RESCHEDULE_REMAINING_REPAYMENTS',
                'RECALCULATE_SCHEDULE_KEEP_SAME_NUMBER_OF_TERMS',
                'RECALCULATE_SCHEDULE_KEEP_SAME_PRINCIPAL_AMOUNT',
                'RECALCULATE_SCHEDULE_KEEP_SAME_TOTAL_REPAYMENT_AMOUNT',
                'REDUCE_AMOUNT_PER_INSTALLMENT',
                'REDUCE_NUMBER_OF_INSTALLMENTS',
                'REDUCE_NUMBER_OF_INSTALLMENTS_NEW',
            ])
            .describe('The prepayment recalculation method of the loan transaction.')
            .optional(),
        taxes: Taxes.optional(),
        terms: LoanTerms.optional(),
        tillKey: z.string().describe('The till key associated with the transaction.').optional(),
        transactionDetails: TransactionDetails.optional(),
        transferDetails: TransferDetails.optional(),
        type: z
            .enum([
                'IMPORT',
                'DISBURSEMENT',
                'DISBURSEMENT_ADJUSTMENT',
                'WRITE_OFF',
                'WRITE_OFF_ADJUSTMENT',
                'REPAYMENT',
                'PAYMENT_MADE',
                'WITHDRAWAL_REDRAW',
                'WITHDRAWAL_REDRAW_ADJUSTMENT',
                'FEE_APPLIED',
                'FEE_CHARGED',
                'FEE_CAPITALISED',
                'SCHEDULE_FIX_APPLIED',
                'FEES_DUE_REDUCED',
                'FEE_REFUND',
                'FEE_REFUND_ADJUSTMENT',
                'FEE_ADJUSTMENT',
                'PENALTY_APPLIED',
                'PENALTY_ADJUSTMENT',
                'PENALTIES_DUE_REDUCED',
                'REPAYMENT_ADJUSTMENT',
                'FEE_CAPITALISED_ADJUSTMENT',
                'PAYMENT_MADE_ADJUSTMENT',
                'INTEREST_RATE_CHANGED',
                'TAX_RATE_CHANGED',
                'PENALTY_RATE_CHANGED',
                'INTEREST_APPLIED',
                'INTEREST_APPLIED_ADJUSTMENT',
                'INTEREST_DUE_REDUCED',
                'PENALTY_REDUCTION_ADJUSTMENT',
                'FEE_REDUCTION_ADJUSTMENT',
                'INTEREST_REDUCTION_ADJUSTMENT',
                'DEFERRED_INTEREST_APPLIED',
                'DEFERRED_INTEREST_APPLIED_ADJUSTMENT',
                'DEFERRED_INTEREST_PAID',
                'DEFERRED_INTEREST_PAID_ADJUSTMENT',
                'INTEREST_LOCKED',
                'FEE_LOCKED',
                'PENALTY_LOCKED',
                'INTEREST_UNLOCKED',
                'FEE_UNLOCKED',
                'PENALTY_UNLOCKED',
                'REDRAW_TRANSFER',
                'REDRAW_REPAYMENT',
                'REDRAW_TRANSFER_ADJUSTMENT',
                'REDRAW_REPAYMENT_ADJUSTMENT',
                'TRANSFER',
                'TRANSFER_ADJUSTMENT',
                'BRANCH_CHANGED',
                'TERMS_CHANGED',
                'CARD_TRANSACTION_REVERSAL',
                'CARD_TRANSACTION_REVERSAL_ADJUSTMENT',
                'DUE_DATE_CHANGED',
                'DUE_DATE_CHANGED_ADJUSTMENT',
                'ACCOUNT_TERMINATED',
                'ACCOUNT_TERMINATED_ADJUSTMENT',
                'REFUND',
                'REFUND_ADJUSTMENT',
            ])
            .describe('The type of loan transaction.')
            .optional(),
        userKey: z.string().describe('The user that performed the transaction.').optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the entry in the organization time format and timezone.')
            .optional(),
    })
    .describe(`Represents the action performed on a loan account after which the account's amount changes its value.`)

export const RestError = z.object({
    errorCode: z.number().int().optional(),
    errorReason: z.string().optional(),
    errorSource: z.string().optional(),
})

export const GetAuthorizationHold = z
    .object({
        accountKey: z.string().describe('The key of the account linked with the authorization hold.').optional(),
        advice: z.boolean().describe('Whether the given request should be accepted without balance validations.'),
        amount: z.number().describe('The amount of money to be held as a result of the authorization hold request.'),
        balances: AccountBalances.optional(),
        cardAcceptor: CardAcceptor.optional(),
        cardToken: z.string().describe('The reference token of the card.').optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The organization time when the authorization hold was created')
            .optional(),
        creditDebitIndicator: z
            .enum(['DBIT', 'CRDT'])
            .describe(
                'Indicates whether the authorization hold amount is credited or debited.If not provided, the default values is DBIT.',
            )
            .optional(),
        currencyCode: z
            .string()
            .describe(
                'The ISO currency code in which the hold was created. The amounts are stored in the base currency, but the user could have enter it in a foreign currency.',
            )
            .optional(),
        customExpirationPeriod: z
            .number()
            .int()
            .describe('The custom expiration period for the hold which overwrites mcc and default expiration periods')
            .optional(),
        encodedKey: z.string().describe('The internal ID of the authorization hold, auto generated, unique.').optional(),
        exchangeRate: z.number().describe('The exchange rate for the original currency.').optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID to be used to reference the account hold in subsequent requests.'),
        originalAmount: z
            .number()
            .describe('The original amount of money to be held as a result of the authorization hold request.')
            .optional(),
        originalCurrency: z.string().describe('The original currency in which the hold was created.').optional(),
        partial: z.boolean().describe('Indicates whether the authorization is partial or not').optional(),
        referenceDateForExpiration: z
            .string()
            .datetime({ offset: true })
            .describe('The date to consider as start date when calculating the number of days passed until expiration')
            .optional(),
        source: z
            .enum(['CARD', 'ACCOUNT'])
            .describe('Indicates the source of the authorization hold, the default values is CARD.')
            .optional(),
        status: z.enum(['PENDING', 'REVERSED', 'SETTLED', 'EXPIRED']).describe('The authorization hold status.').optional(),
        userTransactionTime: z.string().describe('The formatted time at which the user made this authorization hold.').optional(),
    })
    .describe('Details for retrieving a authorization hold. Deprecated due to encodedKey field.')

export const Card = z
    .object({
        referenceToken: z.string().describe(`The card's reference token.`),
    })
    .describe(
        'Returns a card that can be associated to a deposit or loan  account. Cards consist only of card reference tokens and the card details are not stored in Mambu.',
    )

export type Card = z.infer<typeof Card>

export const LoanAccount = z
    .object({
        accountArrearsSettings: AccountArrearsSettings.optional(),
        accountHolderKey: z.string().describe('The encoded key of the account holder.'),
        accountHolderType: z.enum(['CLIENT', 'GROUP']).describe('The type of the account holder.'),
        accountState: z
            .enum(['PARTIAL_APPLICATION', 'PENDING_APPROVAL', 'APPROVED', 'ACTIVE', 'ACTIVE_IN_ARREARS', 'CLOSED'])
            .describe('The state of the loan account.')
            .optional(),
        accountSubState: z
            .enum([
                'PARTIALLY_DISBURSED',
                'LOCKED',
                'LOCKED_CAPPING',
                'REFINANCED',
                'RESCHEDULED',
                'WITHDRAWN',
                'REPAID',
                'REJECTED',
                'WRITTEN_OFF',
                'TERMINATED',
            ])
            .describe(
                'A second state for the loan account. Beside the account state, a second substate is sometimes necessary to provide more information about the exact lifecycle state of a loan account.For example, even if the account state of a loan account is `ACTIVE`, it can also have a substate of `LOCKED`.',
            )
            .optional(),
        accruedInterest: z.number().describe('The amount of interest that has been accrued in the loan account.').optional(),
        accruedPenalty: z
            .number()
            .describe('The accrued penalty, represents the amount of penalty that has been accrued in the loan account.')
            .optional(),
        activationTransactionKey: z
            .string()
            .describe('The encoded key of the transaction that activated the loan account.')
            .optional(),
        allowOffset: z.boolean().describe('DEPRECATED - Will always be false.').optional(),
        approvedDate: z.string().datetime({ offset: true }).describe('The date the loan account was approved.').optional(),
        arrearsTolerancePeriod: z
            .number()
            .int()
            .describe('The arrears tolerance (period or day of month) depending on the product settings.')
            .optional(),
        assets: Asset.array().describe('The list of assets associated with the current loan account.').optional(),
        assignedBranchKey: z
            .string()
            .describe(
                'The key of the branch this loan account is assigned to. The branch is set to unassigned if no branch field is set.',
            )
            .optional(),
        assignedCentreKey: z.string().describe('The key of the centre this account is assigned to.').optional(),
        assignedUserKey: z.string().describe('The key of the user this loan account is assigned to.').optional(),
        balances: Balances.optional(),
        closedDate: z.string().datetime({ offset: true }).describe('The date the loan was closed.').optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The date the loan account was created.').optional(),
        creditArrangementKey: z
            .string()
            .describe('The key to the line of credit where this account is registered to.')
            .optional(),
        currency: Currency.optional(),
        daysInArrears: z.number().int().describe('The number of days the loan account is in arrears.').optional(),
        daysLate: z.number().int().describe('The number of days a repayment for the loan account is late.').optional(),
        disbursementDetails: DisbursementDetails.optional(),
        encodedKey: z
            .string()
            .describe('The encoded key of the loan account, it is auto generated, and must be unique.')
            .optional(),
        fundingSources: InvestorFund.array().describe('The list of funds associated with the loan account.').optional(),
        futurePaymentsAcceptance: z
            .enum(['NO_FUTURE_PAYMENTS', 'ACCEPT_FUTURE_PAYMENTS', 'ACCEPT_OVERPAYMENTS'])
            .describe(
                'Shows whether the repayment transactions with entry date set in the future are allowed or not for this loan account.',
            )
            .optional(),
        guarantors: Guarantor.array().describe('The list of guarantees associated with the loan account.').optional(),
        id: z.string().describe('The ID of the loan account, it can be generated and customized, and must be unique.').optional(),
        interestAccruedInBillingCycle: z
            .number()
            .describe('The interest that is accrued in the current billing cycle.')
            .optional(),
        interestCommission: z
            .number()
            .describe(
                'The value of the interest booked by the organization from the accounts funded by investors. Null if the funds are not enabled.',
            )
            .optional(),
        interestFromArrearsAccrued: z
            .number()
            .describe('The amount of interest from arrears that has been accrued in the loan account.')
            .optional(),
        interestSettings: InterestSettings.optional(),
        lastAccountAppraisalDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                'The date the loan account has last been evaluated for interest, principal, fees, and penalties calculations expressed in the organization time format and time zone.',
            )
            .optional(),
        lastInterestAppliedDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                'The date of the last time the loan account had interest applied (stored to interest balance), expressed in the organization time format and time zone.',
            )
            .optional(),
        lastInterestReviewDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date the interest was reviewed last time, stored in the organization time format and time zone.')
            .optional(),
        lastLockedDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                'The date when the loan account was set for the last time in the `LOCKED` state expressed in the organization time format and time zone. If null, the account is not locked anymore.',
            )
            .optional(),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('The last date the loan was updated.').optional(),
        lastSetToArrearsDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                'The date when the loan account was set to last standing or null; if never set, it is expressed in your organization time format and time zone.',
            )
            .optional(),
        lastTaxRateReviewDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                'The date the tax rate on the loan account was last checked, expressed in the organization time format and time zone.',
            )
            .optional(),
        latePaymentsRecalculationMethod: z
            .enum(['OVERDUE_INSTALLMENTS_INCREASE', 'LAST_INSTALLMENT_INCREASE', 'NO_RECALCULATION'])
            .describe(
                'The overdue payments recalculation method inherited from the loan product on which this loan account is based.',
            )
            .optional(),
        loanAmount: z.number().describe('The loan amount.'),
        loanName: z.string().describe('The name of the loan account.').optional(),
        lockedAccountTotalDueType: z
            .enum(['BALANCE_AMOUNT', 'DUE_AMOUNT_ON_LATE_INSTALLMENTS'])
            .describe('The locked account total due type.')
            .optional(),
        lockedOperations: z
            .enum(['APPLY_INTEREST', 'APPLY_FEES', 'APPLY_PENALTIES'])
            .array()
            .describe('A list with operations which are locked when the account is in the AccountState.LOCKED substate.')
            .optional(),
        migrationEventKey: z
            .string()
            .describe(
                `The migration event encoded key associated with this loan account. If this account was imported, track which 'migration event' they came from.`,
            )
            .optional(),
        modifyInterestForFirstInstallment: z
            .boolean()
            .describe(
                'Adjust the interest for the first repayment when the first repayment period is different than the repayment frequency',
            )
            .optional(),
        notes: z.string().describe('The notes about this loan account.').optional(),
        originalAccountKey: z.string().describe('The key of the original rescheduled or refinanced loan account.').optional(),
        paymentHolidaysAccruedInterest: z
            .number()
            .describe('The amount of interest that has been accrued during payment holidays in the loan account.')
            .optional(),
        paymentMethod: z
            .enum(['HORIZONTAL', 'VERTICAL'])
            .describe(
                'The interest payment method that determines whether the payments are made horizontally (on the repayments) or vertically (on the loan account).',
            )
            .optional(),
        penaltySettings: PenaltySettings.optional(),
        plannedInstallmentFees: PlannedInstallmentFee.array()
            .describe('The list with manual fees planned on the installments of the loan account.')
            .optional(),
        prepaymentSettings: PrepaymentSettings.optional(),
        principalPaymentSettings: PrincipalPaymentAccountSettings.optional(),
        productTypeKey: z.string().describe('The key for the type of loan product that this loan account is based on.'),
        redrawSettings: LoanAccountRedrawSettings.optional(),
        rescheduledAccountKey: z
            .string()
            .describe(
                'The key pointing to where this loan account was rescheduled or refinanced to. This value is only not null if rescheduled.',
            )
            .optional(),
        scheduleSettings: ScheduleSettings,
        settlementAccountKey: z.string().describe('The encoded key of the settlement account.').optional(),
        taxRate: z.number().describe('The tax rate.').optional(),
        terminationDate: z.string().datetime({ offset: true }).describe('The date this loan account was terminated.').optional(),
        tranches: LoanTranche.array().describe('The list of disbursement tranches available for the loan account.').optional(),
    })
    .describe(
        'Represents a loan account. A loan account defines the amount that your organization lends to a client. The terms and conditions of a loan account are defined by a loan product. In a loan account, Mambu stores all the information related to disbursements, repayments, interest rates, and withdrawals.',
    )

export type LoanAccount = z.infer<typeof LoanAccount>

export const PayOffAdjustableAmounts = z
    .object({
        feesPaid: z.number().describe('The fee amount to be paid for Pay Off action').optional(),
        interestFromArrearsPaid: z.number().describe('The interest from arrears amount to be paid for Pay Off action').optional(),
        interestPaid: z.number().describe('The interest amount to be paid for Pay Off action').optional(),
        penaltyPaid: z.number().describe('The penalty amount to be paid for Pay Off action').optional(),
    })
    .describe('Adjustable amounts to be paid for Pay Off action')

export const Installment = z
    .object({
        dueDate: z.string().datetime({ offset: true }).describe('The installment due date.').optional(),
        encodedKey: z.string().describe('The encoded key of the installment, which is auto generated, and unique.').optional(),
        expectedClosingBalance: z
            .number()
            .describe(
                'The expected closing balance is the remaining amount per installment only applicable for interest only equal installment products.',
            )
            .optional(),
        fee: InstallmentFee.optional(),
        feeDetails: InstallmentFeeDetails.array()
            .describe('The breakdown of the fee amounts that have been applied to the loan account.')
            .optional(),
        interest: InstallmentAllocationElementTaxableAmount.optional(),
        interestAccrued: z
            .number()
            .describe(
                'The interest accrued calculated on previous repayment closing balance only applicable interest only equal installment products.',
            )
            .optional(),
        isPaymentHoliday: z
            .boolean()
            .describe('`TRUE` if a payment holiday is offered for the installment, `FALSE` otherwise.')
            .optional(),
        lastPaidDate: z.string().datetime({ offset: true }).describe('The installment last paid date.').optional(),
        number: z
            .string()
            .describe(
                'The order number of an installment among all the installments generated for a loan. Loan installments are put in ascending order by due date. The order number only applies to the content of a particular JSON response therefore it is not unique.',
            )
            .optional(),
        parentAccountKey: z.string().describe('The parent account key of the installment.').optional(),
        penalty: InstallmentAllocationElementTaxableAmount.optional(),
        principal: InstallmentAllocationElementAmount.optional(),
        repaidDate: z.string().datetime({ offset: true }).describe('The installment repaid date.').optional(),
        state: z.enum(['PENDING', 'LATE', 'PAID', 'PARTIALLY_PAID', 'GRACE']).describe('The installment state.').optional(),
    })
    .describe('Represents a single installment details structure.')

export const LoanAccountSortingCriteria = z
    .object({
        field: z
            .enum([
                'encodedKey',
                'loanName',
                'id',
                'accountHolderId',
                'recipient',
                'creationDate',
                'approvedDate',
                'lastModifiedDate',
                'lastSetToArrearsDate',
                'lastLockedDate',
                'closedDate',
                'daysInArrears',
                'daysLate',
                'loanAmount',
                'tranches.amount',
                'numInstallments',
                'accruedInterest',
                'accruedPenalty',
                'penaltySettings.penaltyRate',
                'arrearsTolerancePeriod',
                'interestSettings.interestSpread',
                'totalPaid',
                'totalBalance',
                'totalDue',
                'firstRepaymentDate',
                'lastPaymentDate',
                'lastPaymentAmount',
                'expectedMaturity',
                'rescheduledAccountKey',
                'refinancedAccountId',
                'originalAccountKey',
                'taxRate',
                'taxPaid',
                'taxDue',
                'settlementAccountKey',
                'interestCommission',
                'numberOfFunds',
                'fundsEnabled',
                'availableAmount',
                'wasRescheduled',
                'wasRefinanced',
                'expectedPrincipalRedraw',
                'balances.principalDue',
                'balances.principalPaid',
                'balances.principalBalance',
                'balances.interestDue',
                'balances.interestPaid',
                'balance.interestBalance',
                'balances.redrawBalance',
                'balances.feesDue',
                'balances.feesBalance',
                'balances.feesPaid',
                'balances.penaltyDue',
                'balances.penaltyPaid',
                'balances.penaltyBalance',
                'fundingSources.amount',
                'fundingSources.sharePercentage',
            ])
            .describe(
                'Contains the field that can be used as sorting selection. Can be native (one from the provided list) or otherwise can specify a custom field definition using the format [customFieldSetId].[customFieldId].',
            ),
        order: z.enum(['ASC', 'DESC']).describe('The sorting order: `ASC` or `DESC`. The default order is `DESC`.').optional(),
    })
    .describe('Represents the sorting criteria used for loan account searches.')

export const LoanAccountFilterCriteria = z
    .object({
        field: z.union([
            z
                .enum([
                    'accountHolderKey',
                    'productTypeKey',
                    'loanRiskLevelKey',
                    'encodedKey',
                    'loanName',
                    'id',
                    'accountHolderId',
                    'recipient',
                    'creationDate',
                    'approvedDate',
                    'lastModifiedDate',
                    'lastSetToArrearsDate',
                    'lastLockedDate',
                    'closedDate',
                    'daysInArrears',
                    'daysLate',
                    'accountSubState',
                    'accountState',
                    'loanAmount',
                    'numInstallments',
                    'balances.principalDue',
                    'balances.principalPaid',
                    'balances.principalBalance',
                    'balances.interestDue',
                    'balances.interestPaid',
                    'balance.interestBalance',
                    'accruedInterest',
                    'balances.feesDue',
                    'balances.feesBalance',
                    'balances.feesPaid',
                    'penaltySettings.loanPenaltyCalculationMethod',
                    'balances.penaltyDue',
                    'balances.penaltyPaid',
                    'balances.penaltyBalance',
                    'accruedPenalty',
                    'penaltySettings.penaltyRate',
                    'arrearsTolerancePeriod',
                    'interestSettings.interestRate',
                    'interestSettings.interestSpread',
                    'totalPaid',
                    'totalBalance',
                    'totalDue',
                    'firstRepaymentDate',
                    'lastPaymentDate',
                    'lastPaymentAmount',
                    'expectedMaturityDate',
                    'rescheduledAccountKey',
                    'refinancedAccountId',
                    'originalAccountKey',
                    'taxRate',
                    'taxPaid',
                    'taxDue',
                    'settlementAccountKey',
                    'interestCommission',
                    'fundingSources.amount',
                    'fundingSources.sharePercentage',
                    'numberOfFunds',
                    'fundsEnabled',
                    'availableAmount',
                    'wasRescheduled',
                    'wasRefinanced',
                    'prepaymentSettings.prepaymentRecalculationMethod',
                    'prepaymentSettings.applyInterestOnPrepaymentMethod',
                    'latePaymentsRecalculationMethod',
                    'balances.redrawBalance',
                    'expectedPrincipalRedraw',
                    'tranches.parentAccountKey',
                    'tranches.disbursementDetails.disbursementTransactionKey',
                    'tranches.amount',
                    'tranches.disbursementDetails.expectedDisbursementDate',
                    'disbursementDetails.expectedDisbursementDate',
                    'disbursementDetails.disbursementDate',
                    'lastAccountAppraisalDate',
                ])
                .describe(
                    'Contains the actual searching fields that can be native (one from the provided list) or otherwise can specify a custom field definition using the format [customFieldSetId].[customFieldId].\\n',
                ),
            z.string(),
        ]),
        operator: z
            .enum([
                'EQUALS',
                'EQUALS_CASE_SENSITIVE',
                'DIFFERENT_THAN',
                'MORE_THAN',
                'LESS_THAN',
                'BETWEEN',
                'ON',
                'AFTER',
                'AFTER_INCLUSIVE',
                'BEFORE',
                'BEFORE_INCLUSIVE',
                'STARTS_WITH',
                'STARTS_WITH_CASE_SENSITIVE',
                'IN',
                'TODAY',
                'THIS_WEEK',
                'THIS_MONTH',
                'THIS_YEAR',
                'LAST_DAYS',
                'EMPTY',
                'NOT_EMPTY',
            ])
            .describe(
                '| **Operator**                | **Affected values**  | **Available for**                                                    |\\n|---------------               |----------------------|----------------------------------------------------------------------|\\n| EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |\\n| EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |\\n| MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |\\n| ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| STARTS_WITH                  | ONE_VALUE            | STRING                                                               |\\n| STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |\\n| IN                           | LIST                 | ENUM,KEY                                                             |\\n| TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |\\n| EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |\\n| NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |',
            ),
        secondValue: z
            .string()
            .describe('The second value to match the searching criteria, when the `BETWEEN` operator is used.')
            .optional(),
        value: z.string().describe('The value to match the searching criteria.').optional(),
        values: z.string().array().describe('List of values when the `IN` operator is used.').optional(),
    })
    .describe('Wrapper that holds a list of filtering criteria and a sorting criteria for Loan account directed query')

export const PatchOperation = z
    .object({
        from: z.string().describe('The field from where a value should be moved, when using move').optional(),
        op: z.enum(['ADD', 'REPLACE', 'REMOVE', 'MOVE']).describe('The change to perform'),
        path: z.string().describe('The field to perform the operation on'),
        value: z.unknown().describe('The value of the field, can be null').optional(),
    })
    .describe('A single change that needs to be made to a resource')

export const ScheduleSettingsForSchedulePreview = z
    .object({
        amortizationPeriod: z
            .number()
            .int()
            .describe('The PMT is calculated as the loan would have [amortizationPeriod] installments.')
            .optional(),
        fixedDaysOfMonth: z
            .number()
            .int()
            .array()
            .describe(
                'Specifies the days of the month when the repayment due dates should be. Only available if the Repayment Methodology is FIXED_DAYS_OF_MONTH.',
            )
            .optional(),
        gracePeriod: z
            .number()
            .int()
            .describe('The grace period. Represents the grace period for loan repayment - in number of installments.')
            .optional(),
        paymentPlan: PeriodicPaymentForSchedulePreview.array()
            .describe('A list of periodic payments for the current loan account.')
            .optional(),
        periodicPayment: z
            .number()
            .describe(
                'The periodic payment amount for the accounts which have balloon payments or Reduce Number of Installments and Optimized Payments',
            )
            .optional(),
        principalRepaymentInterval: z
            .number()
            .int()
            .describe('The principal repayment interval. Indicates the interval of repayments that the principal has to be paid.')
            .optional(),
        repaymentInstallments: z
            .number()
            .int()
            .describe('The repayment installments. Represents how many installments are required to pay back the loan.')
            .optional(),
        repaymentPeriodCount: z
            .number()
            .int()
            .describe(
                'The repayment period count. Represents how often the loan is to be repaid: stored based on the type repayment option.',
            )
            .optional(),
        repaymentPeriodUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS', 'YEARS'])
            .describe('The repayment period unit. Represents the frequency of loan repayment.')
            .optional(),
    })
    .describe('The schedule settings, holds all schedule properties needed for schedule preview request.')

export const InterestSettingsForSchedulePreview = z
    .object({
        accountInterestRateSettings: AccountInterestRateSettings.array()
            .describe('The interest settings details for schedule preview.')
            .optional(),
        interestRate: z
            .number()
            .describe(
                'The interest rate. Represents the interest rate for the loan account. The interest on loans is accrued on a daily basis, which allows charging the clients only for the days they actually used the loan amount.',
            )
            .optional(),
        interestSpread: z
            .number()
            .describe('Interest to be added to active organization index interest rate in order to find out actual interest rate')
            .optional(),
    })
    .describe('The interest settings, holds all the properties regarding interests for the loan account.')

export const DisbursementDetailsForSchedulePreview = z
    .object({
        expectedDisbursementDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the expected disbursement.Stored as Organization Time.')
            .optional(),
        fees: CustomPredefinedFee.array().describe('List of fees that should be applied at the disbursement time.').optional(),
        firstRepaymentDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the expected first repayment. Stored as Organization Time.')
            .optional(),
    })
    .describe(
        'The the disbursement details it holds the information related to the disbursement details as disbursement date, first repayment date, disbursement fees.',
    )

export const RefinanceWriteOffAmounts = z
    .object({
        fee: z.number().describe('Fee write-off amount').optional(),
        interest: z.number().describe('Interest write-off amount').optional(),
        interestFromArrears: z.number().optional(),
        penalty: z.number().describe('Penalty write-off amount').optional(),
    })
    .describe('The write-off amounts, allowed on the loan account refinance')

export const RefinanceLoanAccount = z
    .object({
        accountArrearsSettings: RestructureAccountArrearsSettings.optional(),
        disbursementDetails: RefinanceDisbursementDetails,
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        guarantors: Guarantor.array().describe('The guarantees associated with the refinanced loan account').optional(),
        id: z.string().describe('Id of the new loan account.').optional(),
        interestSettings: RestructureInterestSettings.optional(),
        loanName: z.string().describe('The name of the new loan account.').optional(),
        notes: z.string().describe('The loan account notes').optional(),
        penaltySettings: RestructurePenaltySettings.optional(),
        principalPaymentSettings: RestructurePrincipalPaymentAccountSettings.optional(),
        productTypeKey: z.string().describe('The key of the loan product that this account is based on'),
        scheduleSettings: RestructureScheduleSettings.optional(),
    })
    .describe('The new loan account settings, allowed on the loan account refinance')

export const RescheduleWriteOffAmounts = z
    .object({
        fee: z.number().describe('Fee write-off amount').optional(),
        interest: z.number().describe('Interest write-off amount').optional(),
        interestFromArrears: z.number().describe('Interest from Arrears write-off amount').optional(),
        penalty: z.number().describe('Penalty write-off amount').optional(),
        principal: z.number().describe('Principal write-off amount').optional(),
    })
    .describe('The write-off amounts, allowed on the loan account reschedule')

export const RescheduleLoanAccount = z
    .object({
        accountArrearsSettings: RestructureAccountArrearsSettings.optional(),
        disbursementDetails: RescheduleDisbursementDetails,
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        guarantors: Guarantor.array().describe('The guarantees associated with the rescheduled loan account').optional(),
        id: z.string().describe('Id of the new loan account.').optional(),
        interestCommission: z.number().describe('The interest commission').optional(),
        interestSettings: RestructureInterestSettings.optional(),
        loanName: z.string().describe('The name of the new loan account.').optional(),
        notes: z.string().describe('Notes for the rescheduled loan account').optional(),
        penaltySettings: RestructurePenaltySettings.optional(),
        principalPaymentSettings: RestructurePrincipalPaymentAccountSettings.optional(),
        productTypeKey: z.string().describe('The key of the loan product that this account is based on'),
        scheduleSettings: RestructureScheduleSettings.optional(),
    })
    .describe('The new loan account settings, allowed on the loan account reschedule')

export const ApplyInterestInput = z
    .object({
        interestApplicationDate: z.string().datetime({ offset: true }).describe('The date up to which interest is to be posted'),
        isInterestFromArrears: z
            .boolean()
            .describe(
                'Whether the interest amount to apply should be the regular one or interest from arrears. If nothing specified it will be the regular one.',
            )
            .optional(),
        isPaymentHolidaysInterest: z
            .boolean()
            .describe(
                'Whether the interest amount to apply should be the regular one or the one accrued during the Payment Holidays. If nothing specified it will be the regular one.',
            )
            .optional(),
        notes: z.string().describe('Additional information for this action').optional(),
        paymentHolidaysInterestAmount: z.number().describe('The amount of the Payment Holidays interest to apply').optional(),
    })
    .describe('Represents a request for applying the accrued interest ')

export type ApplyInterestInput = z.infer<typeof ApplyInterestInput>

export const ApplyPlannedFeesResponse = LoanTransaction.array()

export type ApplyPlannedFeesResponse = z.infer<typeof ApplyPlannedFeesResponse>

export const ChangeArrearsSettingsInput = z
    .object({
        arrearsTolerancePeriod: z.number().int().describe('The new arrears tolerance period to be available on the account'),
        entryDate: z.string().datetime({ offset: true }).describe('The date when to change the arrears settings'),
        notes: z.string().describe('The notes for the change arrears settings action performed on the loan account').optional(),
    })
    .describe('Represents the request payload for performing an arrears settings change action')

export type ChangeArrearsSettingsInput = z.infer<typeof ChangeArrearsSettingsInput>

export const ChangeDueDatesSettingsInput = z
    .object({
        entryDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when to change the due dates settings - deprecated, use valueDate instead')
            .optional(),
        fixedDaysOfMonth: z.number().int().array().describe('The new fixed days of month to be used on the account'),
        notes: z.string().describe('The notes for the change due dates settings action performed on the loan account').optional(),
        valueDate: z.string().datetime({ offset: true }).describe('The date when to change the due dates settings').optional(),
    })
    .describe('Represents the request payload for performing change due dates settings action')

export type ChangeDueDatesSettingsInput = z.infer<typeof ChangeDueDatesSettingsInput>

export const ChangeInterestRateLoanAccountInput = z
    .object({
        interestRate: z.number().describe('The new interest rate to be available on the account').optional(),
        interestSpread: z.number().describe('The new interest spread to be available on the account').optional(),
        notes: z.string().describe('The notes for the change interest rate action performed on the loan account').optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when to change the interest rate (as Organization Time)'),
    })
    .describe('Represents the request payload for performing an PMT Adjustment action')

export type ChangeInterestRateLoanAccountInput = z.infer<typeof ChangeInterestRateLoanAccountInput>

export const ChangePeriodicPaymentLoanAccountInput = z
    .object({
        notes: z.string().describe('The notes for the change periodic payment action performed on the loan account').optional(),
        periodicPayment: z.number().describe('The new periodic payment to be available on the account'),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when to change the periodic payment (as Organization Time)'),
    })
    .describe('Represents the request payload for performing a periodic payment change action')

export type ChangePeriodicPaymentLoanAccountInput = z.infer<typeof ChangePeriodicPaymentLoanAccountInput>

export const ChangeRepaymentValueLoanAccountInput = z
    .object({
        amount: z.number().describe('Fixed amount for being used for the repayments principal due').optional(),
        notes: z.string().describe('Notes for the repayment value change action performed on the loan account').optional(),
        percentage: z.number().describe('Percentage of principal amount used for the repayments principal due').optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('Date when to change the repayment value (as Organization Time)'),
    })
    .describe('Represents the request payload for performing a repayment value change action')

export type ChangeRepaymentValueLoanAccountInput = z.infer<typeof ChangeRepaymentValueLoanAccountInput>

export const CollateralAssetFilter = z
    .object({
        branchKeys: z
            .string()
            .array()
            .describe('Assets of the loan accounts that will be filtered by the branch keys in the background process')
            .optional(),
        currencies: z
            .string()
            .array()
            .describe('Assets of the loan accounts that will be filtered by the currency codes in the background process')
            .optional(),
        productKeys: z
            .string()
            .array()
            .describe('Assets of the loan accounts that will be filtered by the product keys in the background process')
            .optional(),
    })
    .describe('Represents the input for the collateral assets reevaluation background task.')

export type CollateralAssetFilter = z.infer<typeof CollateralAssetFilter>

export const CollateralAssetsReevaluationResponse = z
    .object({
        bulkProcessKey: z.string().describe('The encoded key of the collateral assets reevaluation task').optional(),
        status: z
            .enum([
                'QUEUED',
                'IN_PROGRESS',
                'COMPLETE',
                'NOT_FOUND',
                'CANCEL',
                'TO_BE_CANCELED',
                'TIMED_OUT',
                'ERROR',
                'TRANSIENT_ERROR',
                'OVERRIDDEN',
                'RECOVERABLE_ERROR',
            ])
            .describe('The collateral assets reevaluation status')
            .optional(),
    })
    .describe('Holds the information about collateral assets reevaluation status.')

export type CollateralAssetsReevaluationResponse = z.infer<typeof CollateralAssetsReevaluationResponse>

export const CreateLoanAccountFundingSourcesRequest = InvestorFund.array()

export type CreateLoanAccountFundingSourcesRequest = z.infer<typeof CreateLoanAccountFundingSourcesRequest>

export const CreateLoanAccountFundingSourcesResponse = InvestorFund.array()

export type CreateLoanAccountFundingSourcesResponse = z.infer<typeof CreateLoanAccountFundingSourcesResponse>

export const CreatePlannedFeesRequest = PlannedInstallmentFee.array()

export type CreatePlannedFeesRequest = z.infer<typeof CreatePlannedFeesRequest>

export const CreatePlannedFeesResponse = PlannedInstallmentFee.array()

export type CreatePlannedFeesResponse = z.infer<typeof CreatePlannedFeesResponse>

export const ErrorResponse = z.object({
    errors: RestError.array().optional(),
})

export type ErrorResponse = z.infer<typeof ErrorResponse>

export const GetAllAuthorizationHoldsResponse = GetAuthorizationHold.array()

export type GetAllAuthorizationHoldsResponse = z.infer<typeof GetAllAuthorizationHoldsResponse>

export const GetAllCardsResponse = Card.array()

export type GetAllCardsResponse = z.infer<typeof GetAllCardsResponse>

export const GetAllPlannedFeesResponse = PlannedInstallmentFee.array()

export type GetAllPlannedFeesResponse = z.infer<typeof GetAllPlannedFeesResponse>

export const GetAllResponse = LoanAccount.array()

export type GetAllResponse = z.infer<typeof GetAllResponse>

export const GetLoanAccountDocumentResponse = z.string()

export type GetLoanAccountDocumentResponse = z.infer<typeof GetLoanAccountDocumentResponse>

export const GetVersionsByIdResponse = LoanAccount.array()

export type GetVersionsByIdResponse = z.infer<typeof GetVersionsByIdResponse>

export const LoanAccountAction = z
    .object({
        action: z
            .enum([
                'REQUEST_APPROVAL',
                'SET_INCOMPLETE',
                'APPROVE',
                'UNDO_APPROVE',
                'REJECT',
                'WITHDRAW',
                'CLOSE',
                'UNDO_REJECT',
                'UNDO_WITHDRAW',
                'UNDO_CLOSE',
            ])
            .describe('The action type to be applied.'),
        notes: z.string().describe('The notes related to the action performed.').optional(),
    })
    .describe('Represents information for an action to perform on a loan account.')

export type LoanAccountAction = z.infer<typeof LoanAccountAction>

export const LoanAccountBalances = z
    .object({
        balances: z.record(z.number().optional()).describe('Balances for a loan account').optional(),
    })
    .describe('Balances for a loan account')

export type LoanAccountBalances = z.infer<typeof LoanAccountBalances>

export const LoanAccountPayOffInput = z
    .object({
        externalId: z.string().describe('The external ID for the repayment transaction.').optional(),
        notes: z.string().describe('The notes for the repayment transaction logged for the pay off action.').optional(),
        payOffAdjustableAmounts: PayOffAdjustableAmounts.optional(),
        transactionDetails: TransactionDetails.optional(),
    })
    .describe('Represents the information for loan account pay off action.')

export type LoanAccountPayOffInput = z.infer<typeof LoanAccountPayOffInput>

export const LoanAccountSchedule = z
    .object({
        currency: Currency.optional(),
        installments: Installment.array().describe('The loan account schedule installments list.').optional(),
    })
    .describe('Represents a single loan account schedule structure.')

export type LoanAccountSchedule = z.infer<typeof LoanAccountSchedule>

export const LoanAccountSearchCriteria = z
    .object({
        filterCriteria: LoanAccountFilterCriteria.array().describe('The list of filtering criteria').optional(),
        sortingCriteria: LoanAccountSortingCriteria.optional(),
    })
    .describe('Wrapper that holds a list of filtering criteria and a sorting criteria for Loan account directed query')

export type LoanAccountSearchCriteria = z.infer<typeof LoanAccountSearchCriteria>

export const LoanActionDetails = z
    .object({
        notes: z.string().describe('The notes for the action performed on a loan account.').optional(),
    })
    .describe('Represents details about an action performed on a loan account.')

export type LoanActionDetails = z.infer<typeof LoanActionDetails>

export const PatchFundingSourceRequest = PatchOperation.array()

export type PatchFundingSourceRequest = z.infer<typeof PatchFundingSourceRequest>

export const PatchRequest = PatchOperation.array()

export type PatchRequest = z.infer<typeof PatchRequest>

export const PlannedFeeKeys = z
    .object({
        encodedKeys: z.string().array().describe('The list of encoded keys of the planned installment fees.'),
    })
    .describe('The planned installment fees encoded keys list')

export type PlannedFeeKeys = z.infer<typeof PlannedFeeKeys>

export const PreviewLoanAccountSchedule = z
    .object({
        disbursementDetails: DisbursementDetailsForSchedulePreview.optional(),
        interestCommission: z
            .number()
            .describe(
                'The value of the interest booked by the organization from the accounts funded by investors. Null if the funds are not enable',
            )
            .optional(),
        interestSettings: InterestSettingsForSchedulePreview.optional(),
        loanAmount: z.number().describe('The loan amount'),
        plannedInstallmentFees: PlannedInstallmentFee.array()
            .describe('A list with planned manual fees to be applied on the installments for schedule preview.')
            .optional(),
        productTypeKey: z.string().describe('The key to the type of product that this account is based on.'),
        scheduleSettings: ScheduleSettingsForSchedulePreview.optional(),
        topUpAmount: z.number().describe('The top up amount in case of a refinanced account').optional(),
        tranches: LoanTranche.array().describe('List of tranches to be considered for schedule preview.').optional(),
    })
    .describe('Payload structure to preview loan account schedule.')

export type PreviewLoanAccountSchedule = z.infer<typeof PreviewLoanAccountSchedule>

export const PreviewPayOffDueAmountsInAFutureDateInput = z
    .object({
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date until which the amounts due for pay off should be calculated'),
    })
    .describe('Represents the information to preview the pay off due amounts in a future date.')

export type PreviewPayOffDueAmountsInAFutureDateInput = z.infer<typeof PreviewPayOffDueAmountsInAFutureDateInput>

export const PreviewPayOffDueAmountsInAFutureDateWrapper = z
    .object({
        earlyRepaymentCharge: z
            .number()
            .describe('The early repayment charge balance due when pay off the account in a future date')
            .optional(),
        feeBalance: z.number().describe('The fee balance due when pay off the account in a future date').optional(),
        interestBalance: z.number().describe('The interest balance due when pay off the account in a future date').optional(),
        interestFromArrearsBalance: z
            .number()
            .describe('The interest from arrears balance due when pay off the account in a future date')
            .optional(),
        penaltyBalance: z.number().describe('The penalty balance due when pay off the account in a future date').optional(),
        principalBalance: z.number().describe('The principal balance due when pay off the account in a future date').optional(),
        totalBalance: z.number().describe('The total balance due when pay off the account in a future date').optional(),
    })
    .describe('Represents a wrapper over a set of due amounts representing pay off due amounts in a future date')

export type PreviewPayOffDueAmountsInAFutureDateWrapper = z.infer<typeof PreviewPayOffDueAmountsInAFutureDateWrapper>

export const RefinanceLoanAccountAction = z
    .object({
        keepSameAccountId: z
            .boolean()
            .describe(
                `Choose whether to keep the same account ID as the originating account. If true, the 'id' field in the 'loanAccount' object should not be provided.`,
            )
            .optional(),
        loanAccount: RefinanceLoanAccount,
        topUpAmount: z.number().describe('The top-up amount'),
        writeOffAmounts: RefinanceWriteOffAmounts.optional(),
    })
    .describe('The request structure for performing the refinance loan account action')

export type RefinanceLoanAccountAction = z.infer<typeof RefinanceLoanAccountAction>

export const RescheduleLoanAccountAction = z
    .object({
        keepSameAccountId: z
            .boolean()
            .describe(
                `Choose whether to keep the same account ID as the originating account. If true, the 'id' field in the 'loanAccount' object should not be provided.`,
            )
            .optional(),
        loanAccount: RescheduleLoanAccount,
        writeOffAmounts: RescheduleWriteOffAmounts.optional(),
    })
    .describe('The request payload for performing a reschedule loan account action')

export type RescheduleLoanAccountAction = z.infer<typeof RescheduleLoanAccountAction>

export const SearchResponse = LoanAccount.array()

export type SearchResponse = z.infer<typeof SearchResponse>

export const TerminateLoanAccountInput = z
    .object({
        notes: z.string().describe('The notes for the terminate action performed on the loan account').optional(),
        valueDate: z.string().datetime({ offset: true }).describe('The date when terminate the loan account'),
    })
    .describe('Represents the request payload for the terminate a loan account action')

export type TerminateLoanAccountInput = z.infer<typeof TerminateLoanAccountInput>

export const UpdateLoanAccountFundingSourcesRequest = InvestorFund.array()

export type UpdateLoanAccountFundingSourcesRequest = z.infer<typeof UpdateLoanAccountFundingSourcesRequest>

export const UpdateLoanAccountFundingSourcesResponse = InvestorFund.array()

export type UpdateLoanAccountFundingSourcesResponse = z.infer<typeof UpdateLoanAccountFundingSourcesResponse>

export const UpdatePlannedFeesRequest = PlannedInstallmentFee.array()

export type UpdatePlannedFeesRequest = z.infer<typeof UpdatePlannedFeesRequest>

export const UpdatePlannedFeesResponse = PlannedInstallmentFee.array()

export type UpdatePlannedFeesResponse = z.infer<typeof UpdatePlannedFeesResponse>
