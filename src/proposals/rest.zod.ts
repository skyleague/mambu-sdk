/**
 * Generated by @skyleague/therefore
 * Do not manually touch this
 */
// biome-ignore-all lint: this file is generated
/* eslint-disable */

import { z } from 'zod/v4'

export const CustomerShareTier = z
    .object({
        creationDate: z.iso.datetime({ offset: true }).describe('The creation time of the customer share tier').optional(),
        fromValue: z.number().describe('The starting value for the customer share tier').optional(),
        id: z.number().int().describe('The identifier of the customer share tier').optional(),
        lastModifiedDate: z.iso
            .datetime({ offset: true })
            .describe('The last modified time of the customer share tier')
            .optional(),
        percentage: z.number().describe('The percentage of the customer share tier').optional(),
        productSettingsId: z.number().int().describe('The identifier of the associated product settings').optional(),
    })
    .describe('Customer share tier for product settings')

export type CustomerShareTier = z.infer<typeof CustomerShareTier>

export const Profit = z
    .object({
        cappedRatePercentage: z.number().describe('Upper threshold limit on the calculated customer profit rate').optional(),
        fixedRatePercentage: z.number().describe('A fixed percentage used to calculate the final profit amount').optional(),
        fixedRateRule: z
            .enum(['ALWAYS_USE_FIXED_RATE', 'TREAT_AS_MIN', 'USE_CALCULATED_RATE'])
            .describe('The type of fixed rate')
            .optional(),
        tiers: CustomerShareTier.array().describe('List of customer share tiers associated with product settings').optional(),
    })
    .describe('Profit calculation configuration for accrual')

export type Profit = z.infer<typeof Profit>

export const BalanceEligibility = z
    .object({
        minimumEligible: z
            .number()
            .describe('The minimum eligible balance to be included in the profit computation flow')
            .optional(),
        type: z
            .enum(['END_OF_THE_DAY_BALANCE', 'AVERAGE_BALANCE', 'MINIMUM_BALANCE'])
            .describe('The balance eligibility type')
            .optional(),
    })
    .describe('Criteria for eligibility of account balances')

export type BalanceEligibility = z.infer<typeof BalanceEligibility>

export const ProductCalculationCycle = z
    .object({
        accountNumber: z.number().int().describe('The account number for the product calculation cycle'),
        aggregatedAccountBalancesPayment: z.number().describe('The aggregated account balances payment'),
        aggregatedAccountBalancesProfit: z.number().describe('The aggregated account balances profit'),
        averageBalance: z.number().describe('The average balance of the product calculation cycle'),
        balanceEligibility: BalanceEligibility,
        creationDate: z.iso.datetime({ offset: true }).describe('The creation time of the product calculation cycle'),
        endDate: z.iso.date().describe('The end date for the product calculation cycle'),
        id: z.number().int().describe('The identifier of the product calculation cycle').optional(),
        lastModifiedDate: z.iso.datetime({ offset: true }).describe('The last modified time of the product calculation cycle'),
        poolCalculationCycleId: z.number().int().describe('The identifier of the pool calculation cycle'),
        productEncodedKey: z.string().describe('The associated product encoded key'),
        profit: Profit,
        profitRate: z.number().describe('The profit rate for the product calculation'),
        startDate: z.iso.date().describe('The start date for the product calculation cycle'),
        status: z.enum(['ACTIVE', 'INACTIVE']).describe('The status of the product calculation cycle'),
        totalAccruedProfitAmount: z.number().describe('The total accrued profit amount'),
        totalBankShareAmountPayment: z.number().describe('The total bank share amount payment'),
        totalBankShareAmountProfit: z.number().describe('The total bank share amount profit'),
        totalFinalShareAmount: z.number().describe('The total final share amount'),
        totalMudaribShareAmountPayment: z.number().describe('The total mudarib share amount payment'),
        totalMudaribShareAmountProfit: z.number().describe('The total mudarib share amount profit'),
        totalWithholdingTaxAmount: z.number().describe('The total Withholding tax amount'),
        withholdingTaxEnabled: z.boolean().describe('Indicates whether withholding tax is enabled in the associated IPS product'),
        withholdingTaxSourceKey: z
            .string()
            .describe('The key reference for the withholding tax source based on the the associated IPS product settings')
            .optional(),
    })
    .describe('Profit calculation cycle for a product')

export type ProductCalculationCycle = z.infer<typeof ProductCalculationCycle>

export const CashFlowCalculationCycle = z
    .object({
        allocationMethod: z
            .enum(['AVERAGE_BALANCE', 'NUMBER_OF_ACCOUNTS', 'PERCENTAGE'])
            .describe('The allocation method of the cash flow'),
        allocationPercentage: z.number().describe('Allocation percentage').optional(),
        amount: z.number().describe('The amount of the cash flow calculation cycle').optional(),
        cashFlowId: z.number().int().describe('The identifier of the cash flow').optional(),
        cashFlowType: z.enum(['INCOME_CATEGORY', 'EXPENSE_CATEGORY']).describe('The type of the cash flow'),
        creationDate: z.iso.datetime({ offset: true }).describe('The creation time of the cash flow calculation cycle'),
        glAccountEncodedKey: z.string().describe('The GL account encoded key').optional(),
        id: z.number().int().describe('The identifier of the cash flow calculation cycle').optional(),
        lastModifiedDate: z.iso.datetime({ offset: true }).describe('The last modified time of the cash flow calculation cycle'),
        percentage: z.number().describe('The percentage of the cash flow calculation cycle').optional(),
        poolCalculationCycleId: z.number().int().describe('The identifier of the pool calculation cycle').optional(),
        proposalId: z.number().int().describe('The identifier of the proposal').optional(),
        source: z.enum(['ISLAMIC_FINANCE', 'OTHERS']).describe('The source of the cash flow').optional(),
    })
    .describe('Profit calculation cycle for a cash flow')

export type CashFlowCalculationCycle = z.infer<typeof CashFlowCalculationCycle>

export const PoolCalculationCycle = z
    .object({
        accountNumber: z.number().int().describe('The account number for the pool calculation cycle'),
        averageBalance: z.number().describe('The average balance of the pool calculation cycle'),
        cashFlowCalculationCycles: CashFlowCalculationCycle.array()
            .describe('The associated cash flow calculation cycles')
            .optional(),
        creationDate: z.iso.datetime({ offset: true }).describe('The creation time of the pool calculation cycle'),
        customerSharesLoss: z.boolean().describe('The loss is charged to customer account when true'),
        daysInMonth: z
            .literal('DAYS_ACTUAL')
            .describe('The number of days in a month to be considered in the profit calculation'),
        daysInYear: z.literal('DAYS365').describe('The number of days in a year to be considered in the profit calculation'),
        endDate: z.iso.date().describe('The end date of the pool calculation cycle'),
        id: z.number().int().describe('The pool calculation cycle identifier').optional(),
        lastModifiedDate: z.iso.datetime({ offset: true }).describe('The last modified time of the pool calculation cycle'),
        poolId: z.number().int().describe('The pool identifier'),
        productCalculationCycles: ProductCalculationCycle.array()
            .describe('The associated product calculation cycles')
            .optional(),
        profitAmount: z.number().describe('The profit amount per pool'),
        profitCalculationBalanceType: z
            .enum(['END_OF_THE_DAY_BALANCE', 'AVERAGE_BALANCE', 'MINIMUM_BALANCE'])
            .describe('The aggregated balance type per account to be used in the calculation'),
        profitRate: z.number().describe('The profit rate per pool'),
        proposalId: z.number().int().describe('The proposal identifier').optional(),
        startDate: z.iso.date().describe('The start date of the pool calculation cycle'),
        status: z.enum(['OPEN', 'CLOSE']).describe('The pool calculation cycle status'),
        totalExpenses: z.number().describe('The total expense for a profit calculation cycle'),
        totalIncome: z.number().describe('The total income for a profit calculation cycle'),
    })
    .describe('Profit calculation cycle for a pool')

export type PoolCalculationCycle = z.infer<typeof PoolCalculationCycle>

export const RestError = z.object({
    errorCode: z.number().int().optional(),
    errorReason: z.string().optional(),
    errorSource: z.string().optional(),
})

export type RestError = z.infer<typeof RestError>

export const ProposalAccountDetails = z
    .object({
        accountId: z.string().describe('The identifier of the account').optional(),
        accountState: z
            .enum([
                'PENDING_APPROVAL',
                'APPROVED',
                'ACTIVE',
                'ACTIVE_IN_ARREARS',
                'MATURED',
                'LOCKED',
                'DORMANT',
                'CLOSED',
                'CLOSED_WRITTEN_OFF',
                'WITHDRAWN',
                'CLOSED_REJECTED',
            ])
            .describe('The account state')
            .optional(),
        paymentCycleAdjustedCustomerProfitRate: z
            .number()
            .describe('The profit rate applicable to the customer for the payment cycle, adjusted for other factors')
            .optional(),
        paymentCycleBankShareAmount: z
            .number()
            .describe(`The monetary value of the bank's share of the profit, for the payment cycle period`)
            .optional(),
        paymentCycleCustomerProfitAmount: z
            .number()
            .describe('The monetary value of the customer profit, for the payment cycle period')
            .optional(),
        paymentCycleCustomerProfitRate: z
            .number()
            .describe('The profit rate applicable to the customer for the payment cycle')
            .optional(),
        paymentCycleCustomerShareAmount: z
            .number()
            .describe(`The monetary value of the customer's share of the profit, for the payment cycle period`)
            .optional(),
        paymentCycleCustomerSharePercentage: z
            .number()
            .describe('The percentage of profit allocated to the customer for the payment cycle')
            .optional(),
        paymentCycleEligibleBalance: z.number().describe('The eligible balance of the account for the payment cycle').optional(),
        paymentCycleEndDate: z.iso.date().describe('The end date of the payment calculation cycle'),
        paymentCycleMudaribShareAmount: z
            .number()
            .describe('The monetary value of the mudarib share, for the payment cycle period')
            .optional(),
        paymentCycleNumberOfDays: z.number().int().describe('length of the payment calculation cycle in days').optional(),
        paymentCycleWithholdingTaxAmount: z
            .number()
            .describe('The monetary value of the withholding tax amount, for the payment cycle period')
            .optional(),
        profitCappedRatePercentage: z.number().describe('Capped rate percentage needed by the rate rule').optional(),
        profitCycleAdjustedCustomerProfitRate: z
            .number()
            .describe('The profit rate applicable to the customer for the profit cycle, adjusted for other factors')
            .optional(),
        profitCycleBankShareAmount: z
            .number()
            .describe(`The monetary value of the bank's share of the profit, for the profit cycle period`)
            .optional(),
        profitCycleCustomerProfitAmount: z
            .number()
            .describe('The monetary value of the customer profit, for the profit cycle period')
            .optional(),
        profitCycleCustomerProfitRate: z
            .number()
            .describe('The profit rate applicable to the customer for the profit cycle')
            .optional(),
        profitCycleCustomerShareAmount: z
            .number()
            .describe(`The monetary value of the customer's share of the profit, for the profit cycle period`)
            .optional(),
        profitCycleCustomerSharePercentage: z
            .number()
            .describe('The percentage of profit allocated to the customer for the profit cycle')
            .optional(),
        profitCycleEligibleBalance: z.number().describe('The eligible balance of the account for the profit cycle').optional(),
        profitCycleEndDate: z.iso.date().describe('The end date of the profit calculation cycle'),
        profitCycleMudaribShareAmount: z
            .number()
            .describe('The monetary value of the mudarib share, for the profit cycle period')
            .optional(),
        profitCycleNumberOfDays: z.number().int().describe('length of the profit calculation cycle in days').optional(),
        profitFixedRatePercentage: z.number().describe('Fixed rate percentage needed by the rate rule').optional(),
        profitFixedRateRule: z
            .enum(['ALWAYS_USE_FIXED_RATE', 'TREAT_AS_MIN', 'USE_CALCULATED_RATE'])
            .describe('Fixed rate rule for applying the fixed rate percentage')
            .optional(),
    })
    .describe('Payment/Profit calculation cycle for an Account')

export type ProposalAccountDetails = z.infer<typeof ProposalAccountDetails>

export const Proposal = z
    .object({
        creationDate: z.iso.datetime({ offset: true }).describe('The creation date of the proposal.').optional(),
        endDate: z.iso.date().describe('The end date of the proposal.'),
        id: z.number().int().describe('The identifier of the proposal.').optional(),
        lastModifiedDate: z.iso.datetime({ offset: true }).describe('The last modified date of the proposal.').optional(),
        ownerEncodedKey: z.string().describe('The encoded key of the proposal owner.').optional(),
        poolCalculationCycles: PoolCalculationCycle.array().describe('The associated pool calculation cycles.'),
        proposalType: z.enum(['DEFAULT', 'CUSTOM']).describe('The type of the proposal (DEFAULT, CUSTOM).'),
        startDate: z.iso.date().describe('The start date of the proposal.'),
        status: z
            .enum(['PENDING', 'APPROVED', 'REJECTED', 'APPLIED'])
            .describe('The status of the proposal (PENDING, APPROVED, REJECTED, APPLIED).'),
    })
    .describe('Represents a single proposal with associated calculation cycles.')

export type Proposal = z.infer<typeof Proposal>

export const ProposalAccountDetailsSortingCriteria = z
    .object({
        field: z
            .literal('sa.id')
            .describe(
                'The field to use to sort the selection. This can be an enumerated value or a custom field using the format [customFieldSetId].[customFieldId].',
            ),
        order: z.enum(['ASC', 'DESC']).describe('The sorting order: `ASC` or `DESC`. The default order is `DESC`.').optional(),
    })
    .describe('The sorting criteria used for sorting account details.')

export type ProposalAccountDetailsSortingCriteria = z.infer<typeof ProposalAccountDetailsSortingCriteria>

export const ErrorResponse = z.object({
    errors: RestError.array().optional(),
})

export type ErrorResponse = z.infer<typeof ErrorResponse>

export const FindProposalAccountDetailsResponse = ProposalAccountDetails.array()

export type FindProposalAccountDetailsResponse = z.infer<typeof FindProposalAccountDetailsResponse>

export const FindProposalsResponse = Proposal.array()

export type FindProposalsResponse = z.infer<typeof FindProposalsResponse>

export const ProposalAccountDetailsSearchCriteria = z
    .object({
        accountId: z.string().describe('The identifier of the account').optional(),
        sortingCriteria: ProposalAccountDetailsSortingCriteria.optional(),
    })
    .describe('Defines the search criteria for the proposal account details')

export type ProposalAccountDetailsSearchCriteria = z.infer<typeof ProposalAccountDetailsSearchCriteria>

export const ProposalsSearchCriteria = z
    .object({
        financialDate: z.iso
            .date()
            .describe('A specific date to filter proposals. The date must fall within the start and end dates of the proposals.')
            .optional(),
        poolIds: z.number().int().array().describe('The pool identifier used to filter proposals.').optional(),
        status: z
            .enum(['PENDING', 'APPROVED', 'REJECTED', 'APPLIED'])
            .describe('The status of the proposals to filter (e.g., PENDING, APPROVED, REJECTED, APPLIED).')
            .optional(),
        type: z.enum(['DEFAULT', 'CUSTOM']).describe('The type of the proposals to filter (e.g., DEFAULT, CUSTOM).').optional(),
    })
    .describe('Defines the search criteria for fetching proposals.')

export type ProposalsSearchCriteria = z.infer<typeof ProposalsSearchCriteria>
