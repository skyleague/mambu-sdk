/**
 * Generated by @skyleague/therefore
 * Do not manually touch this
 */
/* eslint-disable */

import { z } from 'zod'

export const CreditorReferenceInformation = z
    .object({
        reference: z.string().describe(`The reference information of the creditor's underlying documents`).optional(),
        referenceIssuer: z.string().describe('The entity that assigns the reference type').optional(),
        referenceType: z.string().describe('The type of creditor reference').optional(),
    })
    .describe('Represents the reference to the underlying documents of the payment.')

export type CreditorReferenceInformation = z.infer<typeof CreditorReferenceInformation>

export const OtherAccountIdentification = z
    .object({
        identification: z.string().describe('The identification of the payer/payee').optional(),
        scheme: z.string().describe('The identification scheme').optional(),
    })
    .describe('Represents other way of identification for the account.')

export type OtherAccountIdentification = z.infer<typeof OtherAccountIdentification>

export const Structured = z
    .object({
        creditorReferenceInformation: CreditorReferenceInformation.optional(),
    })
    .describe('The information specifying the payment items that are intended to settle')

export type Structured = z.infer<typeof Structured>

export const ServiceLevel = z
    .object({
        code: z.string().describe('The code for a pre-agreed service or level of service between the parties').optional(),
    })
    .describe('The rules under which the transaction should be processed')

export type ServiceLevel = z.infer<typeof ServiceLevel>

export const FinancialInstitutionIdentification = z
    .object({
        bic: z.string().describe('Business identifier code').optional(),
    })
    .describe('The identification of the financial institution')

export type FinancialInstitutionIdentification = z.infer<typeof FinancialInstitutionIdentification>

export const AccountIdentification = z
    .object({
        iban: z.string().describe('The account unique identifier').optional(),
        other: OtherAccountIdentification.optional(),
    })
    .describe('The account identification details')

export type AccountIdentification = z.infer<typeof AccountIdentification>

export const DepositOverdraftSettings = z
    .object({
        overdraftLimit: z.number().describe('The overdraft limit that was set or changed in this transaction').optional(),
    })
    .describe('Holds the deposit overdraft settings for a transaction')

export type DepositOverdraftSettings = z.infer<typeof DepositOverdraftSettings>

export const DepositOverdraftInterestSettings = z
    .object({
        indexInterestRate: z
            .number()
            .describe('The value of the index interest rate set or changed in this transaction')
            .optional(),
        interestRate: z
            .number()
            .describe(
                'The interest rate that was set or changed in this transaction. Used on product interest rate changes or interest tier switches',
            )
            .optional(),
    })
    .describe('Holds the deposit overdraft interest settings')

export type DepositOverdraftInterestSettings = z.infer<typeof DepositOverdraftInterestSettings>

export const DepositTransactionInterestSettings = z
    .object({
        indexInterestRate: z
            .number()
            .describe('The value of the index interest rate set or changed in this transaction')
            .optional(),
        interestRate: z.number().describe('The interest rate for the deposit account').optional(),
    })
    .describe('The interest settings, holds all the properties regarding interests for the deposit account')

export type DepositTransactionInterestSettings = z.infer<typeof DepositTransactionInterestSettings>

export const RemittanceInformation = z
    .object({
        structured: Structured.optional(),
        unstructured: z
            .string()
            .describe('Information supplied to match the items of the payment in an unstructured form')
            .optional(),
    })
    .describe('The information specifying the payment items that are intended to settle')

export type RemittanceInformation = z.infer<typeof RemittanceInformation>

export const PaymentTypeInformation = z
    .object({
        serviceLevel: ServiceLevel.optional(),
    })
    .describe('The information specifying the type of transaction')

export type PaymentTypeInformation = z.infer<typeof PaymentTypeInformation>

export const PaymentIdentification = z
    .object({
        endToEndIdentification: z.string().describe('Identifier assigned by the initiating party to the transaction').optional(),
        instructionIdentification: z.string().describe('Identifier of a payment instruction').optional(),
        transactionIdentification: z
            .string()
            .describe('Identifier unique for a period assigned by the first initiating party to the transaction')
            .optional(),
    })
    .describe('The payment identification details')

export type PaymentIdentification = z.infer<typeof PaymentIdentification>

export const Agent = z
    .object({
        financialInstitutionIdentification: FinancialInstitutionIdentification.optional(),
    })
    .describe('The agent details for a party')

export type Agent = z.infer<typeof Agent>

export const AccountDetails = z
    .object({
        currency: z.string().describe('The currency of the account').optional(),
        identification: AccountIdentification.optional(),
    })
    .describe('The account currency and identification')

export type AccountDetails = z.infer<typeof AccountDetails>

export const Party = z
    .object({
        name: z.string().describe('The name of the party').optional(),
    })
    .describe('The details of the party for a transaction')

export type Party = z.infer<typeof Party>

export const CardAcceptor = z
    .object({
        city: z.string().describe('The city in which the card acceptor has the business.').optional(),
        country: z.string().describe('The country in which the card acceptor has the business.').optional(),
        mcc: z.number().int().describe('The Merchant Category Code of the card acceptor.').optional(),
        name: z.string().describe('The name of the card acceptor.').optional(),
        state: z.string().describe('The state in which the card acceptor has the business.').optional(),
        street: z.string().describe('The street in which the card acceptor has the business.').optional(),
        zip: z.string().describe('The ZIP code of the location in which the card acceptor has the business.').optional(),
    })
    .describe('The details of the card acceptor (merchant) in a transaction hold.')

export type CardAcceptor = z.infer<typeof CardAcceptor>

export const AccountBalances = z
    .object({
        accountId: z.string().describe('The unique account identifier').optional(),
        availableBalance: z.number().describe('The available balance of a deposit or credit account').optional(),
        cardType: z.enum(['DEBIT', 'CREDIT']).describe('The card type either DEBIT or CREDIT').optional(),
        creditLimit: z
            .number()
            .describe('The overdraft limit of a deposit account or the loan amount in case of a credit account')
            .optional(),
        currencyCode: z.string().describe('Currency code used for the account').optional(),
        totalBalance: z
            .number()
            .describe('The current balance of a deposit account or principal balance of a revolving credit')
            .optional(),
    })
    .describe('Account balances presented to inquirer such as card processor')

export type AccountBalances = z.infer<typeof AccountBalances>

export const LinkedTransaction = z
    .object({
        linkedTransactionKey: z.string().describe('The encodedKey of the linked financial transaction.').optional(),
        linkedTransactionType: z
            .enum(['LOAN', 'DEPOSIT'])
            .describe('The type of the linked transaction (Deposit / Loan).')
            .optional(),
    })
    .describe('The details of the linked financial transaction triggered by the card transaction.')

export type LinkedTransaction = z.infer<typeof LinkedTransaction>

export const RestError = z.object({
    errorCode: z.number().int().optional(),
    errorReason: z.string().optional(),
    errorSource: z.string().optional(),
})

export type RestError = z.infer<typeof RestError>

export const TransferDetails = z
    .object({
        linkedDepositTransactionKey: z.string().describe('The key of the related deposit transaction').optional(),
        linkedLoanTransactionKey: z.string().describe('The key of the related loan transaction').optional(),
    })
    .describe('Represents the transfer details, such as the linked transaction key')

export type TransferDetails = z.infer<typeof TransferDetails>

export const TransactionDetails = z
    .object({
        transactionChannelId: z
            .string()
            .describe('The id of the transaction channel associated with the transaction details.')
            .optional(),
        transactionChannelKey: z
            .string()
            .describe('The encoded key of the transaction channel associated with the transaction details.')
            .optional(),
    })
    .describe('Contains the details about transaction including fields like transaction channel key and channel id')

export type TransactionDetails = z.infer<typeof TransactionDetails>

export const DepositTerms = z
    .object({
        interestSettings: DepositTransactionInterestSettings.optional(),
        overdraftInterestSettings: DepositOverdraftInterestSettings.optional(),
        overdraftSettings: DepositOverdraftSettings.optional(),
    })
    .describe('The deposit transaction terms')

export type DepositTerms = z.infer<typeof DepositTerms>

export const DepositTaxes = z
    .object({
        taxRate: z.number().describe('The tax rate that was set or changed in this transaction').optional(),
    })
    .describe('The taxes applied within a transaction')

export type DepositTaxes = z.infer<typeof DepositTaxes>

export const PaymentDetails = z
    .object({
        creditor: Party.optional(),
        creditorAccount: AccountDetails.optional(),
        creditorAgent: Agent.optional(),
        debtor: Party.optional(),
        debtorAccount: AccountDetails.optional(),
        debtorAgent: Agent.optional(),
        paymentIdentification: PaymentIdentification.optional(),
        paymentTypeInformation: PaymentTypeInformation.optional(),
        remittanceInformation: RemittanceInformation.optional(),
    })
    .describe('The payment information including account identification details')

export type PaymentDetails = z.infer<typeof PaymentDetails>

export const DepositInterestAccruedAmounts = z
    .object({
        interestAccrued: z
            .number()
            .describe(
                'The amount of positive interest accrued since last interest application/activation date and applied within Interest Applied transaction',
            )
            .optional(),
        negativeInterestAccrued: z
            .number()
            .describe(
                'The amount of negative interest accrued since last interest application/activation date and applied within Interest Applied transaction',
            )
            .optional(),
        overdraftInterestAccrued: z
            .number()
            .describe(
                'The amount of overdraft interest accrued since last interest application/activation date and applied within Interest Applied transaction',
            )
            .optional(),
        technicalOverdraftInterestAccrued: z
            .number()
            .describe(
                'The amount of technical overdraft interest accrued since last interest application/activation date and applied within Interest Applied transaction',
            )
            .optional(),
    })
    .describe('Represents the accrued interest amounts for an Interest Applied deposit transaction.')

export type DepositInterestAccruedAmounts = z.infer<typeof DepositInterestAccruedAmounts>

export const DepositFee = z
    .object({
        amount: z
            .number()
            .describe('The amount of the fee that was applied/paid in the transaction for the given predefined fee.')
            .optional(),
        name: z.string().describe('The name of the predefined fee').optional(),
        predefinedFeeKey: z.string().describe('The encoded key of the predefined fee, auto generated, unique'),
        taxAmount: z.number().describe('The amount of the taxes on fee that was applied/paid in the transaction.').optional(),
        trigger: z.enum(['MANUAL', 'MONTHLY_FEE', 'ARBITRARY']).describe('Shows the event that will trigger a fee').optional(),
    })
    .describe('An amount of predefined fee that was applied or paid on an account.')

export type DepositFee = z.infer<typeof DepositFee>

export const CardTransactionReversal = z
    .object({
        amount: z
            .number()
            .describe(`The amount of money to be credited in the client's account from the original card transaction.`),
        currencyCode: z
            .string()
            .describe(
                'The ISO currency code in which the card reversal transaction is posted. The amounts are stored in the base currency, but the transaction can be created with a foreign currency.',
            )
            .optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID to be used to reference the card reversal transaction in subsequent requests.'),
        id: z.number().int().describe('The id of the Deposit Transaction').optional(),
        transactionChannelId: z
            .string()
            .describe(
                'The ID of the channel through which the payment is done. If the value is not present, the value from the source card transaction is copied.',
            )
            .optional(),
    })
    .describe('A full or partial reversal of a card transaction.')

export type CardTransactionReversal = z.infer<typeof CardTransactionReversal>

export const CardTransaction = z
    .object({
        advice: z.boolean().describe('Whether the given request should be accepted without balance validations.'),
        amount: z.number().describe('The amount of money to be withdrawn in the financial transaction.'),
        cardAcceptor: CardAcceptor.optional(),
        cardToken: z.string().describe('The reference token of the card.').optional(),
        currencyCode: z
            .string()
            .describe(
                'The ISO currency code in which the card reversal transaction is posted. The amounts are stored in the base currency, but the transaction can be created with a foreign currency.',
            )
            .optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        externalAuthorizationReferenceId: z
            .string()
            .describe(
                'The external authorization hold reference ID, which relates this card transaction to a previous authorization hold.',
            )
            .optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID to be used to reference the card transaction in subsequent requests.'),
        userTransactionTime: z.string().describe('The formatted time at which the user made this card transaction.').optional(),
    })
    .describe('A card transaction entry which will have a corresponding a financial transaction performed.')

export type CardTransaction = z.infer<typeof CardTransaction>

export const DepositAffectedAmounts = z
    .object({
        feesAmount: z
            .number()
            .describe('Amount of fees involved in a transaction that affects an account with positive balance')
            .optional(),
        fractionAmount: z
            .number()
            .describe(
                'In the case of an LOAN_FRACTION_BOUGHT this represent the fraction amount which was bought from another investor',
            )
            .optional(),
        fundsAmount: z
            .number()
            .describe('Balance change amount involved in a transaction that affects an account with positive balance')
            .optional(),
        interestAmount: z
            .number()
            .describe('Amount of interest involved in a transaction that affects an account with positive balance')
            .optional(),
        overdraftAmount: z
            .number()
            .describe('The amount of money that was added/subtracted from the account by this transaction as overdraft')
            .optional(),
        overdraftFeesAmount: z.number().describe('Fees amount involved in a transaction that affects an overdraft').optional(),
        overdraftInterestAmount: z
            .number()
            .describe('Interest amount involved in a transaction that affects an overdraft')
            .optional(),
        technicalOverdraftAmount: z
            .number()
            .describe('The amount of money that was added/subtracted from the account by this transaction as technical overdraft')
            .optional(),
        technicalOverdraftInterestAmount: z
            .number()
            .describe(
                'The amount of money that was added/subtracted from the account by this transaction as technical overdraft interest',
            )
            .optional(),
    })
    .describe('The amounts affected after completing the deposit transaction')

export type DepositAffectedAmounts = z.infer<typeof DepositAffectedAmounts>

export const DepositTransactionBalances = z
    .object({
        totalBalance: z.number().describe('The running balance owed by deposit').optional(),
    })
    .describe('The balances changed within a transaction.')

export type DepositTransactionBalances = z.infer<typeof DepositTransactionBalances>

export const PatchOperation = z
    .object({
        from: z.string().describe('The field from where a value should be moved, when using move').optional(),
        op: z.enum(['ADD', 'REPLACE', 'REMOVE', 'MOVE']).describe('The change to perform'),
        path: z.string().describe('The field to perform the operation on'),
        value: z.unknown().describe('The value of the field, can be null').optional(),
    })
    .describe('A single change that needs to be made to a resource')

export type PatchOperation = z.infer<typeof PatchOperation>

export const AuthorizationHold = z
    .object({
        accountKey: z.string().describe('The key of the account linked with the authorization hold.').optional(),
        advice: z.boolean().describe('Whether the given request should be accepted without balance validations.'),
        amount: z.number().describe('The amount of money to be held as a result of the authorization hold request.'),
        balances: AccountBalances.optional(),
        cardAcceptor: CardAcceptor.optional(),
        cardToken: z.string().describe('The reference token of the card.').optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The organization time when the authorization hold was created')
            .optional(),
        creditDebitIndicator: z
            .enum(['DBIT', 'CRDT'])
            .describe(
                'Indicates whether the authorization hold amount is credited or debited.If not provided, the default values is DBIT.',
            )
            .optional(),
        currencyCode: z
            .string()
            .describe(
                'The ISO currency code in which the hold was created. The amounts are stored in the base currency, but the user could have enter it in a foreign currency.',
            )
            .optional(),
        customExpirationPeriod: z
            .number()
            .int()
            .describe('The custom expiration period for the hold which overwrites mcc and default expiration periods')
            .optional(),
        exchangeRate: z.number().describe('The exchange rate for the original currency.').optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID to be used to reference the account hold in subsequent requests.'),
        originalAmount: z
            .number()
            .describe('The original amount of money to be held as a result of the authorization hold request.')
            .optional(),
        originalCurrency: z.string().describe('The original currency in which the hold was created.').optional(),
        partial: z.boolean().describe('Indicates whether the authorization is partial or not').optional(),
        referenceDateForExpiration: z
            .string()
            .datetime({ offset: true })
            .describe('The date to consider as start date when calculating the number of days passed until expiration')
            .optional(),
        source: z
            .enum(['CARD', 'ACCOUNT'])
            .describe('Indicates the source of the authorization hold, the default values is CARD.')
            .optional(),
        status: z.enum(['PENDING', 'REVERSED', 'SETTLED', 'EXPIRED']).describe('The authorization hold status.').optional(),
        userTransactionTime: z.string().describe('The formatted time at which the user made this authorization hold.').optional(),
    })
    .describe('The authorization hold corresponding to a card token')

export type AuthorizationHold = z.infer<typeof AuthorizationHold>

export const AuthorizationHoldAmountAdjustmentRequest = z
    .object({
        advice: z.boolean().describe('Whether the given request should be accepted without balance validations.').optional(),
        amount: z
            .number()
            .describe(
                'The amount of money to be subtracted/added to the authorization hold amount. For the decrease: if the amount is greater or equal to the authorization hold amount, then the authorization hold is reversed.',
            ),
        currencyCode: z.string().describe('The ISO currency code in which the hold was created.').optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID of the decrease/increase request (not of the authorization hold).')
            .optional(),
    })
    .describe('A request to decrease/increase the amount of an authorization hold.')

export type AuthorizationHoldAmountAdjustmentRequest = z.infer<typeof AuthorizationHoldAmountAdjustmentRequest>

export const CardTransactionInput = z
    .object({
        advice: z.boolean().describe('Whether the given request should be accepted without balance validations.'),
        amount: z.number().describe('The amount of money to be withdrawn in the financial transaction.'),
        cardAcceptor: CardAcceptor.optional(),
        cardToken: z.string().describe('The reference token of the card.').optional(),
        creditDebitIndicator: z
            .enum(['DBIT', 'CRDT'])
            .describe('If present, indicates that the card transaction is a refund, and whether is credited or debited')
            .optional(),
        currencyCode: z
            .string()
            .describe(
                'The ISO currency code in which the card reversal transaction is posted. The amounts are stored in the base currency, but the transaction can be created with a foreign currency.',
            )
            .optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        externalAuthorizationReferenceId: z
            .string()
            .describe(
                'The external authorization hold reference ID, which relates this card transaction to a previous authorization hold.',
            )
            .optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID to be used to reference the card transaction in subsequent requests.'),
        firstRepaymentDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the first repayment for the loan account (as Organization Time)')
            .optional(),
        increaseAmountIfNeeded: z.boolean().describe('Increase available amount if needed').optional(),
        partial: z.boolean().describe('Whether the given request should be a partial clearing or not.').optional(),
        transactionChannelId: z.string().describe('The ID of the channel through which the payment is done.'),
        userTransactionTime: z.string().describe('The formatted time at which the user made this card transaction.').optional(),
    })
    .describe('A card transaction entry which will have a corresponding a financial transaction performed.')

export type CardTransactionInput = z.infer<typeof CardTransactionInput>

export const CardTransactionOutput = z
    .object({
        advice: z.boolean().describe('Whether the given request should be accepted without balance validations.'),
        amount: z.number().describe('The amount of money to be withdrawn in the financial transaction.'),
        balances: AccountBalances.optional(),
        cardAcceptor: CardAcceptor.optional(),
        cardToken: z.string().describe('The reference token of the card.').optional(),
        creditDebitIndicator: z
            .enum(['DBIT', 'CRDT'])
            .describe('If present, indicates that the card transaction is a refund, and whether is credited or debited')
            .optional(),
        currencyCode: z
            .string()
            .describe(
                'The ISO currency code in which the card reversal transaction is posted. The amounts are stored in the base currency, but the transaction can be created with a foreign currency.',
            )
            .optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        externalAuthorizationReferenceId: z
            .string()
            .describe(
                'The external authorization hold reference ID, which relates this card transaction to a previous authorization hold.',
            )
            .optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID to be used to reference the card transaction in subsequent requests.'),
        firstRepaymentDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the first repayment for the loan account (as Organization Time)')
            .optional(),
        increaseAmountIfNeeded: z.boolean().describe('Increase available amount if needed').optional(),
        linkedTransaction: LinkedTransaction.optional(),
        partial: z.boolean().describe('Whether the given request should be a partial clearing or not.').optional(),
        transactionChannelId: z.string().describe('The ID of the channel through which the payment is done.'),
        userTransactionTime: z.string().describe('The formatted time at which the user made this card transaction.').optional(),
    })
    .describe('A card transaction output after a financial transaction was performed.')

export type CardTransactionOutput = z.infer<typeof CardTransactionOutput>

export const ErrorResponse = z.object({
    errors: RestError.array().optional(),
})

export type ErrorResponse = z.infer<typeof ErrorResponse>

export const GetAuthorizationHold = z
    .object({
        accountKey: z.string().describe('The key of the account linked with the authorization hold.').optional(),
        advice: z.boolean().describe('Whether the given request should be accepted without balance validations.'),
        amount: z.number().describe('The amount of money to be held as a result of the authorization hold request.'),
        balances: AccountBalances.optional(),
        cardAcceptor: CardAcceptor.optional(),
        cardToken: z.string().describe('The reference token of the card.').optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The organization time when the authorization hold was created')
            .optional(),
        creditDebitIndicator: z
            .enum(['DBIT', 'CRDT'])
            .describe(
                'Indicates whether the authorization hold amount is credited or debited.If not provided, the default values is DBIT.',
            )
            .optional(),
        currencyCode: z
            .string()
            .describe(
                'The ISO currency code in which the hold was created. The amounts are stored in the base currency, but the user could have enter it in a foreign currency.',
            )
            .optional(),
        customExpirationPeriod: z
            .number()
            .int()
            .describe('The custom expiration period for the hold which overwrites mcc and default expiration periods')
            .optional(),
        encodedKey: z.string().describe('The internal ID of the authorization hold, auto generated, unique.').optional(),
        exchangeRate: z.number().describe('The exchange rate for the original currency.').optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID to be used to reference the account hold in subsequent requests.'),
        originalAmount: z
            .number()
            .describe('The original amount of money to be held as a result of the authorization hold request.')
            .optional(),
        originalCurrency: z.string().describe('The original currency in which the hold was created.').optional(),
        partial: z.boolean().describe('Indicates whether the authorization is partial or not').optional(),
        referenceDateForExpiration: z
            .string()
            .datetime({ offset: true })
            .describe('The date to consider as start date when calculating the number of days passed until expiration')
            .optional(),
        source: z
            .enum(['CARD', 'ACCOUNT'])
            .describe('Indicates the source of the authorization hold, the default values is CARD.')
            .optional(),
        status: z.enum(['PENDING', 'REVERSED', 'SETTLED', 'EXPIRED']).describe('The authorization hold status.').optional(),
        userTransactionTime: z.string().describe('The formatted time at which the user made this authorization hold.').optional(),
    })
    .describe('Details for retrieving a authorization hold. Deprecated due to encodedKey field.')

export type GetAuthorizationHold = z.infer<typeof GetAuthorizationHold>

export const GetCardTransaction = z
    .object({
        accountBalances: DepositTransactionBalances.optional(),
        adjustmentTransactionKey: z
            .string()
            .describe(
                'The key of the deposit transaction where the adjustment for this transaction was made (if any adjustment was involved)',
            )
            .optional(),
        affectedAmounts: DepositAffectedAmounts.optional(),
        amount: z.number().describe('How much was added/removed in account').optional(),
        blockId: z.string().describe('The block fund id associated with the transaction').optional(),
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when corresponding JE is booked (as Organization Time)')
            .optional(),
        branchKey: z.string().describe('The branch where the transaction was performed').optional(),
        cardTransaction: CardTransaction.optional(),
        cardTransactionReversals: CardTransactionReversal.array()
            .describe('Object containing all the associated reversal transactions.')
            .optional(),
        centreKey: z.string().describe('The center where the transaction was performed').optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when this deposit transaction was created')
            .optional(),
        currencyCode: z.string().describe('The currency in which this transaction was posted').optional(),
        encodedKey: z.string().describe('The encoded key of the deposit transaction, auto generated, unique').optional(),
        externalId: z.string().describe('The external id of the deposit transaction, customizable, unique').optional(),
        fees: DepositFee.array()
            .describe('All the amounts that have been applied or paid within this transaction and involved predefined fees')
            .optional(),
        holdExternalReferenceId: z.string().describe('The external id of an account authorization hold').optional(),
        id: z.string().describe('The id of the deposit transaction, auto generated, unique').optional(),
        interestAccruedAmounts: DepositInterestAccruedAmounts.optional(),
        migrationEventKey: z
            .string()
            .describe(
                `The migration event encoded key associated with this deposit account. If this account was imported, track which 'migration event' they came from`,
            )
            .optional(),
        notes: z.string().describe('Extra notes about this deposit transaction').optional(),
        originalTransactionKey: z
            .string()
            .describe(
                'The encodedKey of the transaction that was adjusted as part of this one. Available only for adjustment transactions',
            )
            .optional(),
        parentAccountKey: z.string().describe('The key of the parent deposit account').optional(),
        paymentDetails: PaymentDetails.optional(),
        paymentOrderId: z.string().describe('The payment order id of the deposit transaction, customizable').optional(),
        taxes: DepositTaxes.optional(),
        terms: DepositTerms.optional(),
        tillKey: z.string().describe('The till key associated with this transaction').optional(),
        transactionDetails: TransactionDetails.optional(),
        transferDetails: TransferDetails.optional(),
        type: z
            .enum([
                'IMPORT',
                'WRITE_OFF',
                'WRITE_OFF_ADJUSTMENT',
                'DEPOSIT',
                'ADJUSTMENT',
                'WITHDRAWAL',
                'WITHDRAWAL_ADJUSTMENT',
                'CARD_TRANSACTION_REVERSAL',
                'CARD_TRANSACTION_REVERSAL_ADJUSTMENT',
                'TRANSFER',
                'TRANSFER_ADJUSTMENT',
                'FEE_APPLIED',
                'FEE_ADJUSTED',
                'FEES_DUE_REDUCED',
                'INTEREST_APPLIED',
                'INTEREST_APPLIED_ADJUSTMENT',
                'NET_DIFF_INTEREST',
                'FEE_REDUCTION_ADJUSTMENT',
                'WITHHOLDING_TAX',
                'WITHHOLDING_TAX_ADJUSTMENT',
                'INTEREST_RATE_CHANGED',
                'OVERDRAFT_INTEREST_RATE_CHANGED',
                'OVERDRAFT_LIMIT_CHANGED',
                'BRANCH_CHANGED',
                'ACCOUNT_HOLDER_CHANGED',
                'LOAN_FUNDED',
                'LOAN_FUNDED_ADJUSTMENT',
                'LOAN_REPAID',
                'LOAN_REPAID_ADJUSTMENT',
                'LOAN_FRACTION_BOUGHT',
                'LOAN_FRACTION_BOUGHT_ADJUSTMENT',
                'LOAN_FRACTION_SOLD',
                'LOAN_FRACTION_SOLD_ADJUSTMENT',
                'SEIZED_AMOUNT',
            ])
            .describe('The type of the deposit transaction')
            .optional(),
        userKey: z.string().describe('The person that performed the transaction').optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('Date of the entry (eg date of repayment or disbursal, etc.) (as Organization Time)')
            .optional(),
    })
    .describe('Details for retrieving a card financial transaction.')

export type GetCardTransaction = z.infer<typeof GetCardTransaction>

export const PatchAuthorizationHoldRequest = PatchOperation.array()

export type PatchAuthorizationHoldRequest = z.infer<typeof PatchAuthorizationHoldRequest>
