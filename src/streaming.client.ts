/**
 * Generated by @skyleague/therefore@v1.0.0-local
 * Do not manually touch this
 */
/* eslint-disable */
import got from 'got'
import type { CancelableRequest, Got, Options, Response } from 'got'
import type { ValidateFunction, ErrorObject } from 'ajv'
import { IncomingHttpHeaders } from 'http'
import {
    CreateSubscriptionCursorRequest,
    CreateSubscriptionCursorResponse200,
    DeleteSubscriptionBySubscriptionIdResponse404,
    GetSubscriptionStatsResponse,
    Problem,
    Subscription,
    SubscriptionEventStreamBatch,
} from './streaming.type'

export class StreamingClient {
    public client: Got

    public auth: {
        apiKeyAuth?: string | (() => Promise<string>)
    }

    public availableAuth: Set<string>
    public defaultAuth: string[][] | string[] | undefined

    public constructor({
        prefixUrl = 'http://MYTENANT.mambu.com/api/v1',
        options,
        auth = {},
        defaultAuth,
    }: {
        prefixUrl?: string | 'http://MYTENANT.mambu.com/api/v1'
        options?: Options
        auth: {
            apiKeyAuth?: string | (() => Promise<string>)
        }
        defaultAuth?: string[][] | string[]
    }) {
        this.client = got.extend(...[{ prefixUrl, throwHttpErrors: false }, options].filter((o): o is Options => o !== undefined))
        this.auth = auth
        this.availableAuth = new Set(Object.keys(auth))
        this.defaultAuth = defaultAuth
    }

    /**
     * Create a Subscription
     *
     * This endpoint creates a subscription for `event_types`. Event types must first be specified using the Mambu UI following the instructions in our [Event Streaming API](https://support.mambu.com/docs/streaming-api) article.
     *
     * - The subscription is needed to be able to consume events from `event_types` in a high level way when Mambu stores the offsets and manages the rebalancing of consuming clients.
     *
     * - The subscription is identified by its key parameters (`owning_application`, `event_types`, `consumer_group`).
     *
     * - If this endpoint is invoked several times with the same key subscription properties in body (order of even_types is not important) - the subscription will be created only once and for all other calls it will just return the subscription that was already created.
     */
    public async createSubscription({ body }: { body: Subscription }) {
        this.validateRequestBody(Subscription, body)

        return this.awaitResponse(
            this.buildClient().post(`subscriptions`, {
                json: body,
                responseType: 'json',
            }),
            {
                200: Subscription,
                201: Subscription,
                400: Problem,
                422: Problem,
            }
        )
    }

    /**
     * Start Event Stream
     *
     * This endpoint starts a new stream for reading events from this subscription. The data will be automatically rebalanced between streams of one subscription.
     *
     * - The minimal consumption unit is a partition, so it is possible to start as many streams as the total number of partitions in event-types of this subscription.
     * - The rebalance currently only operates with the number of partitions so the amount of data in event-- types/partitions is not considered during autorebalance.
     * - The position of the consumption is managed by Mambu. The client is required to commit the cursors it gets in a stream.
     *
     *
     * > <strong>Example Request</strong>
     * ```http
     * GET https://TENANT_NAME.mambu.com/api/v1/subscriptions/0691160a-b519-4595-b85c-a400fc73e96/events?stream_limit=10&stream_timeout=600 HTTP/1.1
     *
     * Accept: application/json
     * apikey: string
     * X-Flow-Id: string
     * ```
     * ### Client Rebalancing
     *
     * - If you need more than one client for your subscription to distribute load or increase throughput - you can read the subscription with multiple clients and Mambu will automatically balance the load across them.
     * - Currently, the maximum number of supported clients per subscription is equal to the number of event types in the subscription multiplied by `3`.
     * - For example if there are two event types in the subscription, the total number of clients for the subscription is `6`. The total of all the partitions within a subscription cannot be more than `100`. This gives a maximum of `33` event types per subscription.
     * - The API provides a guarantee of at-least-once delivery, this means that there are cases where duplicate events may be sent if there are errors committing events - a useful technique to detect and handle duplicates is to be idempotent and to check the `eid` field of event metadata.
     */
    public async getSubscriptionEvents({
        path,
        query,
    }: {
        path: { subscriptionId: string }
        query?: {
            max_uncommitted_events?: string
            batch_limit?: string
            stream_limit?: string
            batch_flush_timeout?: string
            stream_timeout?: string
            stream_keep_alive_limit?: string
            commit_timeout?: string
        }
    }) {
        return this.awaitResponse(
            this.buildClient().get(`subscriptions/${path.subscriptionId}/events`, {
                searchParams: query ?? {},
                responseType: 'json',
            }),
            {
                200: SubscriptionEventStreamBatch,
                400: Problem,
                403: Problem,
                404: Problem,
                409: Problem,
            }
        )
    }

    /**
     * Commit Cursors
     *
     * This endpoint commits offsets of the subscription.
     *
     * - If there is uncommited data, and no commits happen for 60 seconds, Mambu will consider the client to be gone, and will close the connection. As long as no events are sent, the client does not need to commit.
     *
     * - If the connection is closed, the client has 60 seconds to commit the events it received, from the moment they were sent. After that, the connection will be considered closed, and it will not be possible to do commit with that `X-Mambu-StreamId` anymore.
     *
     * - When a batch is committed, that also automatically commits all previous batches that were sent in a stream for this partition.
     */
    public async createSubscriptionCursor({
        path,
        body,
    }: {
        path: { subscriptionId: string }
        body: CreateSubscriptionCursorRequest
    }) {
        this.validateRequestBody(CreateSubscriptionCursorRequest, body)

        return this.awaitResponse(
            this.buildClient().post(`subscriptions/${path.subscriptionId}/cursors`, {
                json: body,
                responseType: 'json',
            }),
            {
                200: CreateSubscriptionCursorResponse200,
                403: Problem,
                404: Problem,
                422: Problem,
            }
        )
    }

    /**
     * Delete a Subscription
     *
     * This endpoint deletes an existing subscription for event types.
     * > <strong>Example Request</strong>
     * ```http
     * DELETE https://TENNT_NAME.MAMBU.COM/api/v1/subscriptions/0691160a-b519-4595-b85c-a400fc73e96 HTTP/1.1
     *
     * apikey: string
     * ```
     *
     * - In case the subscription is not needed anymore, it can be manually deleted by providing its unique subscription id.
     */
    public async deleteSubscriptionBySubscriptionId({ path }: { path: { subscriptionId: string } }) {
        return this.awaitResponse(
            this.buildClient().delete(`subscriptions/${path.subscriptionId}`, {
                responseType: 'json',
            }),
            {
                404: DeleteSubscriptionBySubscriptionIdResponse404,
            }
        )
    }

    /**
     * Get Statistics
     *
     * This endpoint exposes statistics of a specified subscription. An example use for the statistics provided could be monitoring lag in consumers.
     *
     *
     * > <strong>Example Request</strong>
     * ```http
     * GET https://TENANT_NAME.mambu.com/api/v1/subscriptions/0691160a-b519-4595-b85c-a400fc73e96/stats?show_time_lag=true HTTP/1.1
     *
     * Accept: application/json
     * apikey: string
     * ```
     *
     * The latest offset is compared with committed offset in order to calculate unconsumed events count for specific partition.
     */
    public async getSubscriptionStats({ path, query }: { path: { subscriptionId: string }; query?: { show_time_lag?: string } }) {
        return this.awaitResponse(
            this.buildClient().get(`subscriptions/${path.subscriptionId}/stats`, {
                searchParams: query ?? {},
                responseType: 'json',
            }),
            {
                200: GetSubscriptionStatsResponse,
                404: Problem,
            }
        )
    }

    public validateRequestBody<T>(schema: { is: (o: unknown) => o is T; assert: (o: unknown) => void }, body: T) {
        schema.assert(body)
        return body
    }

    public async awaitResponse<
        T,
        S extends Record<PropertyKey, undefined | { is: (o: unknown) => o is T; validate: ValidateFunction<T> }>
    >(response: CancelableRequest<Response<unknown>>, schemas: S) {
        type FilterStartingWith<S extends PropertyKey, T extends string> = S extends number | string
            ? `${S}` extends `${T}${infer _X}`
                ? S
                : never
            : never
        type InferSchemaType<T> = T extends { is: (o: unknown) => o is infer S; assert: (o: unknown) => void } ? S : never
        const result = await response
        const validator = schemas[result.statusCode]
        if (validator?.is(result.body) === false || result.statusCode < 200 || result.statusCode >= 300) {
            return {
                statusCode: result.statusCode,
                headers: result.headers,
                left: result.body,
                validationErrors: validator?.validate.errors ?? undefined,
            } as {
                statusCode: number
                headers: IncomingHttpHeaders
                left: InferSchemaType<S[keyof S]>
                validationErrors?: ErrorObject[]
            }
        }
        return { statusCode: result.statusCode, headers: result.headers, right: result.body } as {
            statusCode: number
            headers: IncomingHttpHeaders
            right: InferSchemaType<S[keyof Pick<S, FilterStartingWith<keyof S, '2'>>]>
        }
    }

    protected buildApiKeyAuthClient(client: Got) {
        return client.extend({
            hooks: {
                beforeRequest: [
                    async (options) => {
                        const apiKeyAuth = this.auth.apiKeyAuth
                        const key = typeof apiKeyAuth === 'function' ? await apiKeyAuth() : apiKeyAuth
                        options.headers['apikey'] = key
                    },
                ],
            },
        })
    }

    protected buildClient(auths: string[][] | string[] | undefined = this.defaultAuth, client: Got = this.client): Got {
        const auth = (auths ?? [])
            .map((auth) => (Array.isArray(auth) ? auth : [auth]))
            .filter((auth) => auth.every((a) => this.availableAuth.has(a)))
        for (const chosen of auth[0] ?? []) {
            if (chosen === 'apiKeyAuth') {
                client = this.buildApiKeyAuthClient(client)
            }
        }
        return client
    }
}
