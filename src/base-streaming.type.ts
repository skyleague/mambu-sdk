/**
 * Generated by @skyleague/therefore@v1.0.0-local
 * Do not manually touch this
 */
/* eslint-disable */

import type { DefinedError, ValidateFunction } from 'ajv'

import { validate as CommitSubscriptionCursorsRequestValidator } from './schemas/commit-subscription-cursors-request.schema.js'
import { validate as CommitSubscriptionCursorsResponse200Validator } from './schemas/commit-subscription-cursors-response200.schema.js'
import { validate as DeleteSubscriptionBySubscriptionIdResponse404Validator } from './schemas/delete-subscription-by-subscription-id-response404.schema.js'
import { validate as GetSubscriptionStatsResponseValidator } from './schemas/get-subscription-stats-response.schema.js'
import { validate as ProblemValidator } from './schemas/problem.schema.js'
import { validate as SubscriptionEventStreamBatchValidator } from './schemas/subscription-event-stream-batch.schema.js'
import { validate as SubscriptionValidator } from './schemas/subscription.schema.js'

export interface CommitSubscriptionCursorsRequest {
    /**
     * List of cursors that the consumer acknowledges to have successfully processed.
     */
    items: [Items, ...Items[]]
}

export const CommitSubscriptionCursorsRequest = {
    validate: CommitSubscriptionCursorsRequestValidator as ValidateFunction<CommitSubscriptionCursorsRequest>,
    get schema() {
        return CommitSubscriptionCursorsRequest.validate.schema
    },
    get errors() {
        return CommitSubscriptionCursorsRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is CommitSubscriptionCursorsRequest => CommitSubscriptionCursorsRequest.validate(o) === true,
    parse: (o: unknown): { right: CommitSubscriptionCursorsRequest } | { left: DefinedError[] } => {
        if (CommitSubscriptionCursorsRequest.is(o)) {
            return { right: o }
        }
        return { left: (CommitSubscriptionCursorsRequest.errors ?? []) as DefinedError[] }
    },
} as const

export interface CommitSubscriptionCursorsResponse200 {
    items: [CursorCommitResult, ...CursorCommitResult[]]
}

export const CommitSubscriptionCursorsResponse200 = {
    validate: CommitSubscriptionCursorsResponse200Validator as ValidateFunction<CommitSubscriptionCursorsResponse200>,
    get schema() {
        return CommitSubscriptionCursorsResponse200.validate.schema
    },
    get errors() {
        return CommitSubscriptionCursorsResponse200.validate.errors ?? undefined
    },
    is: (o: unknown): o is CommitSubscriptionCursorsResponse200 => CommitSubscriptionCursorsResponse200.validate(o) === true,
    parse: (o: unknown): { right: CommitSubscriptionCursorsResponse200 } | { left: DefinedError[] } => {
        if (CommitSubscriptionCursorsResponse200.is(o)) {
            return { right: o }
        }
        return { left: (CommitSubscriptionCursorsResponse200.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The result of single cursor commit. Holds a cursor itself and a result value.
 */
export interface CursorCommitResult {
    cursor: SubscriptionCursor
    /**
     * The result of cursor commit. - `committed`: cursor was successfully committed - `outdated`: there already was more recent (or the same) cursor committed, so the current one was not committed as it is outdated
     */
    result: string
}

export interface DeleteSubscriptionBySubscriptionIdResponse404 {
    /**
     * A human readable explanation specific to this occurrence of the problem.
     */
    detail: string
    /**
     * The HTTP status code generated by the origin server for this occurrence of the problem.
     */
    status: number
    /**
     * A short, summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).
     */
    title: string
}

export const DeleteSubscriptionBySubscriptionIdResponse404 = {
    validate:
        DeleteSubscriptionBySubscriptionIdResponse404Validator as ValidateFunction<DeleteSubscriptionBySubscriptionIdResponse404>,
    get schema() {
        return DeleteSubscriptionBySubscriptionIdResponse404.validate.schema
    },
    get errors() {
        return DeleteSubscriptionBySubscriptionIdResponse404.validate.errors ?? undefined
    },
    is: (o: unknown): o is DeleteSubscriptionBySubscriptionIdResponse404 =>
        DeleteSubscriptionBySubscriptionIdResponse404.validate(o) === true,
    parse: (o: unknown): { right: DeleteSubscriptionBySubscriptionIdResponse404 } | { left: DefinedError[] } => {
        if (DeleteSubscriptionBySubscriptionIdResponse404.is(o)) {
            return { right: o }
        }
        return { left: (DeleteSubscriptionBySubscriptionIdResponse404.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Payload of an Event. Usually represents a status transition in a Business process.
 */
export interface Event {
    body: string | {}
    metadata: EventMetadata
    /**
     * Name of the notification template.
     */
    template_name: string
}

/**
 * Metadata for this Event.
 */
export interface EventMetadata {
    /**
     * Indicates if the content of the notification can be configured in Mambu or it is fixed. Currently only one category is supported: `DATA`
     */
    category: string
    /**
     * Notification content format.
     */
    content_type: 'application/xml' | 'application/json' | 'text/plain; charset=UTF-8'
    /**
     * Unique identifier of this Event. Consumers MIGHT use this value to assert uniqueness of reception of the Event.
     */
    eid: string
    /**
     * The EventType of this Event.
     */
    event_type: string
    /**
     * Timestamp of creation of the Event generated by Mambu.
     */
    occurred_at: string
}

export interface GetSubscriptionStatsResponse {
    /**
     * Statistics list for specified subscription.
     */
    items: SubscriptionEventTypeStats[]
}

export const GetSubscriptionStatsResponse = {
    validate: GetSubscriptionStatsResponseValidator as ValidateFunction<GetSubscriptionStatsResponse>,
    get schema() {
        return GetSubscriptionStatsResponse.validate.schema
    },
    get errors() {
        return GetSubscriptionStatsResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetSubscriptionStatsResponse => GetSubscriptionStatsResponse.validate(o) === true,
    parse: (o: unknown): { right: GetSubscriptionStatsResponse } | { left: DefinedError[] } => {
        if (GetSubscriptionStatsResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetSubscriptionStatsResponse.errors ?? []) as DefinedError[] }
    },
} as const

interface Items {
    /**
     * An opaque value defined by the server.
     */
    cursor_token: string
    /**
     * The name of the event type this partition's events belong to.
     */
    event_type: string
    /**
     * Offset of the event being pointed to. Note that if you want to specify beginning position of a stream with first event at offset `N`, you should specify offset `N-1`.
     *
     * This applies in cases when you create new subscription or reset subscription offsets.
     *
     * Also for stream start offsets one can use two special values:
     *
     * - `begin` - read from the oldest available event.
     *
     * - `end` - read from the most recent offset.
     */
    offset: string
    /**
     * Id of the partition pointed to by this cursor.
     */
    partition: string
}

/**
 * Statistics of partition within a subscription context.
 */
export interface PartitionStats {
    /**
     * Subscription consumer lag for this partition in seconds. Measured as the age of the oldest event of this partition that is not yet consumed within this subscription.
     */
    consumer_lag_seconds?: number | undefined
    /**
     * The partition id.
     */
    partition: string
    /**
     * The state of this partition in current subscription. Currently following values are possible:
     *
     * `unassigned` - the partition is currently not assigned to any client.
     * `reassigning` - the partition is currently reassigning from one client to another.
     * `assigned` - the partition is assigned to a client.
     */
    state: 'assigned' | 'unassigned' | 'reassigning'
    /**
     * The id of the stream that consumes data from this partition.
     */
    stream_id: string
    /**
     * The amount of events in this partition that are not yet consumed within this subscription. The property may be absent at the moment when no events were yet consumed from the partition in this subscription (In case of read_from is `BEGIN` or `END`). If the event type uses ‘compact’ cleanup policy - then the actual number of unconsumed events can be lower than the one reported in this field.
     */
    unconsumed_events: number
}

export interface Problem {
    /**
     * A human readable explanation specific to this occurrence of the problem.
     */
    detail?: string | undefined
    /**
     * An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
     */
    instance?: string | undefined
    /**
     * The HTTP status code generated by the origin server for this occurrence of the problem.
     */
    status: number
    /**
     * A short, summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).
     */
    title: string
    /**
     * An absolute URI that identifies the problem type. When dereferenced, it SHOULD provide human-readable API documentation for the problem type (e.g., using HTML).
     */
    type: string
}

export const Problem = {
    validate: ProblemValidator as ValidateFunction<Problem>,
    get schema() {
        return Problem.validate.schema
    },
    get errors() {
        return Problem.validate.errors ?? undefined
    },
    is: (o: unknown): o is Problem => Problem.validate(o) === true,
    parse: (o: unknown): { right: Problem } | { left: DefinedError[] } => {
        if (Problem.is(o)) {
            return { right: o }
        }
        return { left: (Problem.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * This object contains general information about the stream. Used only for debugging purposes. We recommend logging this object in order to solve connection issues.
 *
 * Clients should not parse this structure.
 */
export interface StreamInfo {}

/**
 * Subscription is a high level consumption unit. Subscriptions allow applications to easily scale the number of clients by managing consumed event offsets and distributing load between instances. The key properties that identify a subscription are `owning_application`, `event_types` and `consumer_group`. It is not possible to have two different subscriptions with these properties being the same.
 */
export interface Subscription {
    /**
     * The value describing the use case of this subscription. In general that is an additional identifier used to differ subscriptions having the same `owning_application` and `event_types`.
     */
    consumer_group?: string | undefined
    /**
     * Timestamp of creation of the subscription. This is generated by Mambu. It should not be specified when creating subscription and sending it may result in a client error.
     */
    created_at?: string | undefined
    /**
     * EventTypes to subscribe to. The order is not important. Subscriptions that differ only by the order of EventTypes will be considered the same and will have the same id. The size of the `event_type`s list is limited by the total number of partitions within these event types. Default limit for partition count is `100`.
     */
    event_types: string[]
    /**
     * ID of subscription that was created. Is generated by Mambu, should not be specified when creating a subscription.
     */
    id?: string | undefined
    /**
     * List of cursors to start reading from. This property is required when `read_from` = cursors. The `initial` cursors should cover all partitions of subscription. Clients will get events starting from next offset positions.
     */
    initial_cursors?: SubscriptionCursorWithoutToken[] | undefined
    /**
     * The id of application owning the subscription.
     */
    owning_application: string
    /**
     * Position to start reading events from. Currently supported values: - `begin` - read from the oldest available event. - `end` - read from the most recent offset. - `cursors` - read from cursors provided in initial_cursors property. Applied when the client starts reading from a subscription.
     */
    read_from?: string | undefined
    /**
     * Timestamp of last update of the subscription. This is generated by Mambu. It should not be specified when creating subscription and sending it may result in a client error. Its initial value is same as `created_at`.
     */
    updated_at?: string | undefined
}

export const Subscription = {
    validate: SubscriptionValidator as ValidateFunction<Subscription>,
    get schema() {
        return Subscription.validate.schema
    },
    get errors() {
        return Subscription.validate.errors ?? undefined
    },
    is: (o: unknown): o is Subscription => Subscription.validate(o) === true,
    parse: (o: unknown): { right: Subscription } | { left: DefinedError[] } => {
        if (Subscription.is(o)) {
            return { right: o }
        }
        return { left: (Subscription.errors ?? []) as DefinedError[] }
    },
} as const

export interface SubscriptionCursor {
    /**
     * An opaque value defined by the server.
     */
    cursor_token: string
    /**
     * The name of the event type this partition's events belong to.
     */
    event_type: string
    /**
     * Offset of the event being pointed to. Note that if you want to specify beginning position of a stream with first event at offset `N`, you should specify offset `N-1`. This applies in cases when you create new subscription or reset subscription offsets. Also for stream start offsets one can use two special values: - `begin` - read from the oldest available event. - `end` - read from the most recent offset.
     */
    offset: string
    /**
     * Id of the partition pointed to by this cursor.
     */
    partition: string
}

export interface SubscriptionCursorWithoutToken {
    /**
     * The name of the event type this partition's events belong to.
     */
    event_type?: string | undefined
    /**
     * Offset of the event being pointed to. Note that if you want to specify beginning position of a stream with first event at offset `N`, you should specify offset `N-1`. This applies in cases when you create new subscription or reset subscription offsets. Also for stream start offsets one can use two special values: - `begin` - read from the oldest available event. - `end` - read from the most recent offset.
     */
    offset: string
    /**
     * Id of the partition pointed to by this cursor.
     */
    partition: string
}

/**
 * One chunk of events in a stream. A batch consists of an array of `event`s plus a `cursor` pointing to the offset of the last `event` in the stream.
 *
 * The size of the array of `event` is limited by the parameters used to initialize a Stream.
 *
 * Sequential batches might present repeated cursors if no new events have arrived.
 */
export interface SubscriptionEventStreamBatch {
    cursor: SubscriptionCursor
    /**
     * [Payload of an Event. Usually represents a status transition in a Business process.]
     */
    events?: [Event, ...Event[]] | undefined
    info?: StreamInfo | undefined
}

export const SubscriptionEventStreamBatch = {
    validate: SubscriptionEventStreamBatchValidator as ValidateFunction<SubscriptionEventStreamBatch>,
    get schema() {
        return SubscriptionEventStreamBatch.validate.schema
    },
    get errors() {
        return SubscriptionEventStreamBatch.validate.errors ?? undefined
    },
    is: (o: unknown): o is SubscriptionEventStreamBatch => SubscriptionEventStreamBatch.validate(o) === true,
    parse: (o: unknown): { right: SubscriptionEventStreamBatch } | { left: DefinedError[] } => {
        if (SubscriptionEventStreamBatch.is(o)) {
            return { right: o }
        }
        return { left: (SubscriptionEventStreamBatch.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * SubscriptionEventTypeStats
 *
 * Statistics of one event-type within a context of subscription.
 */
export interface SubscriptionEventTypeStats {
    /**
     * The name of the event type this partition's events belong to.
     */
    event_type: string
    /**
     * Statistics of partitions of this event-type.
     */
    partitions: PartitionStats[]
}
