/**
 * Generated by @skyleague/therefore@v1.0.0-local
 * Do not manually touch this
 */
/* eslint-disable */
import AjvValidator from 'ajv'
import type { ValidateFunction } from 'ajv'

/**
 * Subscription is a high level consumption unit. Subscriptions allow applications to easily scale the number of clients by managing consumed event offsets and distributing load between instances. The key properties that identify a subscription are `owning_application`, `event_types` and `consumer_group`. It is not possible to have two different subscriptions with these properties being the same.
 */
export interface Subscription {
    /**
     * ID of subscription that was created. Is generated by Mambu, should not be specified when creating a subscription.
     */
    id?: string
    /**
     * The id of application owning the subscription.
     */
    owning_application: string
    /**
     * EventTypes to subscribe to. The order is not important. Subscriptions that differ only by the order of EventTypes will be considered the same and will have the same id. The size of the `event_type`s list is limited by the total number of partitions within these event types. Default limit for partition count is `100`.
     */
    event_types: string[]
    /**
     * The value describing the use case of this subscription. In general that is an additional identifier used to differ subscriptions having the same `owning_application` and `event_types`.
     */
    consumer_group?: string
    /**
     * Timestamp of creation of the subscription. This is generated by Mambu. It should not be specified when creating subscription and sending it may result in a client error.
     */
    created_at?: string
    /**
     * Timestamp of last update of the subscription. This is generated by Mambu. It should not be specified when creating subscription and sending it may result in a client error. Its initial value is same as `created_at`.
     */
    updated_at?: string
    /**
     * Position to start reading events from. Currently supported values: - `begin` - read from the oldest available event. - `end` - read from the most recent offset. - `cursors` - read from cursors provided in initial_cursors property. Applied when the client starts reading from a subscription.
     */
    read_from?: string
    /**
     * List of cursors to start reading from. This property is required when `read_from` = cursors. The `initial` cursors should cover all partitions of subscription. Clients will get events starting from next offset positions.
     */
    initial_cursors?: SubscriptionCursorWithoutToken[]
}

export const Subscription = {
    validate: require('./schemas/subscription.schema.js') as ValidateFunction<Subscription>,
    get schema() {
        return Subscription.validate.schema
    },
    is: (o: unknown): o is Subscription => Subscription.validate(o) === true,
    assert: (o: unknown) => {
        if (!Subscription.validate(o)) {
            throw new AjvValidator.ValidationError(Subscription.validate.errors ?? [])
        }
    },
} as const

export interface Problem {
    /**
     * An absolute URI that identifies the problem type. When dereferenced, it SHOULD provide human-readable API documentation for the problem type (e.g., using HTML).
     */
    type: string
    /**
     * A short, summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).
     */
    title: string
    /**
     * The HTTP status code generated by the origin server for this occurrence of the problem.
     */
    status: number
    /**
     * A human readable explanation specific to this occurrence of the problem.
     */
    detail?: string
    /**
     * An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
     */
    instance?: string
}

export const Problem = {
    validate: require('./schemas/problem.schema.js') as ValidateFunction<Problem>,
    get schema() {
        return Problem.validate.schema
    },
    is: (o: unknown): o is Problem => Problem.validate(o) === true,
} as const

/**
 * One chunk of events in a stream. A batch consists of an array of `event`s plus a `cursor` pointing to the offset of the last `event` in the stream.
 *
 * The size of the array of `event` is limited by the parameters used to initialize a Stream.
 *
 * Sequential batches might present repeated cursors if no new events have arrived.
 */
export interface SubscriptionEventStreamBatch {
    cursor: SubscriptionCursor
    info?: StreamInfo
    /**
     * [Payload of an Event. Usually represents a status transition in a Business process.]
     */
    events?: [Event, ...Event[]]
}

export const SubscriptionEventStreamBatch = {
    validate: require('./schemas/subscription-event-stream-batch.schema.js') as ValidateFunction<SubscriptionEventStreamBatch>,
    get schema() {
        return SubscriptionEventStreamBatch.validate.schema
    },
    is: (o: unknown): o is SubscriptionEventStreamBatch => SubscriptionEventStreamBatch.validate(o) === true,
} as const

interface CommitSubscriptionCursorsRequestItemsArray {
    /**
     * Id of the partition pointed to by this cursor.
     */
    partition: string
    /**
     * Offset of the event being pointed to. Note that if you want to specify beginning position of a stream with first event at offset `N`, you should specify offset `N-1`.
     *
     * This applies in cases when you create new subscription or reset subscription offsets.
     *
     * Also for stream start offsets one can use two special values:
     *
     * - `begin` - read from the oldest available event.
     *
     * - `end` - read from the most recent offset.
     */
    offset: string
    /**
     * The name of the event type this partition's events belong to.
     */
    event_type: string
    /**
     * An opaque value defined by the server.
     */
    cursor_token: string
}

export interface CommitSubscriptionCursorsRequest {
    /**
     * List of cursors that the consumer acknowledges to have successfully processed.
     */
    items: [CommitSubscriptionCursorsRequestItemsArray, ...CommitSubscriptionCursorsRequestItemsArray[]]
}

export const CommitSubscriptionCursorsRequest = {
    validate:
        require('./schemas/commit-subscription-cursors-request.schema.js') as ValidateFunction<CommitSubscriptionCursorsRequest>,
    get schema() {
        return CommitSubscriptionCursorsRequest.validate.schema
    },
    is: (o: unknown): o is CommitSubscriptionCursorsRequest => CommitSubscriptionCursorsRequest.validate(o) === true,
    assert: (o: unknown) => {
        if (!CommitSubscriptionCursorsRequest.validate(o)) {
            throw new AjvValidator.ValidationError(CommitSubscriptionCursorsRequest.validate.errors ?? [])
        }
    },
} as const

export interface CommitSubscriptionCursorsResponse200 {
    items: [CursorCommitResult, ...CursorCommitResult[]]
}

export const CommitSubscriptionCursorsResponse200 = {
    validate:
        require('./schemas/commit-subscription-cursors-response200.schema.js') as ValidateFunction<CommitSubscriptionCursorsResponse200>,
    get schema() {
        return CommitSubscriptionCursorsResponse200.validate.schema
    },
    is: (o: unknown): o is CommitSubscriptionCursorsResponse200 => CommitSubscriptionCursorsResponse200.validate(o) === true,
} as const

export interface DeleteSubscriptionBySubscriptionIdResponse404 {
    /**
     * A short, summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).
     */
    title: string
    /**
     * The HTTP status code generated by the origin server for this occurrence of the problem.
     */
    status: number
    /**
     * A human readable explanation specific to this occurrence of the problem.
     */
    detail: string
}

export const DeleteSubscriptionBySubscriptionIdResponse404 = {
    validate:
        require('./schemas/delete-subscription-by-subscription-id-response404.schema.js') as ValidateFunction<DeleteSubscriptionBySubscriptionIdResponse404>,
    get schema() {
        return DeleteSubscriptionBySubscriptionIdResponse404.validate.schema
    },
    is: (o: unknown): o is DeleteSubscriptionBySubscriptionIdResponse404 =>
        DeleteSubscriptionBySubscriptionIdResponse404.validate(o) === true,
} as const

export interface GetSubscriptionStatsResponse {
    /**
     * Statistics list for specified subscription.
     */
    items: SubscriptionEventTypeStats[]
}

export const GetSubscriptionStatsResponse = {
    validate: require('./schemas/get-subscription-stats-response.schema.js') as ValidateFunction<GetSubscriptionStatsResponse>,
    get schema() {
        return GetSubscriptionStatsResponse.validate.schema
    },
    is: (o: unknown): o is GetSubscriptionStatsResponse => GetSubscriptionStatsResponse.validate(o) === true,
} as const

export interface SubscriptionCursorWithoutToken {
    /**
     * Id of the partition pointed to by this cursor.
     */
    partition: string
    /**
     * Offset of the event being pointed to. Note that if you want to specify beginning position of a stream with first event at offset `N`, you should specify offset `N-1`. This applies in cases when you create new subscription or reset subscription offsets. Also for stream start offsets one can use two special values: - `begin` - read from the oldest available event. - `end` - read from the most recent offset.
     */
    offset: string
    /**
     * The name of the event type this partition's events belong to.
     */
    event_type?: string
}

export interface SubscriptionCursor {
    /**
     * Id of the partition pointed to by this cursor.
     */
    partition: string
    /**
     * Offset of the event being pointed to. Note that if you want to specify beginning position of a stream with first event at offset `N`, you should specify offset `N-1`. This applies in cases when you create new subscription or reset subscription offsets. Also for stream start offsets one can use two special values: - `begin` - read from the oldest available event. - `end` - read from the most recent offset.
     */
    offset: string
    /**
     * The name of the event type this partition's events belong to.
     */
    event_type: string
    /**
     * An opaque value defined by the server.
     */
    cursor_token: string
}

/**
 * This object contains general information about the stream. Used only for debugging purposes. We recommend logging this object in order to solve connection issues.
 *
 * Clients should not parse this structure.
 */
export type StreamInfo = unknown

/**
 * Payload of an Event. Usually represents a status transition in a Business process.
 */
export interface Event {
    metadata: EventMetadata
    body: string | unknown
    /**
     * Name of the notification template.
     */
    template_name: string
}

/**
 * Metadata for this Event.
 */
export interface EventMetadata {
    /**
     * Unique identifier of this Event. Consumers MIGHT use this value to assert uniqueness of reception of the Event.
     */
    eid: string
    /**
     * The EventType of this Event.
     */
    event_type: string
    /**
     * Timestamp of creation of the Event generated by Mambu.
     */
    occurred_at: string
    /**
     * Notification content format.
     */
    content_type: 'application/xml' | 'application/json' | 'text/plain; charset=UTF-8'
    /**
     * Indicates if the content of the notification can be configured in Mambu or it is fixed. Currently only one category is supported: `DATA`
     */
    category: string
}

/**
 * The result of single cursor commit. Holds a cursor itself and a result value.
 */
export interface CursorCommitResult {
    cursor: SubscriptionCursor
    /**
     * The result of cursor commit. - `committed`: cursor was successfully committed - `outdated`: there already was more recent (or the same) cursor committed, so the current one was not committed as it is outdated
     */
    result: string
}

/**
 * SubscriptionEventTypeStats
 *
 * Statistics of one event-type within a context of subscription.
 */
export interface SubscriptionEventTypeStats {
    /**
     * The name of the event type this partition's events belong to.
     */
    event_type: string
    /**
     * Statistics of partitions of this event-type.
     */
    partitions: PartitionStats[]
}

/**
 * Statistics of partition within a subscription context.
 */
export interface PartitionStats {
    /**
     * The partition id.
     */
    partition: string
    /**
     * The state of this partition in current subscription. Currently following values are possible:
     *
     * `unassigned` - the partition is currently not assigned to any client.
     * `reassigning` - the partition is currently reassigning from one client to another.
     * `assigned` - the partition is assigned to a client.
     */
    state: 'assigned' | 'unassigned' | 'reassigning'
    /**
     * The amount of events in this partition that are not yet consumed within this subscription. The property may be absent at the moment when no events were yet consumed from the partition in this subscription (In case of read_from is `BEGIN` or `END`). If the event type uses ‘compact’ cleanup policy - then the actual number of unconsumed events can be lower than the one reported in this field.
     */
    unconsumed_events: number
    /**
     * Subscription consumer lag for this partition in seconds. Measured as the age of the oldest event of this partition that is not yet consumed within this subscription.
     */
    consumer_lag_seconds?: number
    /**
     * The id of the stream that consumes data from this partition.
     */
    stream_id: string
}
