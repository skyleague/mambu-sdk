/**
 * Generated by @skyleague/therefore
 * Do not manually touch this
 */
/* eslint-disable */

import { z } from 'zod'

export const SubscriptionCursor = z
    .object({
        cursor_token: z.string().nonempty().describe('An opaque value defined by the server.'),
        event_type: z.string().nonempty().describe(`The name of the event type this partition's events belong to.`),
        offset: z
            .string()
            .nonempty()
            .describe(
                'Offset of the event being pointed to. Note that if you want to specify beginning position of a stream with first event at offset `N`, you should specify offset `N-1`. This applies in cases when you create new subscription or reset subscription offsets. Also for stream start offsets one can use two special values: - `begin` - read from the oldest available event. - `end` - read from the most recent offset.',
            ),
        partition: z.string().nonempty().describe('Id of the partition pointed to by this cursor.'),
    })
    .describe('')

export type SubscriptionCursor = z.infer<typeof SubscriptionCursor>

export const PartitionStats = z
    .object({
        consumer_lag_seconds: z
            .number()
            .int()
            .describe(
                'Subscription consumer lag for this partition in seconds. Measured as the age of the oldest event of this partition that is not yet consumed within this subscription.',
            )
            .optional(),
        partition: z.string().nonempty().describe('The partition id.'),
        state: z
            .enum(['assigned', 'unassigned', 'reassigning'])
            .describe(
                'The state of this partition in current subscription. Currently following values are possible:\\n\\n`unassigned` - the partition is currently not assigned to any client.\\n`reassigning` - the partition is currently reassigning from one client to another.\\n`assigned` - the partition is assigned to a client.',
            ),
        stream_id: z.string().describe('The id of the stream that consumes data from this partition.'),
        unconsumed_events: z
            .number()
            .int()
            .describe(
                'The amount of events in this partition that are not yet consumed within this subscription. The property may be absent at the moment when no events were yet consumed from the partition in this subscription (In case of read_from is `BEGIN` or `END`). If the event type uses ‘compact’ cleanup policy - then the actual number of unconsumed events can be lower than the one reported in this field.',
            ),
    })
    .describe('Statistics of partition within a subscription context.')

export type PartitionStats = z.infer<typeof PartitionStats>

export const EventMetadata = z
    .object({
        category: z
            .string()
            .nonempty()
            .describe(
                'Indicates if the content of the notification can be configured in Mambu or it is fixed. Currently only one category is supported: `DATA`',
            ),
        content_type: z
            .enum(['application/xml', 'application/json', 'text/plain; charset=UTF-8'])
            .describe('Notification content format.'),
        eid: z
            .string()
            .nonempty()
            .uuid()
            .describe(
                'Unique identifier of this Event. Consumers MIGHT use this value to assert uniqueness of reception of the Event.',
            ),
        event_type: z.string().nonempty().describe('The EventType of this Event.'),
        occurred_at: z
            .string()
            .nonempty()
            .datetime({ offset: true })
            .describe('Timestamp of creation of the Event generated by Mambu.'),
    })
    .describe('Metadata for this Event.')

export type EventMetadata = z.infer<typeof EventMetadata>

export const CursorCommitResult = z
    .object({
        cursor: SubscriptionCursor,
        result: z
            .string()
            .nonempty()
            .describe(
                'The result of cursor commit. - `committed`: cursor was successfully committed - `outdated`: there already was more recent (or the same) cursor committed, so the current one was not committed as it is outdated',
            ),
    })
    .describe('The result of single cursor commit. Holds a cursor itself and a result value.')

export type CursorCommitResult = z.infer<typeof CursorCommitResult>

export const SubscriptionEventTypeStats = z
    .object({
        event_type: z.string().describe(`The name of the event type this partition's events belong to.`),
        partitions: PartitionStats.array().describe('Statistics of partitions of this event-type.'),
    })
    .describe('Statistics of one event-type within a context of subscription.')

export type SubscriptionEventTypeStats = z.infer<typeof SubscriptionEventTypeStats>

export const SubscriptionCursorWithoutToken = z
    .object({
        event_type: z.string().nonempty().describe(`The name of the event type this partition's events belong to.`).optional(),
        offset: z
            .string()
            .nonempty()
            .describe(
                'Offset of the event being pointed to. Note that if you want to specify beginning position of a stream with first event at offset `N`, you should specify offset `N-1`. This applies in cases when you create new subscription or reset subscription offsets. Also for stream start offsets one can use two special values: - `begin` - read from the oldest available event. - `end` - read from the most recent offset.',
            ),
        partition: z.string().nonempty().describe('Id of the partition pointed to by this cursor.'),
    })
    .describe('')

export type SubscriptionCursorWithoutToken = z.infer<typeof SubscriptionCursorWithoutToken>

export const StreamInfo = z
    .object({})
    .passthrough()
    .describe(
        'This object contains general information about the stream. Used only for debugging purposes. We recommend logging this object in order to solve connection issues. \\n\\nClients should not parse this structure.',
    )

export type StreamInfo = z.infer<typeof StreamInfo>

export const Event = z
    .object({
        body: z.union([z.string(), z.object({}).passthrough()]),
        metadata: EventMetadata,
        template_name: z.string().nonempty().describe('Name of the notification template.'),
    })
    .describe('Payload of an Event. Usually represents a status transition in a Business process.')

export type Event = z.infer<typeof Event>

export const CommitSubscriptionCursorsRequest = z
    .object({
        items: z
            .set(
                z
                    .object({
                        cursor_token: z.string().nonempty().describe('An opaque value defined by the server.'),
                        event_type: z
                            .string()
                            .nonempty()
                            .describe(`The name of the event type this partition's events belong to.`),
                        offset: z
                            .string()
                            .nonempty()
                            .describe(
                                'Offset of the event being pointed to. Note that if you want to specify beginning position of a stream with first event at offset `N`, you should specify offset `N-1`.\\n\\nThis applies in cases when you create new subscription or reset subscription offsets.\\n\\nAlso for stream start offsets one can use two special values:\\n\\n- `begin` - read from the oldest available event.\\n\\n- `end` - read from the most recent offset.',
                            ),
                        partition: z.string().nonempty().describe('Id of the partition pointed to by this cursor.'),
                    })
                    .describe(''),
            )
            .nonempty()
            .describe('List of cursors that the consumer acknowledges to have successfully processed.'),
    })
    .describe('')

export type CommitSubscriptionCursorsRequest = z.infer<typeof CommitSubscriptionCursorsRequest>

export const CommitSubscriptionCursorsResponse200 = z
    .object({
        items: z.set(CursorCommitResult).nonempty(),
    })
    .describe('')

export type CommitSubscriptionCursorsResponse200 = z.infer<typeof CommitSubscriptionCursorsResponse200>

export const DeleteSubscriptionBySubscriptionIdResponse404 = z
    .object({
        detail: z.string().nonempty().describe('A human readable explanation specific to this occurrence of the problem.'),
        status: z.number().describe('The HTTP status code generated by the origin server for this occurrence of the problem.'),
        title: z
            .string()
            .nonempty()
            .describe(
                'A short, summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).',
            ),
    })
    .describe('')

export type DeleteSubscriptionBySubscriptionIdResponse404 = z.infer<typeof DeleteSubscriptionBySubscriptionIdResponse404>

export const GetSubscriptionStatsResponse = z.object({
    items: SubscriptionEventTypeStats.array().describe('Statistics list for specified subscription.'),
})

export type GetSubscriptionStatsResponse = z.infer<typeof GetSubscriptionStatsResponse>

export const Problem = z
    .object({
        detail: z
            .string()
            .nonempty()
            .describe('A human readable explanation specific to this occurrence of the problem.')
            .optional(),
        instance: z
            .string()
            .nonempty()
            .url()
            .describe(
                'An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.',
            )
            .optional(),
        status: z
            .number()
            .int()
            .describe('The HTTP status code generated by the origin server for this occurrence of the problem.'),
        title: z
            .string()
            .nonempty()
            .describe(
                'A short, summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).',
            ),
        type: z
            .string()
            .nonempty()
            .url()
            .describe(
                'An absolute URI that identifies the problem type. When dereferenced, it SHOULD provide human-readable API documentation for the problem type (e.g., using HTML).',
            ),
    })
    .describe('')

export type Problem = z.infer<typeof Problem>

export const Subscription = z
    .object({
        consumer_group: z
            .string()
            .nonempty()
            .describe(
                'The value describing the use case of this subscription. In general that is an additional identifier used to differ subscriptions having the same `owning_application` and `event_types`.',
            )
            .optional(),
        created_at: z
            .string()
            .nonempty()
            .datetime({ offset: true })
            .describe(
                'Timestamp of creation of the subscription. This is generated by Mambu. It should not be specified when creating subscription and sending it may result in a client error.',
            )
            .optional(),
        event_types: z
            .string()
            .array()
            .describe(
                'EventTypes to subscribe to. The order is not important. Subscriptions that differ only by the order of EventTypes will be considered the same and will have the same id. The size of the `event_type`s list is limited by the total number of partitions within these event types. Default limit for partition count is `100`.',
            ),
        id: z
            .string()
            .nonempty()
            .describe(
                'ID of subscription that was created. Is generated by Mambu, should not be specified when creating a subscription.',
            )
            .optional(),
        initial_cursors: z
            .set(SubscriptionCursorWithoutToken)
            .describe(
                'List of cursors to start reading from. This property is required when `read_from` = cursors. The `initial` cursors should cover all partitions of subscription. Clients will get events starting from next offset positions.',
            )
            .optional(),
        owning_application: z.string().nonempty().describe('The id of application owning the subscription.'),
        read_from: z
            .string()
            .nonempty()
            .describe(
                'Position to start reading events from. Currently supported values: - `begin` - read from the oldest available event. - `end` - read from the most recent offset. - `cursors` - read from cursors provided in initial_cursors property. Applied when the client starts reading from a subscription.',
            )
            .optional(),
        updated_at: z
            .string()
            .nonempty()
            .datetime({ offset: true })
            .describe(
                'Timestamp of last update of the subscription. This is generated by Mambu. It should not be specified when creating subscription and sending it may result in a client error. Its initial value is same as `created_at`.',
            )
            .optional(),
    })
    .describe(
        'Subscription is a high level consumption unit. Subscriptions allow applications to easily scale the number of clients by managing consumed event offsets and distributing load between instances. The key properties that identify a subscription are `owning_application`, `event_types` and `consumer_group`. It is not possible to have two different subscriptions with these properties being the same.',
    )

export type Subscription = z.infer<typeof Subscription>

export const SubscriptionEventStreamBatch = z
    .object({
        cursor: SubscriptionCursor,
        events: Event.array()
            .nonempty()
            .describe('[Payload of an Event. Usually represents a status transition in a Business process.]')
            .optional(),
        info: StreamInfo.optional(),
    })
    .describe(
        'One chunk of events in a stream. A batch consists of an array of `event`s plus a `cursor` pointing to the offset of the last `event` in the stream.\\n\\nThe size of the array of `event` is limited by the parameters used to initialize a Stream.\\n\\nSequential batches might present repeated cursors if no new events have arrived.',
    )

export type SubscriptionEventStreamBatch = z.infer<typeof SubscriptionEventStreamBatch>
