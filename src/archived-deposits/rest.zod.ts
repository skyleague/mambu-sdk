/**
 * Generated by @skyleague/therefore
 * Do not manually touch this
 */
/* eslint-disable */

import { z } from 'zod'

export const CreditorReferenceInformation = z
    .object({
        reference: z.string().describe(`The reference information of the creditor's underlying documents`).optional(),
        referenceIssuer: z.string().describe('The entity that assigns the reference type').optional(),
        referenceType: z.string().describe('The type of creditor reference').optional(),
    })
    .describe('Represents the reference to the underlying documents of the payment.')

export type CreditorReferenceInformation = z.infer<typeof CreditorReferenceInformation>

export const OtherAccountIdentification = z
    .object({
        identification: z.string().describe('The identification of the payer/payee').optional(),
        scheme: z.string().describe('The identification scheme').optional(),
    })
    .describe('Represents other way of identification for the account.')

export type OtherAccountIdentification = z.infer<typeof OtherAccountIdentification>

export const Structured = z
    .object({
        creditorReferenceInformation: CreditorReferenceInformation.optional(),
    })
    .describe('The information specifying the payment items that are intended to settle')

export type Structured = z.infer<typeof Structured>

export const ServiceLevel = z
    .object({
        code: z.string().describe('The code for a pre-agreed service or level of service between the parties').optional(),
    })
    .describe('The rules under which the transaction should be processed')

export type ServiceLevel = z.infer<typeof ServiceLevel>

export const FinancialInstitutionIdentification = z
    .object({
        bic: z.string().describe('Business identifier code').optional(),
    })
    .describe('The identification of the financial institution')

export type FinancialInstitutionIdentification = z.infer<typeof FinancialInstitutionIdentification>

export const AccountIdentification = z
    .object({
        iban: z.string().describe('The account unique identifier').optional(),
        other: OtherAccountIdentification.optional(),
    })
    .describe('The account identification details')

export type AccountIdentification = z.infer<typeof AccountIdentification>

export const RemittanceInformation = z
    .object({
        structured: Structured.optional(),
        unstructured: z
            .string()
            .describe('Information supplied to match the items of the payment in an unstructured form')
            .optional(),
    })
    .describe('The information specifying the payment items that are intended to settle')

export type RemittanceInformation = z.infer<typeof RemittanceInformation>

export const PaymentTypeInformation = z
    .object({
        serviceLevel: ServiceLevel.optional(),
    })
    .describe('The information specifying the type of transaction')

export type PaymentTypeInformation = z.infer<typeof PaymentTypeInformation>

export const PaymentIdentification = z
    .object({
        endToEndIdentification: z.string().describe('Identifier assigned by the initiating party to the transaction').optional(),
        instructionIdentification: z.string().describe('Identifier of a payment instruction').optional(),
        transactionIdentification: z
            .string()
            .describe('Identifier unique for a period assigned by the first initiating party to the transaction')
            .optional(),
    })
    .describe('The payment identification details')

export type PaymentIdentification = z.infer<typeof PaymentIdentification>

export const Agent = z
    .object({
        financialInstitutionIdentification: FinancialInstitutionIdentification.optional(),
    })
    .describe('The agent details for a party')

export type Agent = z.infer<typeof Agent>

export const AccountDetails = z
    .object({
        currency: z.string().describe('The currency of the account').optional(),
        identification: AccountIdentification.optional(),
    })
    .describe('The account currency and identification')

export type AccountDetails = z.infer<typeof AccountDetails>

export const Party = z
    .object({
        name: z.string().describe('The name of the party').optional(),
    })
    .describe('The details of the party for a transaction')

export type Party = z.infer<typeof Party>

export const DepositAccountInterestRateTier = z
    .object({
        encodedKey: z.string().describe('The encoded key of the interest rate tier, auto generated, unique').optional(),
        endingBalance: z
            .number()
            .describe('The top-limit value for the account balance in order to determine if this tier is used or not')
            .optional(),
        endingDay: z
            .number()
            .int()
            .describe('The end date for the account period. Used to determine if this interest rate tier is used or not.')
            .optional(),
        interestRate: z
            .number()
            .describe(
                'The rate used for computing the interest for an account which has the balance less than the ending balance',
            ),
    })
    .describe('Represents information about how interest rate is calculated.')

export type DepositAccountInterestRateTier = z.infer<typeof DepositAccountInterestRateTier>

export const MonthAndDay = z
    .object({
        day: z.number().int().describe('The day in the month').optional(),
        month: z.number().int().describe('The month of the year').optional(),
    })
    .describe(`Wrapper for month and day for instances where the year isn't needed`)

export type MonthAndDay = z.infer<typeof MonthAndDay>

export const PaymentHolidaysSettings = z
    .object({
        paymentHolidaysLoanTermOption: z
            .enum(['EXTEND_LOAN_TERM', 'KEEP_THE_SAME_LOAN_TERM'])
            .describe('payment holiday option')
            .optional(),
    })
    .describe('Holds Payment Holidays Settings')

export type PaymentHolidaysSettings = z.infer<typeof PaymentHolidaysSettings>

export const DecimalConstraints = z
    .object({
        defaultValue: z
            .number()
            .describe('The default value, will be used in case no other value was filled in by the user.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the decimal constraint, auto generated, unique').optional(),
        maxValue: z.number().describe('The maximum value.').optional(),
        minValue: z.number().describe('The minimum value.').optional(),
    })
    .describe('Decimal constraints, like min/max/default.')

export type DecimalConstraints = z.infer<typeof DecimalConstraints>

export const AmountDecimalConstraints = z
    .object({
        defaultValue: z
            .number()
            .describe('The default value, will be used in case no other value was filled in by the user.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the decimal constraint, auto generated, unique').optional(),
        maxValue: z.number().describe('The maximum value.').optional(),
        minValue: z.number().describe('The minimum value.').optional(),
    })
    .describe('Decimal constraints, like min/max/default.')

export type AmountDecimalConstraints = z.infer<typeof AmountDecimalConstraints>

export const DecimalInterval = z
    .object({
        defaultValue: z
            .number()
            .describe('The default value, will be used in case no other value was filled in by the user.')
            .optional(),
        maxValue: z.number().describe('The maximum value.').optional(),
        minValue: z.number().describe('The minimum value.').optional(),
    })
    .describe('Decimal constraints, like min/max/default.')

export type DecimalInterval = z.infer<typeof DecimalInterval>

export const InterestRateTier = z
    .object({
        encodedKey: z.string().describe('The encoded key of the interest rate tier, auto generated, unique').optional(),
        endingBalance: z
            .number()
            .describe('The top-limit value for the account balance in order to determine if this tier is used or not')
            .optional(),
        interestRate: z
            .number()
            .describe(
                'The rate used for computing the interest for an account which has the balance less than the ending balance',
            ),
    })
    .describe('Used or TIERED interest rates, holds the values to define how the interest is computed')

export type InterestRateTier = z.infer<typeof InterestRateTier>

export const FeeTaxSettings = z
    .object({
        taxableCalculationMethod: z
            .enum(['DEFAULT', 'NON_TAXABLE', 'CUSTOM_TAX'])
            .describe(
                'Marks a specific fee as non-taxable (taxes are not calculated for it).Feature is in the Early Stage. To be enabled by request.',
            )
            .optional(),
    })
    .describe('Tax settings for a specific Predefined fee that overrides the tax settings of Loan Product')

export type FeeTaxSettings = z.infer<typeof FeeTaxSettings>

export const PeriodIntervalSettings = z
    .object({
        amortizationProfile: z
            .enum(['NONE', 'SUM_OF_YEARS_DIGITS', 'STRAIGHT_LINE', 'EFFECTIVE_INTEREST_RATE'])
            .describe('Type of amortization profile used for fee')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the period interval settings, auto generated, unique.').optional(),
        feeAmortizationUponRescheduleRefinanceOption: z
            .enum(['END_AMORTIZATION_ON_THE_ORIGINAL_ACCOUNT', 'CONTINUE_AMORTIZATION_ON_THE_RESCHEDULED_REFINANCED_ACCOUNT'])
            .describe('Flag for signaling if fee amortization should be continued or finished at account reschedule/refinance')
            .optional(),
        frequency: z
            .enum(['ACCOUNT_INSTALLMENTS_DUE_DATES', 'ACCOUNT_INSTALLMENTS_DUE_DATES_DAILY_BOOKING', 'CUSTOM_INTERVAL'])
            .describe('Frequency settings of the fee amortization')
            .optional(),
        intervalCount: z.number().int().describe('Total number of intervals').optional(),
        intervalType: z.enum(['PREDEFINED_INTERVALS', 'FULL_TERM']).describe('Defines the options for an interval').optional(),
        periodCount: z
            .number()
            .int()
            .describe('Period count used in conjunction with periodUnit to determine the next date of the interval')
            .optional(),
        periodUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS', 'YEARS'])
            .describe('Amortization unit to determine the interval between amortizations')
            .optional(),
    })
    .describe('The settings for defining period intervals.')

export type PeriodIntervalSettings = z.infer<typeof PeriodIntervalSettings>

export const GLAccountingRule = z
    .object({
        encodedKey: z.string().describe('The encoded key of the accounting rule, auto generated, unique.').optional(),
        financialResource: z
            .enum([
                'PORTFOLIO_CONTROL',
                'FUND_SOURCE',
                'WRITE_OFF_EXPENSE',
                'INTEREST_INCOME',
                'PAYMENT_HOLIDAY_INTEREST_INCOME',
                'TAXES_PAYABLE',
                'FEE_INCOME',
                'PENALTY_INCOME',
                'NEGATIVE_INTEREST_PAYABLE_RECEIVABLE',
                'NEGATIVE_INTEREST_PAYABLE',
                'INTEREST_RECEIVABLE',
                'PAYMENT_HOLIDAY_INTEREST_RECEIVABLE',
                'FEE_RECEIVABLE',
                'PENALTY_RECEIVABLE',
                'TAXES_RECEIVABLE',
                'DEFERRED_INTERESTS_INCOME',
                'DEFERRED_FEE_INCOME',
                'DEFERRED_TAXES',
                'DEPOSIT_REFERENCE',
                'SAVINGS_CONTROL',
                'INTEREST_EXPENSE',
                'INTEREST_PAYABLE',
                'NEGATIVE_INTEREST_INCOME',
                'NEGATIVE_INTEREST_RECEIVABLE',
                'OVERDRAFT_PORTFOLIO_CONTROL',
                'OVERDRAFT_INTEREST_INCOME',
                'OVERDRAFT_WRITE_OFF_EXPENSE',
                'OVERDRAFT_INTEREST_RECEIVABLE',
                'INTER_BRANCH_TRANSFER',
                'INTEREST_FROM_ARREARS_INCOME',
                'INTEREST_FROM_ARREARS_RECEIVABLE',
                'INTEREST_FROM_ARREARS_WRITE_OFF_EXPENSE',
                'PROFIT_EXPENSE',
                'PROFIT_PAYABLE',
            ])
            .describe(
                'General Ledger Financial Resources used to setup the product accounting rules and determine the credit and debit accounts when logging journal entries',
            ),
        glAccountKey: z.string().describe('The encoded key of the account that is mapped to the financialResource'),
        transactionChannelKey: z.string().describe('The key of the transaction rule that uses this rule').optional(),
    })
    .describe(
        'The GL accounting rule, it maps a financial resource with a GL account for a specific product (i.e loan or saving).',
    )

export type GLAccountingRule = z.infer<typeof GLAccountingRule>

export const DepositProductOverdraftInterestRateTier = z
    .object({
        encodedKey: z.string().describe('The encoded key of the interest rate tier, auto generated, unique').optional(),
        endingBalance: z
            .number()
            .describe('The top-limit value for the account balance in order to determine if this tier is used or not')
            .optional(),
        interestRate: z
            .number()
            .describe(
                'The rate used for computing the interest for an account which has the balance less than the ending balance',
            ),
    })
    .describe('Used for TIERED interest rates, holds the values to define how the interest is computed')

export type DepositProductOverdraftInterestRateTier = z.infer<typeof DepositProductOverdraftInterestRateTier>

export const DepositProductInterestRateTier = z
    .object({
        encodedKey: z.string().describe('The encoded key of the interest rate tier, auto generated, unique').optional(),
        endingBalance: z
            .number()
            .describe('The top-limit value for the account balance in order to determine if this tier is used or not')
            .optional(),
        endingDay: z
            .number()
            .int()
            .describe(
                'The top-limit value for the account period since activation in order to determine if this tier is used or not',
            )
            .optional(),
        interestRate: z
            .number()
            .describe(
                'The rate used for computing the interest for an account which has the balance less than the ending balance',
            ),
    })
    .describe('Used or TIERED interest rates, holds the values to define how the interest is computed')

export type DepositProductInterestRateTier = z.infer<typeof DepositProductInterestRateTier>

export const DepositGLAccountingRule = z
    .object({
        encodedKey: z.string().describe('The encoded key of the accounting rule, auto generated, unique.').optional(),
        financialResource: z
            .enum([
                'PORTFOLIO_CONTROL',
                'FUND_SOURCE',
                'WRITE_OFF_EXPENSE',
                'INTEREST_INCOME',
                'PAYMENT_HOLIDAY_INTEREST_INCOME',
                'TAXES_PAYABLE',
                'FEE_INCOME',
                'PENALTY_INCOME',
                'NEGATIVE_INTEREST_PAYABLE_RECEIVABLE',
                'NEGATIVE_INTEREST_PAYABLE',
                'INTEREST_RECEIVABLE',
                'PAYMENT_HOLIDAY_INTEREST_RECEIVABLE',
                'FEE_RECEIVABLE',
                'PENALTY_RECEIVABLE',
                'TAXES_RECEIVABLE',
                'DEFERRED_INTERESTS_INCOME',
                'DEFERRED_FEE_INCOME',
                'DEFERRED_TAXES',
                'DEPOSIT_REFERENCE',
                'SAVINGS_CONTROL',
                'INTEREST_EXPENSE',
                'INTEREST_PAYABLE',
                'NEGATIVE_INTEREST_INCOME',
                'NEGATIVE_INTEREST_RECEIVABLE',
                'OVERDRAFT_PORTFOLIO_CONTROL',
                'OVERDRAFT_INTEREST_INCOME',
                'OVERDRAFT_WRITE_OFF_EXPENSE',
                'OVERDRAFT_INTEREST_RECEIVABLE',
                'INTER_BRANCH_TRANSFER',
                'INTEREST_FROM_ARREARS_INCOME',
                'INTEREST_FROM_ARREARS_RECEIVABLE',
                'INTEREST_FROM_ARREARS_WRITE_OFF_EXPENSE',
                'PROFIT_EXPENSE',
                'PROFIT_PAYABLE',
            ])
            .describe(
                'General Ledger Financial Resources used to setup the product accounting rules and determine the credit and debit accounts when logging journal entries',
            ),
        glAccountKey: z.string().describe('The encoded key of the account that is mapped to the financialResource'),
    })
    .describe(
        'The GL accounting rule, it maps a financial resource with a GL account for a specific product (i.e loan or saving).',
    )

export type DepositGLAccountingRule = z.infer<typeof DepositGLAccountingRule>

export const Amount = z
    .object({
        due: z.number().describe('The due amount.').optional(),
        expected: z.number().describe('The expected amount, which is sum of paid and due amounts.').optional(),
        paid: z.number().describe('The paid amount.').optional(),
    })
    .describe('Represents a simple installment amount structure.')

export type Amount = z.infer<typeof Amount>

export const AmountWithReduced = z
    .object({
        due: z.number().describe('The due amount.').optional(),
        expected: z.number().describe('The expected amount, which is sum of paid and due amounts.').optional(),
        paid: z.number().describe('The paid amount.').optional(),
        reduced: z.number().describe('The reduced amount.').optional(),
    })
    .describe('Represents a simple installment amount structure.')

export type AmountWithReduced = z.infer<typeof AmountWithReduced>

export const FeeAmount = z
    .object({
        due: z.number().describe('The due amount.').optional(),
        expected: z.number().describe('The expected amount, which is sum of paid and due amounts.').optional(),
        expectedUnapplied: z
            .number()
            .describe(
                'The expected amount, which is the sum of unapplied fee and planned fee due amounts. This value is not always retrieved. It is retrieved when the loan schedule is requestedwith full details.',
            )
            .optional(),
        paid: z.number().describe('The paid amount.').optional(),
    })
    .describe('Represents a fee amount.')

export type FeeAmount = z.infer<typeof FeeAmount>

export const TransactionDetailsInput = z
    .object({
        transactionChannelId: z
            .string()
            .describe('The id of the transaction channel associated with the transaction details.')
            .optional(),
        transactionChannelKey: z
            .string()
            .describe('The encoded key of the transaction channel associated with the transaction details.')
            .optional(),
    })
    .describe('Contains the details about transaction including fields like transaction channel key and channel ID')

export type TransactionDetailsInput = z.infer<typeof TransactionDetailsInput>

export const PaymentDetails = z
    .object({
        creditor: Party.optional(),
        creditorAccount: AccountDetails.optional(),
        creditorAgent: Agent.optional(),
        debtor: Party.optional(),
        debtorAccount: AccountDetails.optional(),
        debtorAgent: Agent.optional(),
        paymentIdentification: PaymentIdentification.optional(),
        paymentTypeInformation: PaymentTypeInformation.optional(),
        remittanceInformation: RemittanceInformation.optional(),
    })
    .describe('The payment information including account identification details')

export type PaymentDetails = z.infer<typeof PaymentDetails>

export const Currency = z
    .object({
        code: z
            .enum([
                'AED',
                'AFN',
                'ALL',
                'AMD',
                'ANG',
                'AOA',
                'ARS',
                'AUD',
                'AWG',
                'AZN',
                'BAM',
                'BBD',
                'BDT',
                'BGN',
                'BHD',
                'BIF',
                'BMD',
                'BND',
                'BOB',
                'BOV',
                'BRL',
                'BSD',
                'BTN',
                'BWP',
                'BYR',
                'BYN',
                'BZD',
                'CAD',
                'CDF',
                'CHE',
                'CHF',
                'CHW',
                'CLF',
                'CLP',
                'CNY',
                'COP',
                'COU',
                'CRC',
                'CUC',
                'CUP',
                'CVE',
                'CZK',
                'DJF',
                'DKK',
                'DOP',
                'DZD',
                'EGP',
                'ERN',
                'ETB',
                'EUR',
                'FJD',
                'FKP',
                'GBP',
                'GEL',
                'GHS',
                'GIP',
                'GMD',
                'GNF',
                'GTQ',
                'GYD',
                'HKD',
                'HNL',
                'HRK',
                'HTG',
                'HUF',
                'IDR',
                'ILS',
                'INR',
                'IQD',
                'IRR',
                'ISK',
                'JMD',
                'JOD',
                'JPY',
                'KES',
                'KGS',
                'KHR',
                'KMF',
                'KPW',
                'KRW',
                'KWD',
                'KYD',
                'KZT',
                'LAK',
                'LBP',
                'LKR',
                'LRD',
                'LSL',
                'LTL',
                'LVL',
                'LYD',
                'MAD',
                'MDL',
                'MGA',
                'MKD',
                'MMK',
                'MNT',
                'MOP',
                'MRO',
                'MRU',
                'MUR',
                'MVR',
                'MWK',
                'MXN',
                'MXV',
                'MYR',
                'MZN',
                'NAD',
                'NGN',
                'NIO',
                'NOK',
                'NPR',
                'NZD',
                'OMR',
                'PAB',
                'PEN',
                'PGK',
                'PHP',
                'PKR',
                'PLN',
                'PYG',
                'QAR',
                'RON',
                'RSD',
                'RUB',
                'RWF',
                'SAR',
                'SBD',
                'SCR',
                'SDG',
                'SEK',
                'SGD',
                'SHP',
                'SLL',
                'SOS',
                'SRD',
                'STD',
                'STN',
                'SVC',
                'SYP',
                'SZL',
                'THB',
                'TJS',
                'TMT',
                'TND',
                'TOP',
                'TRY',
                'TTD',
                'TWD',
                'TZS',
                'UAH',
                'UGX',
                'USD',
                'USN',
                'UYI',
                'UYU',
                'UYW',
                'UZS',
                'VED',
                'VEF',
                'VES',
                'VND',
                'VUV',
                'WST',
                'XAG',
                'XAU',
                'XAF',
                'XBA',
                'XBB',
                'XBC',
                'XBD',
                'XCD',
                'XDR',
                'XOF',
                'XPD',
                'XPF',
                'XPT',
                'XSU',
                'XTS',
                'XUA',
                'XXX',
                'YER',
                'ZAR',
                'ZIG',
                'ZMK',
                'ZWL',
                'ZMW',
                'SSP',
                'NON_FIAT',
            ])
            .describe('Fiat(ISO-4217) currency code or NON_FIAT for non fiat currencies.')
            .optional(),
        currencyCode: z.string().describe('Currency code for NON_FIAT currency.').optional(),
    })
    .describe('Represents a currency eg. USD, EUR.')

export type Currency = z.infer<typeof Currency>

export const TransactionInterestSettings = z
    .object({
        indexInterestRate: z.number().describe('The value of the index interest rate').optional(),
        interestRate: z
            .number()
            .describe(
                'The interest rate. Represents the interest rate for the loan account. The interest on loans is accrued on a daily basis, which allows charging the clients only for the days they actually used the loan amount.',
            )
            .optional(),
    })
    .describe('The interest settings, holds all the properties regarding interests for the loan account.')

export type TransactionInterestSettings = z.infer<typeof TransactionInterestSettings>

export const CardAcceptor = z
    .object({
        city: z.string().describe('The city in which the card acceptor has the business.').optional(),
        country: z.string().describe('The country in which the card acceptor has the business.').optional(),
        mcc: z.number().int().describe('The Merchant Category Code of the card acceptor.').optional(),
        name: z.string().describe('The name of the card acceptor.').optional(),
        state: z.string().describe('The state in which the card acceptor has the business.').optional(),
        street: z.string().describe('The street in which the card acceptor has the business.').optional(),
        zip: z.string().describe('The ZIP code of the location in which the card acceptor has the business.').optional(),
    })
    .describe('The details of the card acceptor (merchant) in a transaction hold.')

export type CardAcceptor = z.infer<typeof CardAcceptor>

export const AccountingRate = z
    .object({
        encodedKey: z.string().describe('The encoded key of the accounting rate, auto generated, unique').optional(),
        endDate: z.string().datetime({ offset: true }).describe('Rate validity end date (as Organization Time)').optional(),
        fromCurrencyCode: z.string().describe('Organisation currency code').optional(),
        rate: z.number().describe('Value of rate to be used for accounting conversions').optional(),
        startDate: z.string().datetime({ offset: true }).describe('Rate validity start date (as Organization Time)').optional(),
        toCurrencyCode: z.string().describe('Foreign currency code').optional(),
    })
    .describe('Represents the conversion rate used in accounting to convert amounts from one currency to organisation currency')

export type AccountingRate = z.infer<typeof AccountingRate>

export const CustomPredefinedFee = z
    .object({
        amount: z.number().describe('The amount of the custom fee.').optional(),
        encodedKey: z.string().describe('The encoded key of the custom predefined fee, auto generated, unique.').optional(),
        percentage: z.number().describe('The percentage of the custom fee.').optional(),
        predefinedFeeEncodedKey: z.string().describe('The encoded key of the predefined fee').optional(),
    })
    .describe(
        'The custom predefined fees, they may be used as the expected predefined fees that will be applied on the disbursement.',
    )

export type CustomPredefinedFee = z.infer<typeof CustomPredefinedFee>

export const TrancheDisbursementDetails = z
    .object({
        disbursementTransactionKey: z
            .string()
            .describe(
                'The key of the disbursement transaction logged when this tranche was disbursed. This field will be null until the tranche disbursement',
            )
            .optional(),
        expectedDisbursementDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when this tranche is supposed to be disbursed (as Organization Time)')
            .optional(),
    })
    .describe('The disbursement details regarding a loan tranche.')

export type TrancheDisbursementDetails = z.infer<typeof TrancheDisbursementDetails>

export const RevolvingAccountSettings = z
    .object({
        numberOfPreviewedInstalments: z.number().int().describe('The number of previewed instalments').optional(),
    })
    .describe('The number of previewed instalments for an account')

export type RevolvingAccountSettings = z.infer<typeof RevolvingAccountSettings>

export const PeriodicPayment = z
    .object({
        amount: z.number().describe('The PMT value used in periodic payment'),
        encodedKey: z.string().describe('The encoded key of the periodic payment, auto generated, unique.').optional(),
        toInstallment: z.number().int().describe(`The installment's position up to which the PMT will be used`),
    })
    .describe(
        'For fixed term loans there is the possibility to define a payment plan. A payment plan consists of multiple periodic payments. This class holds information about a periodic payment.',
    )

export type PeriodicPayment = z.infer<typeof PeriodicPayment>

export const BillingCycleDays = z
    .object({
        days: z.number().int().array().describe('The billing cycle start days in case it is enabled').optional(),
    })
    .describe('Defines the billing cycles settings for a loan account')

export type BillingCycleDays = z.infer<typeof BillingCycleDays>

export const PMTAdjustmentThreshold = z
    .object({
        method: z
            .enum(['WORKING_DAYS', 'CALENDAR_DAYS'])
            .describe('The method used to calculate the PMT Adjustment threshold. Supported value is CALENDAR_DAYS')
            .optional(),
        numberOfDays: z.number().int().describe('The number of days that trigger a PMT Adjustment.').optional(),
    })
    .describe('Represents PMT Adjustment threshold settings for loan accounts and loan products.')

export type PMTAdjustmentThreshold = z.infer<typeof PMTAdjustmentThreshold>

export const DaysInMonth = z
    .object({
        daysInMonth: z
            .number()
            .int()
            .array()
            .describe(
                ' Specifies the day(s) of the month when the interest application dates should be. Only available if the Interest Application Method is InterestApplicationMethodDTO#FIXED_DAYS_OF_MONTH. Currently only 1 value can be specified.',
            )
            .optional(),
        shortMonthHandlingMethod: z
            .enum(['LAST_DAY_IN_MONTH', 'FIRST_DAY_OF_NEXT_MONTH'])
            .describe(
                'Determines how to handle the short months, if they select a fixed day of month > 28. Will be null if no such date is selected. Only available if the Interest Application Method is InterestApplicationMethodDTO#FIXED_DAYS_OF_MONTH.',
            )
            .optional(),
    })
    .describe('Enumeration for days of month and method of handling shorter months.')

export type DaysInMonth = z.infer<typeof DaysInMonth>

export const AccountInterestRateSettings = z
    .object({
        encodedKey: z.string().describe('The encoded key of the interest rate settings, auto generated, unique').optional(),
        indexSourceKey: z.string().describe('Index rate source key.').optional(),
        interestRate: z.number().describe('Interest rate value.').optional(),
        interestRateCeilingValue: z
            .number()
            .describe('Maximum value allowed for index based interest rate. Valid only for index interest rate.')
            .optional(),
        interestRateFloorValue: z
            .number()
            .describe('Minimum value allowed for index based interest rate. Valid only for index interest rate.')
            .optional(),
        interestRateReviewCount: z
            .number()
            .int()
            .describe('Interest rate review frequency unit count. Valid only for index interest rate.')
            .optional(),
        interestRateReviewUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS'])
            .describe('Interest rate review frequency measurement unit. Valid only for index interest rate.')
            .optional(),
        interestRateSource: z
            .enum(['FIXED_INTEREST_RATE', 'INDEX_INTEREST_RATE'])
            .describe('Interest calculation method: fixed or indexed(interest spread + active organization index interest rate)'),
        interestSpread: z.number().describe('Interest spread value.').optional(),
        validFrom: z.string().datetime({ offset: true }).describe('Date since an interest rate is valid'),
    })
    .describe('Adjustable interest rates settings for loan account')

export type AccountInterestRateSettings = z.infer<typeof AccountInterestRateSettings>

export const LoanTransactionDetails = z
    .object({
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        internalTransfer: z
            .boolean()
            .describe('Whether the transaction was transferred between loans or deposit accounts')
            .optional(),
        targetDepositAccountKey: z
            .string()
            .describe(
                'In case of a transaction to a deposit account this represent the deposit account key to which the transaction was made.',
            )
            .optional(),
        transactionChannelId: z
            .string()
            .describe('The ID of the transaction channel associated with the transaction details.')
            .optional(),
        transactionChannelKey: z
            .string()
            .describe('The encoded key of the transaction channel associated with the transaction details.')
            .optional(),
    })
    .describe('Represents the loan transaction details.')

export type LoanTransactionDetails = z.infer<typeof LoanTransactionDetails>

export const DepositAccountOverdraftInterestRateSettings = z
    .object({
        encodedKey: z
            .string()
            .describe('The encoded key for the set of interest settings, which is auto-generated and unique.')
            .optional(),
        interestChargeFrequency: z
            .enum(['ANNUALIZED', 'EVERY_MONTH', 'EVERY_FOUR_WEEKS', 'EVERY_WEEK', 'EVERY_DAY', 'EVERY_X_DAYS'])
            .describe('The interest charge frequency, which shows how often interest is charged on loan or deposit accounts.')
            .optional(),
        interestChargeFrequencyCount: z
            .number()
            .int()
            .describe('The number of times to apply interest in a time period.')
            .optional(),
        interestRate: z.number().describe('The interest rate for the deposit account.').optional(),
        interestRateReviewCount: z
            .number()
            .int()
            .describe('The number of times to review the interest rate in a time period.')
            .optional(),
        interestRateReviewUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS'])
            .describe('The time unit to use to determine the frequency of interest rate reviews.')
            .optional(),
        interestRateSource: z
            .enum(['FIXED_INTEREST_RATE', 'INDEX_INTEREST_RATE'])
            .describe('The interest calculation method used.')
            .optional(),
        interestRateTerms: z
            .enum(['FIXED', 'TIERED', 'TIERED_PERIOD', 'TIERED_BAND'])
            .describe('The terms for how interest rate is determined when accruing for an account.')
            .optional(),
        interestRateTiers: DepositAccountInterestRateTier.array()
            .describe('The list of interest rate tiers, which hold the values to define how interest is calculated.')
            .optional(),
        interestSpread: z
            .number()
            .describe('The index interest rate that is used to calculate the interest rate that is applied to accounts.')
            .optional(),
    })
    .describe('Represents information about overdraft interest rate settings for deposit accounts.')

export type DepositAccountOverdraftInterestRateSettings = z.infer<typeof DepositAccountOverdraftInterestRateSettings>

export const DepositAccountInterestRateSettings = z
    .object({
        encodedKey: z
            .string()
            .describe('The encoded key for the set of interest settings, which is auto-generated and unique.')
            .optional(),
        interestChargeFrequency: z
            .enum(['ANNUALIZED', 'EVERY_MONTH', 'EVERY_FOUR_WEEKS', 'EVERY_WEEK', 'EVERY_DAY', 'EVERY_X_DAYS'])
            .describe('The interest charge frequency, which shows how often interest is charged on loan or deposit accounts.')
            .optional(),
        interestChargeFrequencyCount: z
            .number()
            .int()
            .describe('The number of times to apply interest in a time period.')
            .optional(),
        interestRate: z.number().describe('The interest rate for the deposit account.').optional(),
        interestRateReviewCount: z
            .number()
            .int()
            .describe('The number of times to review the interest rate in a time period.')
            .optional(),
        interestRateReviewUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS'])
            .describe('The time unit to use to determine the frequency of interest rate reviews.')
            .optional(),
        interestRateSource: z
            .enum(['FIXED_INTEREST_RATE', 'INDEX_INTEREST_RATE'])
            .describe('The interest calculation method used.')
            .optional(),
        interestRateTerms: z
            .enum(['FIXED', 'TIERED', 'TIERED_PERIOD', 'TIERED_BAND'])
            .describe('The terms for how interest rate is determined when accruing for an account.')
            .optional(),
        interestRateTiers: DepositAccountInterestRateTier.array()
            .describe('The list of interest rate tiers, which hold the values to define how interest is calculated.')
            .optional(),
        interestSpread: z
            .number()
            .describe('The index interest rate that is used to calculate the interest rate that is applied to accounts.')
            .optional(),
    })
    .describe('Represents information about the interest rate settings for deposit accounts.')

export type DepositAccountInterestRateSettings = z.infer<typeof DepositAccountInterestRateSettings>

export const DepositAccountInterestPaymentSettings = z
    .object({
        interestPaymentDates: MonthAndDay.array()
            .describe('The list of all dates when the interest is paid into the deposit account.')
            .optional(),
        interestPaymentPoint: z
            .enum([
                'FIRST_DAY_OF_MONTH',
                'EVERY_WEEK',
                'EVERY_OTHER_WEEK',
                'EVERY_MONTH',
                'EVERY_3_MONTHS',
                'ON_FIXED_DATES',
                'DAILY',
                'ANNUALLY',
                'BI_ANNUALLY',
                'ON_ACCOUNT_MATURITY',
            ])
            .describe('The interest payment point, which specifies when the interest should be paid to the account.')
            .optional(),
    })
    .describe('Represents information about the interest payment settings.')

export type DepositAccountInterestPaymentSettings = z.infer<typeof DepositAccountInterestPaymentSettings>

export const DepositOverdraftSettings = z
    .object({
        overdraftLimit: z.number().describe('The overdraft limit that was set or changed in this transaction').optional(),
    })
    .describe('Holds the deposit overdraft settings for a transaction')

export type DepositOverdraftSettings = z.infer<typeof DepositOverdraftSettings>

export const DepositOverdraftInterestSettings = z
    .object({
        indexInterestRate: z
            .number()
            .describe('The value of the index interest rate set or changed in this transaction')
            .optional(),
        interestRate: z
            .number()
            .describe(
                'The interest rate that was set or changed in this transaction. Used on product interest rate changes or interest tier switches',
            )
            .optional(),
    })
    .describe('Holds the deposit overdraft interest settings')

export type DepositOverdraftInterestSettings = z.infer<typeof DepositOverdraftInterestSettings>

export const DepositTransactionInterestSettings = z
    .object({
        indexInterestRate: z
            .number()
            .describe('The value of the index interest rate set or changed in this transaction')
            .optional(),
        interestRate: z.number().describe('The interest rate for the deposit account').optional(),
    })
    .describe('The interest settings, holds all the properties regarding interests for the deposit account')

export type DepositTransactionInterestSettings = z.infer<typeof DepositTransactionInterestSettings>

export const GroupRole = z
    .object({
        encodedKey: z
            .string()
            .describe('The encoded key of the group role name, which is auto generated, and unique.')
            .optional(),
        groupRoleNameKey: z.string().describe('The group role name key.'),
        roleName: z.string().describe('The group role name.').optional(),
        roleNameId: z.string().describe('The group role name ID.').optional(),
    })
    .describe(
        'Represents a group role. A group role, or group role name, is the role of a group member within the group - for example, money collector. One member could have many roles within a group.',
    )

export type GroupRole = z.infer<typeof GroupRole>

export const RepaymentScheduleEditOptionDetails = z
    .object({
        paymentHolidaysSettings: PaymentHolidaysSettings.optional(),
    })
    .describe('Holds Repayments Schedule Editing options')

export type RepaymentScheduleEditOptionDetails = z.infer<typeof RepaymentScheduleEditOptionDetails>

export const RoundingSettings = z
    .object({
        repaymentCurrencyRounding: z
            .enum(['NO_ROUNDING', 'ROUND_TO_NEAREST_WHOLE_UNIT', 'ROUND_UP_TO_NEAREST_WHOLE_UNIT'])
            .describe('Specifies the repayment currency rounding method.'),
        repaymentElementsRoundingMethod: z
            .enum(['NO_ROUNDING', 'ROUND_ALL', 'PAYMENT_DUE'])
            .describe('Determines how the repayment currency rounding is handled on each element from the schedule.'),
        roundingRepaymentScheduleMethod: z
            .enum([
                'NO_ROUNDING',
                'ROUND_REMAINDER_INTO_LAST_REPAYMENT',
                'ROUND_PRINCIPAL_AND_INTEREST_REMAINDER_INTO_LAST_REPAYMENT',
            ])
            .describe('Specifies the rounding repayment schedule method.'),
    })
    .describe('Defines the rounding settings used in the loan computation.')

export type RoundingSettings = z.infer<typeof RoundingSettings>

export const PreviewScheduleSettings = z
    .object({
        numberOfPreviewedInstalments: z.number().int().describe('Number of Previewed Instalments.').optional(),
        previewScheduleEnabled: z.boolean().describe('Preview Schedule status.').optional(),
    })
    .describe('Defines the Preview Schedule settings for revolving products')

export type PreviewScheduleSettings = z.infer<typeof PreviewScheduleSettings>

export const IntegerIntervalConstraints = z
    .object({
        defaultValue: z
            .number()
            .int()
            .describe('The default value, will be used in case no other value was filled in by the user.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the integer constraint, auto generated, unique').optional(),
        maxValue: z.number().int().describe('The maximum value.').optional(),
        minValue: z.number().int().describe('The minimum value.').optional(),
    })
    .describe('Decimal integer, like min/max/default.')

export type IntegerIntervalConstraints = z.infer<typeof IntegerIntervalConstraints>

export const BillingCyclesProductSettings = z
    .object({
        enabled: z.boolean().describe('The billing cycle status if it is enabled or disabled').optional(),
        startDays: z.number().int().array().describe('The billing cycle start days in case it is enabled').optional(),
    })
    .describe('Defines the billing cycles settings for revolving credit products')

export type BillingCyclesProductSettings = z.infer<typeof BillingCyclesProductSettings>

export const ProductAmortizationPeriod = z
    .object({
        defaultValue: z.number().int().describe('default value').optional(),
        maxValue: z.number().int().describe('max value').optional(),
        minValue: z.number().int().describe('min value').optional(),
    })
    .describe(
        'It holds information about the loan product amortization period. The PMT is calculated as the loan would have [amortisationPeriod] instalments',
    )

export type ProductAmortizationPeriod = z.infer<typeof ProductAmortizationPeriod>

export const PrincipalPaymentProductSettings = z
    .object({
        amount: AmountDecimalConstraints.optional(),
        defaultPrincipalRepaymentInterval: z
            .number()
            .int()
            .describe('How many repayments the principal has to be paid')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the settings, auto generated, unique').optional(),
        includeFeesInFloorAmount: z
            .boolean()
            .describe(
                'If true, the fees will be included along with the principal in the repayment floor amount, for a revolving credit account',
            )
            .optional(),
        includeInterestInFloorAmount: z
            .boolean()
            .describe(
                'If true, the interest will be included along with the principal in the repayment floor amount, for a revolving credit account',
            )
            .optional(),
        percentage: DecimalConstraints.optional(),
        principalCeilingValue: z
            .number()
            .describe('The maximum principal due amount a repayment made with this settings can have')
            .optional(),
        principalFloorValue: z
            .number()
            .describe('The minimum principal due amount a repayment made with this settings can have')
            .optional(),
        principalPaymentMethod: z
            .enum([
                'FLAT',
                'OUTSTANDING_PRINCIPAL_PERCENTAGE',
                'PRINCIPAL_PERCENTAGE_LAST_DISB',
                'TOTAL_BALANCE_PERCENTAGE',
                'TOTAL_BALANCE_FLAT',
                'TOTAL_PRINCIPAL_PERCENTAGE',
            ])
            .describe('The method of principal payment for revolving credit')
            .optional(),
        totalDueAmountFloor: z
            .number()
            .describe('The minimum total due amount a repayment made with this settings can have')
            .optional(),
        totalDuePayment: z
            .enum([
                'FLAT',
                'OUTSTANDING_PRINCIPAL_PERCENTAGE',
                'PRINCIPAL_PERCENTAGE_LAST_DISB',
                'TOTAL_BALANCE_PERCENTAGE',
                'TOTAL_BALANCE_FLAT',
                'TOTAL_PRINCIPAL_PERCENTAGE',
            ])
            .describe('The method of total due payment for revolving credit')
            .optional(),
    })
    .describe('Defines the principal payment settings constraints for the loans that will be created based on this product.')

export type PrincipalPaymentProductSettings = z.infer<typeof PrincipalPaymentProductSettings>

export const ProductPrepaymentSettings = z
    .object({
        applyInterestOnPrepaymentMethod: z
            .enum(['AUTOMATIC', 'MANUAL'])
            .describe('Whether the interest on prepayment is applied manual or automatic.')
            .optional(),
        elementsRecalculationMethod: z
            .enum(['PRINCIPAL_EXPECTED_FIXED', 'TOTAL_EXPECTED_FIXED'])
            .describe(
                'The elements recalculation method, indicates how the declining balance with equal installments repayments are recalculated',
            )
            .optional(),
        ercFreeAllowance: z.number().describe('ERC free allowance in percentage').optional(),
        futurePaymentsAcceptance: z
            .enum(['NO_FUTURE_PAYMENTS', 'ACCEPT_FUTURE_PAYMENTS', 'ACCEPT_OVERPAYMENTS'])
            .describe(
                'Shows whether the future payments are allowed or not for this product (repayment transactions with entry date set in the future)',
            ),
        prepaymentAcceptance: z
            .enum(['ACCEPT_PREPAYMENTS', 'NO_PREPAYMENTS'])
            .describe('Shows whether the pre-payments are allowed or not for this product.')
            .optional(),
        prepaymentRecalculationMethod: z
            .enum([
                'NO_RECALCULATION',
                'RESCHEDULE_REMAINING_REPAYMENTS',
                'RECALCULATE_SCHEDULE_KEEP_SAME_NUMBER_OF_TERMS',
                'RECALCULATE_SCHEDULE_KEEP_SAME_PRINCIPAL_AMOUNT',
                'RECALCULATE_SCHEDULE_KEEP_SAME_TOTAL_REPAYMENT_AMOUNT',
                'REDUCE_AMOUNT_PER_INSTALLMENT',
                'REDUCE_NUMBER_OF_INSTALLMENTS',
                'REDUCE_NUMBER_OF_INSTALLMENTS_NEW',
            ])
            .describe('Prepayment recalculation method copied from the loan product on which this account is based')
            .optional(),
        principalPaidInstallmentStatus: z
            .enum(['PARTIALLY_PAID', 'PAID', 'ORIGINAL_TOTAL_EXPECTED_PAID'])
            .describe('Installment status for the case when principal is paid off (copied from loan product)')
            .optional(),
    })
    .describe('Defines the prepayment settings for the product')

export type ProductPrepaymentSettings = z.infer<typeof ProductPrepaymentSettings>

export const TrancheSettings = z
    .object({
        maxNumberOfTranches: z.number().int().describe('The number of tranches supported by the loan product').optional(),
    })
    .describe(
        'The tranche settings, indicates the settings regarding tranches in case the product is configured to support tranches.',
    )

export type TrancheSettings = z.infer<typeof TrancheSettings>

export const LockSettings = z
    .object({
        cappingConstraintType: z
            .enum(['SOFT_CAP', 'HARD_CAP'])
            .describe('Specifies constraint types for capping charges.')
            .optional(),
        cappingMethod: z
            .enum(['OUTSTANDING_PRINCIPAL_PERCENTAGE', 'ORIGINAL_PRINCIPAL_PERCENTAGE'])
            .describe('Specifies how principal will be used when calculating capping charges.')
            .optional(),
        cappingPercentage: z
            .number()
            .describe(
                'Specifies the percentage of principal that cannot be exceeded by the sum of interest, fees and penalty balances.',
            )
            .optional(),
        lockPeriodDays: z
            .number()
            .int()
            .describe('Specifies the number of days for in which the account will be locked if it stays in arrears.')
            .optional(),
    })
    .describe('Settings applied when transitioning accounts to Locked state')

export type LockSettings = z.infer<typeof LockSettings>

export const FourEyesPrinciple = z
    .object({
        activeForLoanApproval: z.boolean().describe('Requires separate users to create and approve loan accounts').optional(),
    })
    .describe('Settings for Four Eyes Principle')

export type FourEyesPrinciple = z.infer<typeof FourEyesPrinciple>

export const ProductInterestRateSettings = z
    .object({
        encodedKey: z.string().describe('The encoded key of the interest rate settings, auto generated, unique').optional(),
        indexSourceKey: z.string().describe('Index rate source key.').optional(),
        interestRate: DecimalInterval.optional(),
        interestRateCeilingValue: z
            .number()
            .describe('Maximum value allowed for index based interest rate. Valid only for index interest rate.')
            .optional(),
        interestRateFloorValue: z
            .number()
            .describe('Minimum value allowed for index based interest rate. Valid only for index interest rate.')
            .optional(),
        interestRateReviewCount: z
            .number()
            .int()
            .describe('Interest rate review frequency unit count. Valid only for index interest rate.')
            .optional(),
        interestRateReviewUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS'])
            .describe('Interest rate review frequency measurement unit. Valid only for index interest rate.')
            .optional(),
        interestRateSource: z
            .enum(['FIXED_INTEREST_RATE', 'INDEX_INTEREST_RATE'])
            .describe('Interest calculation method: fixed or indexed(interest spread + active organization index interest rate)'),
    })
    .describe('Adjustable interest rates settings')

export type ProductInterestRateSettings = z.infer<typeof ProductInterestRateSettings>

export const InterestProductSettings = z
    .object({
        accrueInterestAfterMaturity: z
            .boolean()
            .describe(
                'If the product supports this option, specify if the interest should be accrued after the account maturity date',
            )
            .optional(),
        allowNegativeInterestRate: z
            .boolean()
            .describe('Indicator whether the loan product allows negative values for interest rate or interest spread')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the interest rate tier, auto generated, unique').optional(),
        indexSourceKey: z.string().describe('Index rate source key.').optional(),
        interestChargeFrequency: z
            .enum(['ANNUALIZED', 'EVERY_MONTH', 'EVERY_FOUR_WEEKS', 'EVERY_WEEK', 'EVERY_DAY', 'EVERY_X_DAYS'])
            .describe('The interval used for determining how often is interest charged')
            .optional(),
        interestChargeFrequencyCount: z.number().int().describe('the count of units to apply over the interval').optional(),
        interestRate: DecimalInterval.optional(),
        interestRateCeilingValue: z
            .number()
            .describe(
                `Interest spread + index interest rate can't be more than this amount (valid only for index interest rate products).`,
            )
            .optional(),
        interestRateFloorValue: z
            .number()
            .describe(
                `Interest spread + index interest rate can't be less than this amount (valid only for index interest rate products).`,
            )
            .optional(),
        interestRateReviewCount: z.number().int().describe('Interest rate review frequency unit count').optional(),
        interestRateReviewUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS'])
            .describe('Interest rate review frequency measurement unit')
            .optional(),
        interestRateSource: z
            .enum(['FIXED_INTEREST_RATE', 'INDEX_INTEREST_RATE'])
            .describe('Interest calculation method: fixed or (interest spread + active organization index interest rate)')
            .optional(),
        interestRateTerms: z
            .enum(['FIXED', 'TIERED', 'TIERED_PERIOD', 'TIERED_BAND'])
            .describe('The option for how is the interest rate determined when being accrued for an account')
            .optional(),
        interestRateTiers: InterestRateTier.array()
            .describe('The list of interest rate tiers available for the current settings instance')
            .optional(),
    })
    .describe(
        'The interest settings, defines constraints regarding interest that will be used on the loan account created based on this product.',
    )

export type InterestProductSettings = z.infer<typeof InterestProductSettings>

export const PredefinedFee = z
    .object({
        accountingRules: GLAccountingRule.array()
            .describe('A list of accounting rules defined for this fee. If null, product default rules are selected.')
            .optional(),
        amortizationSettings: PeriodIntervalSettings.optional(),
        amount: z.number().describe('The amount of the fee').optional(),
        amountCalculationFunctionName: z.string().describe('Mambu Function name used for the fee calculation').optional(),
        amountCalculationMethod: z
            .enum([
                'FLAT',
                'LOAN_AMOUNT_PERCENTAGE',
                'REPAYMENT_PRINCIPAL_AMOUNT_PERCENTAGE',
                'LOAN_AMOUNT_PERCENTAGE_NUMBER_OF_INSTALLMENTS',
                'FLAT_NUMBER_OF_INSTALLMENTS',
                'IOF_PERCENTAGE_OF_DISBURSED_AMOUNT',
                'IOF_PERCENTAGE_OF_INSTALLMENT_PRINCIPAL',
                'IOF_PERCENTAGE_OF_LATE_INSTALLMENT_PRINCIPAL',
                'MAMBU_FUNCTION',
                'FEE_RATE_ON_OUTSTANDING_PRINCIPAL',
            ])
            .describe('The amount from which the fee is calculated using percentageAmount')
            .optional(),
        applyDateMethod: z
            .enum(['MONTHLY_FROM_ACTIVATION', 'FIRST_OF_EVERY_MONTH'])
            .describe('Shows when a fee should be applied; to be used with monthly deposit fees')
            .optional(),
        creationDate: z.string().datetime({ offset: true }).describe('Shows the creation date of the fee').optional(),
        defaultFeeRate: z.number().describe('The rate of the fee  applied to parentSource').optional(),
        encodedKey: z.string().describe('The encoded key of the predefined fee, auto generated, unique').optional(),
        feeApplication: z.enum(['REQUIRED', 'OPTIONAL']).describe('The type of fee application when disbursement is applied'),
        id: z.string().describe('The id of the fee').optional(),
        interestBearing: z.boolean().describe('Indication if the fee bears interest').optional(),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('Shows the last modified date of the fee').optional(),
        name: z.string().describe('The name of the fee').optional(),
        percentageAmount: z.number().describe('The amount of the fee in percents applied to percentSource').optional(),
        scheduleAllocationMethod: z
            .enum(['ON_INSTALLMENT', 'NO_ALLOCATION'])
            .describe('Method to allocate a fee to installments on the schedule')
            .optional(),
        state: z.enum(['ACTIVE', 'INACTIVE']).describe('Indicates the state of the fee'),
        taxSettings: FeeTaxSettings.optional(),
        trigger: z
            .enum([
                'MANUAL',
                'MANUAL_PLANNED',
                'DISBURSEMENT',
                'CAPITALIZED_DISBURSEMENT',
                'UPFRONT_DISBURSEMENT',
                'LATE_REPAYMENT',
                'PAYMENT_DUE',
                'PAYMENT_DUE_APPLIED_ON_DUE_DATES',
                'ARBITRARY',
                'IOF',
                'EARLY_REPAYMENT_CHARGE',
                'FEE_INCLUDED_IN_PMT',
            ])
            .describe('Shows the event that will trigger a fee'),
    })
    .describe('The response representation of the PredefinedFee. Represents a fee with a defined name and a fixed value.')

export type PredefinedFee = z.infer<typeof PredefinedFee>

export const BranchSettings = z
    .object({
        availableProductBranches: z
            .string()
            .array()
            .describe('Holds the encoded keys of the branches this product should be available for.')
            .optional(),
        forAllBranches: z.boolean().describe('Indicates if this product should be available for all branches').optional(),
    })
    .describe('Holds information about branch availability for the product.')

export type BranchSettings = z.infer<typeof BranchSettings>

export const UserManagedBranch = z
    .object({
        branchKey: z.string().describe('The encoded key of the branch, it is automatically generated.').optional(),
    })
    .describe('Represents a branch that can be managed by the user or API consumer.')

export type UserManagedBranch = z.infer<typeof UserManagedBranch>

export const TransactionChannelConstraint = z
    .object({
        criteria: z.enum(['AMOUNT', 'TYPE', 'PRODUCT']).describe('Defines the criteria on which the constraint is applied'),
        operator: z
            .enum(['EQUALS', 'EMPTY', 'NOT_EMPTY', 'MORE_THAN', 'LESS_THAN', 'BETWEEN', 'IN'])
            .describe(`Defines the constraint operator. Example: in 'Amount Equals 100' it is the 'Equals'`),
        secondValue: z
            .string()
            .describe(
                `The second filtering value of the filter parameter (constraint). It might not exist. Example: it represents '500' from 'Amount Between 100 and 500'`,
            )
            .optional(),
        value: z
            .string()
            .describe(
                `The first filtering value of the filter constraint. Example: it represents 'Disbursement' from 'Type equals Disbursement' and it also represents 100 from 'Amount Between 100 and 500'`,
            )
            .optional(),
        values: z
            .string()
            .array()
            .describe(
                'Filtering values used for the Product and Type criteria, where filtering might be applied on one or more values',
            )
            .optional(),
    })
    .describe('The constraints applied on the transaction channel')

export type TransactionChannelConstraint = z.infer<typeof TransactionChannelConstraint>

export const Document = z
    .object({
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The creation date of the document, stored as UTC')
            .optional(),
        encodedKey: z.string().describe('The document encodedKey').optional(),
        fileName: z.string().describe('The original file name of the document').optional(),
        fileSize: z.number().int().describe('The file size of the document').optional(),
        id: z.number().int().describe('The document id'),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last modified date of the document, stored as UTC')
            .optional(),
        location: z.string().describe('Location where the document can be found, eg /myfiles/mypicture.jpeg').optional(),
        name: z.string().describe('The name of the document'),
        notes: z.string().describe('Detailed notes about the document').optional(),
        ownerKey: z
            .string()
            .describe('Represents the holder of this document. If null, means nobody is the owner of this document')
            .optional(),
        ownerType: z
            .enum([
                'CLIENT',
                'GROUP',
                'LOAN_PRODUCT',
                'SAVINGS_PRODUCT',
                'CENTRE',
                'BRANCH',
                'USER',
                'LOAN_ACCOUNT',
                'DEPOSIT_ACCOUNT',
                'ID_DOCUMENT',
                'LINE_OF_CREDIT',
                'GL_JOURNAL_ENTRY',
            ])
            .describe('Determines the owner type of the document')
            .optional(),
        type: z.string().describe('The extension of the document'),
    })
    .describe('Holds information regarding the documents uploaded as attachments')

export type Document = z.infer<typeof Document>

export const DepositProductOverdraftInterestRateSettings = z
    .object({
        indexSourceKey: z.string().describe('Index rate source key.').optional(),
        interestChargeFrequency: z
            .enum(['ANNUALIZED', 'EVERY_MONTH', 'EVERY_FOUR_WEEKS', 'EVERY_WEEK', 'EVERY_DAY', 'EVERY_X_DAYS'])
            .describe('The interval used for determining how often is interest charged')
            .optional(),
        interestChargeFrequencyCount: z.number().int().describe('the count of units to apply over the interval').optional(),
        interestRate: DecimalInterval.optional(),
        interestRateReviewCount: z.number().int().describe('Interest rate review frequency unit count').optional(),
        interestRateReviewUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS'])
            .describe('Interest rate review frequency measurement unit')
            .optional(),
        interestRateSource: z
            .enum(['FIXED_INTEREST_RATE', 'INDEX_INTEREST_RATE'])
            .describe('Interest calculation method: fixed or (interest spread + active organization index interest rate)')
            .optional(),
        interestRateTerms: z
            .enum(['FIXED', 'TIERED', 'TIERED_PERIOD', 'TIERED_BAND'])
            .describe('The option for how is the interest rate determined when being accrued for an account')
            .optional(),
        interestRateTiers: DepositProductOverdraftInterestRateTier.array()
            .describe('The list of interest rate tiers available for the current settings instance')
            .optional(),
    })
    .describe(
        'The overdraft interest settings, defines constraints regarding interest that will be used on the account created based on this product.',
    )

export type DepositProductOverdraftInterestRateSettings = z.infer<typeof DepositProductOverdraftInterestRateSettings>

export const IntegerInterval = z
    .object({
        defaultValue: z
            .number()
            .int()
            .describe('The default value, will be used in case no other value was filled in by the user.')
            .optional(),
        maxValue: z.number().int().describe('The maximum value.').optional(),
        minValue: z.number().int().describe('The minimum value.').optional(),
    })
    .describe('Decimal integer, like min/max/default.')

export type IntegerInterval = z.infer<typeof IntegerInterval>

export const AmountDecimalInterval = z
    .object({
        defaultValue: z
            .number()
            .describe('The default value, will be used in case no other value was filled in by the user.')
            .optional(),
        maxValue: z.number().describe('The maximum value.').optional(),
        minValue: z.number().describe('The minimum value.').optional(),
    })
    .describe('Decimal constraints, like min/max/default.')

export type AmountDecimalInterval = z.infer<typeof AmountDecimalInterval>

export const DepositProductInterestRateSettings = z
    .object({
        accrueInterestAfterMaturity: z
            .boolean()
            .describe(
                'If the product supports this option, specify if the interest should be accrued after the account maturity date',
            )
            .optional(),
        allowNegativeInterestRate: z
            .boolean()
            .describe('Indicator whether the deposit product allows negative values for interest rate')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the interest rate tier, auto generated, unique').optional(),
        indexSourceKey: z.string().describe('Index rate source key.').optional(),
        interestChargeFrequency: z
            .enum(['ANNUALIZED', 'EVERY_MONTH', 'EVERY_FOUR_WEEKS', 'EVERY_WEEK', 'EVERY_DAY', 'EVERY_X_DAYS'])
            .describe('The interval used for determining how often is interest charged')
            .optional(),
        interestChargeFrequencyCount: z.number().int().describe('the count of units to apply over the interval').optional(),
        interestRate: DecimalInterval.optional(),
        interestRateReviewCount: z.number().int().describe('Interest rate review frequency unit count').optional(),
        interestRateReviewUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS'])
            .describe('Interest rate review frequency measurement unit')
            .optional(),
        interestRateSource: z
            .enum(['FIXED_INTEREST_RATE', 'INDEX_INTEREST_RATE'])
            .describe('Interest calculation method: fixed or (interest spread + active organization index interest rate)')
            .optional(),
        interestRateTerms: z
            .enum(['FIXED', 'TIERED', 'TIERED_PERIOD', 'TIERED_BAND'])
            .describe('The option for how is the interest rate determined when being accrued for an account')
            .optional(),
        interestRateTiers: DepositProductInterestRateTier.array()
            .describe('The list of interest rate tiers available for the current settings instance')
            .optional(),
    })
    .describe(
        'The interest settings, defines constraints regarding interest that will be used on the deposit created based on this product.',
    )

export type DepositProductInterestRateSettings = z.infer<typeof DepositProductInterestRateSettings>

export const InterestPaymentSettings = z
    .object({
        interestPaymentDates: MonthAndDay.array()
            .describe('List of all dates on which the interest is payed into deposit account')
            .optional(),
        interestPaymentPoint: z
            .enum([
                'FIRST_DAY_OF_MONTH',
                'EVERY_WEEK',
                'EVERY_OTHER_WEEK',
                'EVERY_MONTH',
                'EVERY_3_MONTHS',
                'ON_FIXED_DATES',
                'DAILY',
                'ANNUALLY',
                'BI_ANNUALLY',
                'ON_ACCOUNT_MATURITY',
            ])
            .describe('Specifies when the interest should be paid to the deposit account')
            .optional(),
    })
    .describe('Defines the interest payment settings for the deposit product and for deposits created based on this product')

export type InterestPaymentSettings = z.infer<typeof InterestPaymentSettings>

export const DepositProductPredefinedFee = z
    .object({
        accountingRules: DepositGLAccountingRule.array()
            .describe('A list of accounting rules defined for this fee. If null, product default rules are selected.')
            .optional(),
        amount: z.number().describe('The amount of the fee').optional(),
        amountCalculationFunctionName: z.string().describe('External function').optional(),
        amountCalculationMethod: z
            .enum(['FLAT', 'MAMBU_FUNCTION'])
            .describe('The amount from which the fee is calculated using percentageAmount')
            .optional(),
        applyDateMethod: z
            .enum(['MONTHLY_FROM_ACTIVATION', 'FIRST_OF_EVERY_MONTH'])
            .describe('Shows when a fee should be applied; to be used with monthly deposit fees')
            .optional(),
        creationDate: z.string().datetime({ offset: true }).describe('Shows the creation date of the fee').optional(),
        encodedKey: z.string().describe('The encoded key of the predefined fee, auto generated, unique').optional(),
        feeApplication: z.enum(['REQUIRED', 'OPTIONAL']).describe('The type of fee application when disbursement is applied'),
        id: z.string().describe('The id of the fee').optional(),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('Shows the last modified date of the fee').optional(),
        name: z.string().describe('The name of the fee').optional(),
        state: z.enum(['ACTIVE', 'INACTIVE']).describe('Indicates the state of the fee'),
        trigger: z.enum(['MANUAL', 'MONTHLY_FEE', 'ARBITRARY']).describe('Shows the event that will trigger a fee'),
    })
    .describe('The response representation of the PredefinedFee. Represents a fee with a defined name and a fixed value.')

export type DepositProductPredefinedFee = z.infer<typeof DepositProductPredefinedFee>

export const CustomFieldAvailableOption = z
    .object({
        score: z.number().describe('The score of the option.').optional(),
        selectionKey: z.string().describe('The system-generated ID of the option.').optional(),
        value: z.string().describe('The name of the option.').optional(),
    })
    .describe('Represents one option of a selection custom field definition.')

export type CustomFieldAvailableOption = z.infer<typeof CustomFieldAvailableOption>

export const InstallmentAllocationElementAmount = z
    .object({
        amount: Amount.optional(),
    })
    .describe('Represents an installment allocation element amount structure.')

export type InstallmentAllocationElementAmount = z.infer<typeof InstallmentAllocationElementAmount>

export const InstallmentAllocationElementTaxableAmount = z
    .object({
        amount: Amount.optional(),
        tax: Amount.optional(),
    })
    .describe('Represents an installment allocation element taxable amount structure.')

export type InstallmentAllocationElementTaxableAmount = z.infer<typeof InstallmentAllocationElementTaxableAmount>

export const InstallmentFeeDetails = z
    .object({
        amount: AmountWithReduced.optional(),
        encodedKey: z.string().describe('The encoded key of the predefined fee, auto generated, unique').optional(),
        id: z.string().describe('The id of the fee, provided by the client').optional(),
        name: z.string().describe('The name of the fee').optional(),
        tax: AmountWithReduced.optional(),
    })
    .describe('Represents fee details for an installment.')

export type InstallmentFeeDetails = z.infer<typeof InstallmentFeeDetails>

export const InstallmentFee = z
    .object({
        amount: FeeAmount.optional(),
        tax: Amount.optional(),
    })
    .describe('Represents an installment fee structure.')

export type InstallmentFee = z.infer<typeof InstallmentFee>

export const CustomSettingDetails = z
    .object({
        loanTransactionKey: z.string().describe('The loan transaction associated with the custom setting.').optional(),
        source: z.string().describe('The source of the custom setting').optional(),
        type: z.string().describe('The type of custom setting.').optional(),
    })
    .describe('Represents the custom settings for a loan schedule.')

export type CustomSettingDetails = z.infer<typeof CustomSettingDetails>

export const CarryForwardInterestSplit = z
    .object({
        amount: z.number().describe('The carry forward interest amount.').optional(),
        tax: z.number().describe('The taxes amount on the carry forward interest.').optional(),
    })
    .describe('Represents carry forward interest split')

export type CarryForwardInterestSplit = z.infer<typeof CarryForwardInterestSplit>

export const WithdrawalDepositTransactionInput = z
    .object({
        amount: z.number().describe('The amount to withdraw from account'),
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                'The date of the withdrawal when the transaction is logged into accounting. If not specified it is considered the value date',
            )
            .optional(),
        externalId: z.string().describe('The external id of the withdrawal transaction, customizable, unique').optional(),
        holdExternalReferenceId: z.string().describe('The external id of an account authorization hold').optional(),
        notes: z.string().describe('Extra notes about this deposit transaction').optional(),
        paymentDetails: PaymentDetails.optional(),
        paymentOrderId: z.string().describe('The payment order id of the withdrawal transaction, customizable').optional(),
        transactionDetails: TransactionDetailsInput.optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                'The entry date of the withdrawal. If not specified it is considered the current date (as Organization Time)',
            )
            .optional(),
    })
    .passthrough()
    .describe('Represents the input for a withdrawal transaction.')

export type WithdrawalDepositTransactionInput = z.infer<typeof WithdrawalDepositTransactionInput>

export const FeeAppliedDepositTransactionInput = z
    .object({
        amount: z.number().describe('The value of the fee applied on the account').optional(),
        externalId: z.string().describe('The external id of the current transaction, customizable, unique').optional(),
        notes: z.string().describe('Extra notes about the current transaction').optional(),
        predefinedFeeKey: z.string().describe('The encodedKey of the predefined fee that defines the current fee').optional(),
    })
    .describe('Represents the request payload for creating a transaction of type FEE_APPLIED.')

export type FeeAppliedDepositTransactionInput = z.infer<typeof FeeAppliedDepositTransactionInput>

export const DepositTransactionInput = z
    .object({
        amount: z.number().describe('The amount that was added to an account'),
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of Journal Entry (as Organization Time)')
            .optional(),
        externalId: z.string().describe('The external id of the deposit transaction, customizable, unique').optional(),
        holdExternalReferenceId: z.string().describe('The external id of an account authorization hold').optional(),
        notes: z.string().describe('Extra notes about this deposit transaction').optional(),
        paymentDetails: PaymentDetails.optional(),
        paymentOrderId: z.string().describe('The payment order id of the deposit transaction, customizable').optional(),
        skipMaximumBalanceValidation: z
            .boolean()
            .describe('Flag indicating that a maximum balance validation should be skipped')
            .optional(),
        transactionDetails: TransactionDetailsInput.optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The entry date of the deposit (as Organization Time)')
            .optional(),
    })
    .describe('Represents the request payload for creating a transaction of type DEPOSIT.')

export type DepositTransactionInput = z.infer<typeof DepositTransactionInput>

export const GLAccount = z
    .object({
        activated: z.boolean().describe('`TRUE` if the account is activated and may be used, `FALSE` otherwise.').optional(),
        allowManualJournalEntries: z
            .boolean()
            .describe('`TRUE` if manual journal entries are allowed, `FALSE` otherwise.')
            .optional(),
        balance: z
            .number()
            .describe('The balance of the general ledger account, which is only populated for the GET /glaccounts endpoint.')
            .optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The creation date for this account, which is stored as UTC.')
            .optional(),
        currency: Currency.optional(),
        description: z.string().describe('A description of the general ledger account.').optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        glCode: z
            .string()
            .describe(
                `The general ledger code used to identify different account types. Also used for grouping and categorizing accounts. For example: an account code of '3201' is considered a subtype of '3200'.`,
            )
            .optional(),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last modification date and time, which is stored as UTC.')
            .optional(),
        migrationEventKey: z
            .string()
            .describe(
                'The data migration event key if the general ledger account was created as a part of a data migration event.',
            )
            .optional(),
        name: z.string().describe('The name of the general ledger account.').optional(),
        stripTrailingZeros: z.boolean().describe('`TRUE` if trailing zeros are stripped, `FALSE` otherwise.').optional(),
        type: z
            .enum(['ASSET', 'LIABILITY', 'EQUITY', 'INCOME', 'EXPENSE'])
            .describe('The general ledger account type.')
            .optional(),
        usage: z
            .enum(['DETAIL', 'HEADER'])
            .describe(
                'The usage type of the general ledger account. `DETAIL` accounts are used to stores transaction balances. `HEADER` accounts are used to organise and group detail accounts for reporting purposes.',
            )
            .optional(),
    })
    .describe('Represents a general ledger account.')

export type GLAccount = z.infer<typeof GLAccount>

export const AccountingReportAmounts = z
    .object({
        closingBalance: z.number().describe('The closing balance amount of the general ledger account.').optional(),
        credits: z.number().describe('The credit amount of the general ledger account.').optional(),
        debits: z.number().describe('The debit amount of the general ledger account.').optional(),
        netChange: z.number().describe('The net change amount of the general ledger account.').optional(),
        openingBalance: z.number().describe('The opening balance amount of the general ledger account.').optional(),
    })
    .describe('Represents information about the accounting report amounts.')

export type AccountingReportAmounts = z.infer<typeof AccountingReportAmounts>

export const TransferDetails = z
    .object({
        linkedDepositTransactionKey: z.string().describe('The key of the related deposit transaction').optional(),
        linkedLoanTransactionKey: z.string().describe('The key of the related loan transaction').optional(),
    })
    .describe('Represents the transfer details, such as the linked transaction key')

export type TransferDetails = z.infer<typeof TransferDetails>

export const TransactionDetails = z
    .object({
        transactionChannelId: z
            .string()
            .describe('The id of the transaction channel associated with the transaction details.')
            .optional(),
        transactionChannelKey: z
            .string()
            .describe('The encoded key of the transaction channel associated with the transaction details.')
            .optional(),
    })
    .describe('Contains the details about transaction including fields like transaction channel key and channel id')

export type TransactionDetails = z.infer<typeof TransactionDetails>

export const LoanTerms = z
    .object({
        interestSettings: TransactionInterestSettings.optional(),
        periodicPayment: z
            .number()
            .describe('The periodic payment value logged when changing it for a Balloon Payments account')
            .optional(),
        principalPaymentAmount: z
            .number()
            .describe('The principal payment flat amount logged when changing it for a Revolving Credit account')
            .optional(),
        principalPaymentPercentage: z
            .number()
            .describe('The principal payment percentage value logged when changing it for a Revolving Credit account')
            .optional(),
    })
    .describe('The loan transaction terms')

export type LoanTerms = z.infer<typeof LoanTerms>

export const Taxes = z
    .object({
        deferredTaxOnInterestAmount: z
            .number()
            .describe(
                'How much taxes on the interest that was pre-paid were added/removed in account, within this transaction. If there is any deferred tax on interest amount set in this transaction, that amount should be included in this field.',
            )
            .optional(),
        taxOnFeesAmount: z
            .number()
            .describe(
                'How much taxes on the fees that were paid in this transaction were added/removed in account, within this transaction.',
            )
            .optional(),
        taxOnInterestAmount: z
            .number()
            .describe(
                'How much taxes on the interest that was paid in this transaction were added/removed in account, within this transaction.',
            )
            .optional(),
        taxOnInterestFromArrearsAmount: z
            .number()
            .describe(
                'The amount of taxes on the interest from arrears that were applied/paid in account, within this transaction.',
            )
            .optional(),
        taxOnPaymentHolidaysInterest: z
            .number()
            .describe(
                'The amount of taxes on the Payment Holidays interest that were added/removed in account, within this transaction.',
            )
            .optional(),
        taxOnPenaltyAmount: z
            .number()
            .describe(
                'How much taxes on the penalties that were paid in this transaction were added/removed in account, within this transaction.',
            )
            .optional(),
        taxRate: z.number().describe('The tax rate that was set or changed in this transaction.').optional(),
    })
    .describe('The taxes applied within a transaction.')

export type Taxes = z.infer<typeof Taxes>

export const Fee = z
    .object({
        amount: z
            .number()
            .describe('The amount of the fee that was applied/paid in the transaction for the given predefined fee.')
            .optional(),
        name: z.string().describe('The name of the predefined fee').optional(),
        predefinedFeeKey: z.string().describe('The encoded key of the predefined fee, auto generated, unique'),
        taxAmount: z.number().describe('The amount of the taxes on fee that was applied/paid in the transaction.').optional(),
        trigger: z
            .enum([
                'MANUAL',
                'MANUAL_PLANNED',
                'DISBURSEMENT',
                'CAPITALIZED_DISBURSEMENT',
                'UPFRONT_DISBURSEMENT',
                'LATE_REPAYMENT',
                'PAYMENT_DUE',
                'PAYMENT_DUE_APPLIED_ON_DUE_DATES',
                'ARBITRARY',
                'IOF',
                'EARLY_REPAYMENT_CHARGE',
                'FEE_INCLUDED_IN_PMT',
            ])
            .describe('Shows the event that will trigger a fee')
            .optional(),
    })
    .describe('An amount of predefined fee that was applied or paid on an account.')

export type Fee = z.infer<typeof Fee>

export const CustomPaymentAmount = z
    .object({
        amount: z.number().describe('The amount of the payment paid in the transaction for the given type.'),
        customPaymentAmountType: z
            .enum([
                'PRINCIPAL',
                'INTEREST',
                'MANUAL_FEE',
                'UPFRONT_DISBURSEMENT_FEE',
                'LATE_REPAYMENT_FEE',
                'PAYMENT_DUE_FEE',
                'PENALTY',
                'INTEREST_FROM_ARREARS',
                'NON_SCHEDULED_FEE',
                'INTEREST_BEARING_FEE',
                'INTEREST_BEARING_FEE_INTEREST',
                'CF_INTEREST',
                'CF_INTEREST_FROM_ARREARS',
                'CF_INTEREST_FROM_ARREARS_ACCRUED',
            ])
            .describe('The type of the custom payment'),
        predefinedFeeKey: z.string().describe('The encodedKey of the predefined fee to be paid.').optional(),
        taxOnAmount: z.number().describe('The amount of the taxes paid in the transaction for the given type.').optional(),
    })
    .describe('Custom payment amount for a specific element type')

export type CustomPaymentAmount = z.infer<typeof CustomPaymentAmount>

export const CardTransaction = z
    .object({
        advice: z.boolean().describe('Whether the given request should be accepted without balance validations.'),
        amount: z.number().describe('The amount of money to be withdrawn in the financial transaction.'),
        cardAcceptor: CardAcceptor.optional(),
        cardToken: z.string().describe('The reference token of the card.').optional(),
        currencyCode: z
            .string()
            .describe(
                'The ISO currency code in which the card reversal transaction is posted. The amounts are stored in the base currency, but the transaction can be created with a foreign currency.',
            )
            .optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        externalAuthorizationReferenceId: z
            .string()
            .describe(
                'The external authorization hold reference ID, which relates this card transaction to a previous authorization hold.',
            )
            .optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID to be used to reference the card transaction in subsequent requests.'),
        userTransactionTime: z.string().describe('The formatted time at which the user made this card transaction.').optional(),
    })
    .describe('A card transaction entry which will have a corresponding a financial transaction performed.')

export type CardTransaction = z.infer<typeof CardTransaction>

export const LoanAffectedAmounts = z
    .object({
        deferredInterestAmount: z
            .number()
            .describe('How much interest pre-paid was added/removed in account, within this transaction (including taxes).')
            .optional(),
        feesAmount: z.number().describe(' How much fees was added/removed in account, within this transaction.').optional(),
        fundersInterestAmount: z
            .number()
            .describe('How much interest is given to the investors, within this transaction (only for p2p products)')
            .optional(),
        interestAmount: z
            .number()
            .describe(
                'How much interest was added/removed in account, within this transaction (including taxes). If there is any deferred interest amount set in this transaction, that amount should be included in this field.',
            )
            .optional(),
        interestFromArrearsAmount: z
            .number()
            .describe('How much interest from arrears was added/removed in account, within this transaction (including taxes).')
            .optional(),
        organizationCommissionAmount: z
            .number()
            .describe('How much interest is given to the organization, within this transaction (only for p2p products)')
            .optional(),
        paymentHolidaysInterestAmount: z
            .number()
            .describe(
                'How much Payment Holidays interest was added/removed in account, within this transaction (including taxes).',
            )
            .optional(),
        penaltyAmount: z
            .number()
            .describe('How much penalties was added/removed in account, within this transaction.')
            .optional(),
        principalAmount: z
            .number()
            .describe('How much principal was added/removed in account, within this transaction.')
            .optional(),
    })
    .describe('The amounts affected after completing the loan transaction')

export type LoanAffectedAmounts = z.infer<typeof LoanAffectedAmounts>

export const TransactionBalances = z
    .object({
        advancePosition: z.number().describe('Captures the advance (prepaid) amount.').optional(),
        arrearsPosition: z.number().describe('Captures the arrears position amount for the account in arrears.').optional(),
        expectedPrincipalRedraw: z
            .number()
            .describe(
                'The difference between principal balance and redraw balance after each transaction performed on the loan account.',
            )
            .optional(),
        principalBalance: z.number().describe('The account redraw balance captured after the transaction update.').optional(),
        redrawBalance: z.number().describe('The account redraw balance captured after the transaction update.').optional(),
        totalBalance: z.number().describe('The running balance still owed for the loan.').optional(),
    })
    .describe('The balances changed within a transaction.')

export type TransactionBalances = z.infer<typeof TransactionBalances>

export const AccountBalances = z
    .object({
        accountId: z.string().describe('The unique account identifier').optional(),
        availableBalance: z.number().describe('The available balance of a deposit or credit account').optional(),
        cardType: z.enum(['DEBIT', 'CREDIT']).describe('The card type either DEBIT or CREDIT').optional(),
        creditLimit: z
            .number()
            .describe('The overdraft limit of a deposit account or the loan amount in case of a credit account')
            .optional(),
        currencyCode: z.string().describe('Currency code used for the account').optional(),
        totalBalance: z
            .number()
            .describe('The current balance of a deposit account or principal balance of a revolving credit')
            .optional(),
    })
    .describe('Account balances presented to inquirer such as card processor')

export type AccountBalances = z.infer<typeof AccountBalances>

export const DepositAccountInterestAvailabilitySettings = z
    .object({
        interestRate: z.number().describe('The interest rate for the deposit account').optional(),
        interestRateTiers: DepositAccountInterestRateTier.array()
            .describe(
                'The list of interest rate tiers. An interest rate tier holds the values to define how the interest is computed',
            )
            .optional(),
        interestSpread: z
            .number()
            .describe(
                'The rate based on which the interest is accrued and applied for accounts with InterestRateSource#INDEX_INTEREST_RATE',
            )
            .optional(),
    })
    .describe('Interest Rate Settings for Deposit Account Interest Availability')

export type DepositAccountInterestAvailabilitySettings = z.infer<typeof DepositAccountInterestAvailabilitySettings>

export const GLJournalEntryForeignAmount = z
    .object({
        accountingRate: AccountingRate.optional(),
        amount: z.number().describe('The amount of an accounting entry in foreign currency.').optional(),
        currency: Currency.optional(),
    })
    .describe('Represents the details of the general ledger journal entry amount posted in foreign currency.')

export type GLJournalEntryForeignAmount = z.infer<typeof GLJournalEntryForeignAmount>

export const LoanTranche = z
    .object({
        amount: z.number().describe('The amount this tranche has available for disburse'),
        disbursementDetails: TrancheDisbursementDetails.optional(),
        encodedKey: z.string().describe('The encoded key of the transaction details , auto generated, unique.').optional(),
        fees: CustomPredefinedFee.array().describe('Fees that are associated with this tranche').optional(),
        trancheNumber: z.number().int().describe('Index indicating the tranche number').optional(),
    })
    .describe(
        `In some cases organizations may approve loans but not disburse the full amount initially. They would like to spread the disbursement (and risk) over time. Likewise for the client, they may not need the full loan amount up front. They may want to have a loan to buy some equipment for their business but will make one purchase today and another purchase in a few months.  In these cases, they don't need the full amount and wouldn't want to pay interest on cash they don't need yet. A solution for this matter is the usage of disbursement in tranches. This class holds the information required for one of this tranche. `,
    )

export type LoanTranche = z.infer<typeof LoanTranche>

export const ScheduleSettings = z
    .object({
        amortizationPeriod: z
            .number()
            .int()
            .describe('The PMT is calculated as the loan would have [amortizationPeriod] installments.')
            .optional(),
        billingCycle: BillingCycleDays.optional(),
        defaultFirstRepaymentDueDateOffset: z
            .number()
            .int()
            .describe(
                'The default first repayment due date offset, indicates how many days the first repayment due date should be extended(all other due dates from the schedule are relative to first repayment due date - they will also be affected by the offset)',
            )
            .optional(),
        fixedDaysOfMonth: z
            .number()
            .int()
            .array()
            .describe(
                'Specifies the days of the month when the repayment due dates should be. Only available if the Repayment Methodology is FIXED_DAYS_OF_MONTH.',
            )
            .optional(),
        gracePeriod: z
            .number()
            .int()
            .describe('The grace period. Represents the grace period for loan repayment - in number of installments.'),
        gracePeriodType: z
            .enum(['NONE', 'PAY_INTEREST_ONLY', 'INTEREST_FORGIVENESS'])
            .describe('The grace period type. Representing the type of grace period which is possible for a loan account.')
            .optional(),
        hasCustomSchedule: z
            .boolean()
            .describe(
                'Flag used when the repayments schedule for the current account was determined by the user, by editing the due dates or the principal due',
            )
            .optional(),
        paymentPlan: PeriodicPayment.array().describe('A list of periodic payments for the current loan account.').optional(),
        periodicPayment: z
            .number()
            .describe(
                'The periodic payment amount for the accounts which have balloon payments or Reduce Number of Installments and Optimized Payments',
            )
            .optional(),
        previewSchedule: RevolvingAccountSettings.optional(),
        principalRepaymentInterval: z
            .number()
            .int()
            .describe('The principal repayment interval. Indicates the interval of repayments that the principal has to be paid.')
            .optional(),
        repaymentInstallments: z
            .number()
            .int()
            .describe('The repayment installments. Represents how many installments are required to pay back the loan.')
            .optional(),
        repaymentPeriodCount: z
            .number()
            .int()
            .describe(
                'The repayment period count. Represents how often the loan is to be repaid: stored based on the type repayment option.',
            )
            .optional(),
        repaymentPeriodUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS', 'YEARS'])
            .describe('The repayment period unit. Represents the frequency of loan repayment.')
            .optional(),
        repaymentScheduleMethod: z
            .enum(['NONE', 'FIXED', 'DYNAMIC'])
            .describe(
                `The repayment schedule method. Represents the method that determines whether the schedule will be fixed all over the loan account's life cycle or will be dynamically recomputed when required.`,
            )
            .optional(),
        scheduleDueDatesMethod: z
            .enum(['INTERVAL', 'FIXED_DAYS_OF_MONTH'])
            .describe(
                'The schedule due dates method. Represents the methodology used by this account to compute the due dates of the repayments.',
            )
            .optional(),
        shortMonthHandlingMethod: z
            .enum(['LAST_DAY_IN_MONTH', 'FIRST_DAY_OF_NEXT_MONTH'])
            .describe(
                'The short handling method. Determines how to handle the short months, if they select a fixed day of month > 28. Will be null if no such date is selected and also for the Interval methodology. Only available if the Repayment Methodology is FIXED_DAYS_OF_MONTH.',
            )
            .optional(),
    })
    .describe('The schedule settings, holds all schedule properties.')

export type ScheduleSettings = z.infer<typeof ScheduleSettings>

export const LoanAccountRedrawSettings = z
    .object({
        restrictNextDueWithdrawal: z
            .boolean()
            .describe(
                '`TRUE` if withdrawing amounts that reduce the next due instalment repayment is restricted, `FALSE` otherwise.',
            ),
    })
    .describe('Represents the redraw settings for a loan account.')

export type LoanAccountRedrawSettings = z.infer<typeof LoanAccountRedrawSettings>

export const PrincipalPaymentAccountSettings = z
    .object({
        amount: z.number().describe('Fixed amount for being used for the repayments principal due.').optional(),
        encodedKey: z
            .string()
            .describe('The encoded key of the principal payment base settings, auto generated, unique.')
            .optional(),
        includeFeesInFloorAmount: z
            .boolean()
            .describe(
                'Boolean flag, if true, the fees will be included along with the principal in the repayment floor amount, for a revolving credit account',
            )
            .optional(),
        includeInterestInFloorAmount: z
            .boolean()
            .describe(
                'Boolean flag, if true, the interest will be included along with the principal in the repayment floor amount, for a revolving credit account',
            )
            .optional(),
        percentage: z.number().describe('Percentage of principal amount used for the repayments principal due.').optional(),
        principalCeilingValue: z
            .number()
            .describe('The maximum principal due amount a repayment made with this settings can have')
            .optional(),
        principalFloorValue: z
            .number()
            .describe('The minimum principal due amount a repayment made with this settings can have')
            .optional(),
        principalPaymentMethod: z
            .enum([
                'FLAT',
                'OUTSTANDING_PRINCIPAL_PERCENTAGE',
                'PRINCIPAL_PERCENTAGE_LAST_DISB',
                'TOTAL_BALANCE_PERCENTAGE',
                'TOTAL_BALANCE_FLAT',
                'TOTAL_PRINCIPAL_PERCENTAGE',
            ])
            .describe('The method of principal payment for revolving credit.')
            .optional(),
        totalDueAmountFloor: z
            .number()
            .describe('The minimum total due amount a repayment made with this settings can have')
            .optional(),
        totalDuePayment: z
            .enum([
                'FLAT',
                'OUTSTANDING_PRINCIPAL_PERCENTAGE',
                'PRINCIPAL_PERCENTAGE_LAST_DISB',
                'TOTAL_BALANCE_PERCENTAGE',
                'TOTAL_BALANCE_FLAT',
                'TOTAL_PRINCIPAL_PERCENTAGE',
            ])
            .describe('The method of total due payment for revolving credit')
            .optional(),
    })
    .describe(
        'The principal payment account settings, holds the required information for the principal payment process of an account.',
    )

export type PrincipalPaymentAccountSettings = z.infer<typeof PrincipalPaymentAccountSettings>

export const PrepaymentSettings = z
    .object({
        applyInterestOnPrepaymentMethod: z
            .enum(['AUTOMATIC', 'MANUAL'])
            .describe('Apply interest on prepayment method copied from loan product on which this account is based.')
            .optional(),
        elementsRecalculationMethod: z
            .enum(['PRINCIPAL_EXPECTED_FIXED', 'TOTAL_EXPECTED_FIXED'])
            .describe(
                'The elements recalculation method, indicates how the declining balance with equal installments repayments are recalculated.',
            )
            .optional(),
        ercFreeAllowanceAmount: z.number().optional(),
        ercFreeAllowancePercentage: z
            .number()
            .describe('Early repayment charge fee free allowance in percentage per year')
            .optional(),
        prepaymentRecalculationMethod: z
            .enum([
                'NO_RECALCULATION',
                'RESCHEDULE_REMAINING_REPAYMENTS',
                'RECALCULATE_SCHEDULE_KEEP_SAME_NUMBER_OF_TERMS',
                'RECALCULATE_SCHEDULE_KEEP_SAME_PRINCIPAL_AMOUNT',
                'RECALCULATE_SCHEDULE_KEEP_SAME_TOTAL_REPAYMENT_AMOUNT',
                'REDUCE_AMOUNT_PER_INSTALLMENT',
                'REDUCE_NUMBER_OF_INSTALLMENTS',
                'REDUCE_NUMBER_OF_INSTALLMENTS_NEW',
            ])
            .describe('Prepayment recalculation method copied from the loan product on which this account is based.')
            .optional(),
        principalPaidInstallmentStatus: z
            .enum(['PARTIALLY_PAID', 'PAID', 'ORIGINAL_TOTAL_EXPECTED_PAID'])
            .describe('Installment status for the case when principal is paid off (copied from loan product).')
            .optional(),
    })
    .describe('The prepayment settings, holds all prepayment properties.')

export type PrepaymentSettings = z.infer<typeof PrepaymentSettings>

export const PlannedInstallmentFee = z
    .object({
        amount: z.number().describe('The amount of the planned fee.').optional(),
        applyOnDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                `The date when a planned fee should be applied, overriding installment's due date. It should match the interval of the installment. If it belong to first installment, it should be between disbursement date and installment due date.`,
            )
            .optional(),
        encodedKey: z.string().describe('The encoded key of the planned installment fee, auto generated, unique.').optional(),
        installmentKey: z
            .string()
            .describe('The encoded key of the installment on which the predefined fee is planned.')
            .optional(),
        installmentNumber: z
            .number()
            .int()
            .describe(
                'The number of the installment on which the predefined fee is planned. It is used only in the case when fees are created at the same time with the loan account creation or during preview schedule, before account creation, otherwise this should be empty and installmentKey will be used to identify an installment.',
            )
            .optional(),
        predefinedFeeKey: z.string().describe('The encoded key of the predefined fee which is planned.'),
    })
    .describe('The planned fee details holds the information related to the installment key, predefined fee key and amount')

export type PlannedInstallmentFee = z.infer<typeof PlannedInstallmentFee>

export const PenaltySettings = z
    .object({
        loanPenaltyCalculationMethod: z
            .enum(['NONE', 'OVERDUE_BALANCE', 'OVERDUE_BALANCE_AND_INTEREST', 'OUTSTANDING_PRINCIPAL'])
            .describe('The last penalty calculation method, represents on what amount are the penalties calculated.')
            .optional(),
        penaltyRate: z
            .number()
            .describe('The penalty rate, represents the rate (in percent) which is charged as a penalty.')
            .optional(),
    })
    .describe('The penalty settings, holds all the fields regarding penalties')

export type PenaltySettings = z.infer<typeof PenaltySettings>

export const InterestSettings = z
    .object({
        accountInterestRateSettings: AccountInterestRateSettings.array()
            .describe('Adjustable interest rates settings for loan account')
            .optional(),
        accrueInterestAfterMaturity: z
            .boolean()
            .describe(
                'The accrue interest after maturity. If the product support this option, specify if the interest should be accrued after the account maturity date.',
            )
            .optional(),
        accrueLateInterest: z.boolean().describe('Indicates whether late interest is accrued for this loan account').optional(),
        effectiveInterestRate: z
            .number()
            .describe(
                'The effective interest rate. Represents the interest rate for the loan accounts with semi-annually compounding product.',
            )
            .optional(),
        interestApplicationDays: DaysInMonth.optional(),
        interestApplicationMethod: z
            .enum(['AFTER_DISBURSEMENT', 'REPAYMENT_DUE_DATE', 'FIXED_DAYS_OF_MONTH'])
            .describe(
                `The interest application method. Represents the interest application method that determines whether the interest gets applied on the account's disbursement or on each repayment.`,
            )
            .optional(),
        interestBalanceCalculationMethod: z
            .enum(['ONLY_PRINCIPAL', 'PRINCIPAL_AND_INTEREST'])
            .describe(
                `The interest balance calculation method. Represents the option which determines the way the balance for the account's interest is computed.`,
            )
            .optional(),
        interestCalculationMethod: z
            .enum(['FLAT', 'DECLINING_BALANCE', 'DECLINING_BALANCE_DISCOUNTED', 'EQUAL_INSTALLMENTS'])
            .describe('The interest calculation method. Holds the type of interest calculation method.')
            .optional(),
        interestChargeFrequency: z
            .enum(['ANNUALIZED', 'EVERY_MONTH', 'EVERY_FOUR_WEEKS', 'EVERY_WEEK', 'EVERY_DAY', 'EVERY_X_DAYS'])
            .describe(
                'The interest change frequency. Holds the possible values for how often is interest charged on loan or deposit accounts',
            )
            .optional(),
        interestRate: z
            .number()
            .describe(
                'The interest rate. Represents the interest rate for the loan account. The interest on loans is accrued on a daily basis, which allows charging the clients only for the days they actually used the loan amount.',
            )
            .optional(),
        interestRateReviewCount: z.number().int().describe('Interest rate update frequency unit count.').optional(),
        interestRateReviewUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS'])
            .describe('The interest rate review unit. Defines the interest rate update frequency measurement unit.')
            .optional(),
        interestRateSource: z
            .enum(['FIXED_INTEREST_RATE', 'INDEX_INTEREST_RATE'])
            .describe(
                'The interest rate source. Represents the interest calculation method: fixed or (interest spread + active organization index interest rate)',
            )
            .optional(),
        interestSpread: z
            .number()
            .describe('Interest to be added to active organization index interest rate in order to find out actual interest rate')
            .optional(),
        interestType: z
            .enum(['SIMPLE_INTEREST', 'CAPITALIZED_INTEREST', 'COMPOUNDING_INTEREST'])
            .describe('The possible values for how we compute and apply the interest')
            .optional(),
        pmtAdjustmentThreshold: PMTAdjustmentThreshold.optional(),
    })
    .describe('The interest settings, holds all the properties regarding interests for the loan account.')

export type InterestSettings = z.infer<typeof InterestSettings>

export const Guarantor = z
    .object({
        amount: z.number().describe('The amount used by the client for the guaranty'),
        assetName: z
            .string()
            .describe('The name of a value the client guarantees with (populated when the guaranty type is ASSET)')
            .optional(),
        depositAccountKey: z
            .string()
            .describe(
                'The key of the deposit account used by the guarantor (populated when the guaranty type is GUARANTOR). It can be null.',
            )
            .optional(),
        encodedKey: z.string().describe('The encoded key of the security, auto generated, unique.').optional(),
        guarantorKey: z.string().describe('The key of the client/group used as the guarantor.'),
        guarantorType: z.enum(['CLIENT', 'GROUP']).describe('The type of the guarantor (client/group)'),
    })
    .passthrough()
    .describe(
        'Guarantor, holds information about a client guaranty entry. It can be defined based on another client which guarantees (including or not a savings account whether it is a client of the organization using Mambu or not) or based on a value the client holds (an asset)',
    )

export type Guarantor = z.infer<typeof Guarantor>

export const InvestorFund = z
    .object({
        amount: z.number().describe('The amount used by the client for the guaranty'),
        assetName: z
            .string()
            .describe('The name of a value the client guarantees with (populated when the guaranty type is ASSET)')
            .optional(),
        depositAccountKey: z
            .string()
            .describe(
                'The key of the deposit account used by the guarantor (populated when the guaranty type is GUARANTOR). It can be null.',
            )
            .optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        guarantorKey: z.string().describe('The key of the client/group used as the guarantor.'),
        guarantorType: z.enum(['CLIENT', 'GROUP']).describe('The type of the guarantor (client/group)'),
        id: z
            .string()
            .describe('Investor fund unique identifier. All versions of an investor fund will have same id.')
            .optional(),
        interestCommission: z.number().describe('The constraint minimum value').optional(),
        sharePercentage: z.number().describe('Percentage of loan shares this investor owns').optional(),
    })
    .describe(
        'Contains the details about an investor fund including fields like encoded key, guarantor type, amount and guarantor key',
    )

export type InvestorFund = z.infer<typeof InvestorFund>

export const FeesAccountSettings = z
    .object({
        feeRate: z
            .number()
            .describe(
                'The fee rate. Represents the fee rate for the loan account. The fee on loans is accrued on a daily basis, which allows charging the clients only for the days they actually used the loan amount.',
            )
            .optional(),
    })
    .describe('The fee settings, holds all the properties regarding fees for the loan account.')

export type FeesAccountSettings = z.infer<typeof FeesAccountSettings>

export const DisbursementDetails = z
    .object({
        disbursementDate: z
            .string()
            .datetime({ offset: true })
            .describe('The activation date, the date when the disbursement actually took place.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the disbursement details, auto generated, unique').optional(),
        expectedDisbursementDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the expected disbursement.Stored as Organization Time.')
            .optional(),
        fees: CustomPredefinedFee.array().describe('List of fees that should be applied at the disbursement time.').optional(),
        firstRepaymentDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the expected first repayment. Stored as Organization Time.')
            .optional(),
        transactionDetails: LoanTransactionDetails.optional(),
    })
    .describe(
        'The the disbursement details it holds the information related to the disbursement details as disbursement date, first repayment date, disbursement fees.',
    )

export type DisbursementDetails = z.infer<typeof DisbursementDetails>

export const Balances = z
    .object({
        feesBalance: z
            .number()
            .describe('The fees balance. Represents the total fees expected to be paid on this account at a given moment.')
            .optional(),
        feesDue: z.number().describe('The fees due. Representing the total fees due for the account.').optional(),
        feesPaid: z.number().describe('The fees paid. Represents the total fees paid for the account.').optional(),
        holdBalance: z.number().describe('The sum of all the authorization hold amounts on this account.').optional(),
        interestBalance: z
            .number()
            .describe(
                'Represents the total interest owed by the client (total interest applied for account minus interest paid).',
            )
            .optional(),
        interestDue: z
            .number()
            .describe(`The interest due. Indicates how much interest it's due for the account at this moment.`)
            .optional(),
        interestFromArrearsBalance: z
            .number()
            .describe(
                'The interest from arrears balance. Indicates interest from arrears owned by the client, from now on. (total interest from arrears accrued for account - interest from arrears paid).',
            )
            .optional(),
        interestFromArrearsDue: z
            .number()
            .describe(
                `The interest from arrears due. Indicates how much interest from arrears it's due for the account at this moment.`,
            )
            .optional(),
        interestFromArrearsPaid: z
            .number()
            .describe('The interest from arrears paid, indicates total interest from arrears paid into the account.')
            .optional(),
        interestPaid: z.number().describe('The interest paid, indicates total interest paid into the account.').optional(),
        penaltyBalance: z
            .number()
            .describe('The penalty balance. Represents the total penalty expected to be paid on this account at a given moment.')
            .optional(),
        penaltyDue: z.number().describe('The penalty due. Represents the total penalty amount due for the account.').optional(),
        penaltyPaid: z
            .number()
            .describe('The Penalty paid. Represents the total penalty amount paid for the account.')
            .optional(),
        principalBalance: z
            .number()
            .describe('The total principal owned by the client, from now on (principal disbursed - principal paid).')
            .optional(),
        principalDue: z.number().describe(`The principal due, indicates how much principal it's due at this moment.`).optional(),
        principalPaid: z.number().describe('The principal paid, holds the value of the total paid into the account.').optional(),
        redrawBalance: z.number().describe('The total redraw amount owned by the client, from now on.').optional(),
    })
    .describe('The loan account balance details.')

export type Balances = z.infer<typeof Balances>

export const Asset = z
    .object({
        amount: z.number().describe('The amount used by the client for the guaranty'),
        assetName: z
            .string()
            .describe('The name of a value the client guarantees with (populated when the guaranty type is ASSET)'),
        depositAccountKey: z
            .string()
            .describe(
                'The key of the deposit account used by the guarantor (populated when the guaranty type is GUARANTOR). It can be null.',
            )
            .optional(),
        encodedKey: z.string().describe('The encoded key of the security, auto generated, unique.').optional(),
        guarantorKey: z.string().describe('The key of the client/group used as the guarantor.').optional(),
        guarantorType: z.enum(['CLIENT', 'GROUP']).describe('The type of the guarantor (client/group)').optional(),
        originalAmount: z.number().describe('The original amount used by the client for a collateral asset').optional(),
        originalCurrency: Currency.optional(),
    })
    .passthrough()
    .describe('Asset, holds information about a client asset entry.')

export type Asset = z.infer<typeof Asset>

export const AccountArrearsSettings = z
    .object({
        dateCalculationMethod: z
            .enum(['ACCOUNT_FIRST_WENT_TO_ARREARS', 'LAST_LATE_REPAYMENT', 'ACCOUNT_FIRST_BREACHED_MATERIALITY_THRESHOLD'])
            .describe('The arrears date calculation method.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the arrears base settings, auto generated, unique.').optional(),
        monthlyToleranceDay: z.number().int().describe('Defines monthly arrears tolerance day value.').optional(),
        nonWorkingDaysMethod: z
            .enum(['INCLUDED', 'EXCLUDED'])
            .describe(
                'Shows whether the non working days are taken in consideration or not when applying penaltees/late fees or when setting an account into arrears',
            )
            .optional(),
        toleranceCalculationMethod: z
            .enum(['ARREARS_TOLERANCE_PERIOD', 'MONTHLY_ARREARS_TOLERANCE_DAY'])
            .describe('Defines the tolerance calculation method')
            .optional(),
        toleranceFloorAmount: z.number().describe('The tolerance floor amount.').optional(),
        tolerancePercentageOfOutstandingPrincipal: z.number().describe('Defines the arrears tolerance amount.').optional(),
        tolerancePeriod: z.number().int().describe('Defines the arrears tolerance period value.').optional(),
    })
    .describe('The account arrears settings, holds the required information for the arrears settings of an account.')

export type AccountArrearsSettings = z.infer<typeof AccountArrearsSettings>

export const DepositAccountOwnershipHistory = z
    .object({
        previousOwnerKey: z.string().describe('They key of the previous account holder').optional(),
        transferDate: z.string().datetime({ offset: true }).describe('The transfer date of the account ownership').optional(),
    })
    .describe('The history of deposit account ownership')

export type DepositAccountOwnershipHistory = z.infer<typeof DepositAccountOwnershipHistory>

export const DepositAccountOverdraftSettings = z
    .object({
        allowOverdraft: z.boolean().describe('`TRUE` if this account supports overdraft, `FALSE` otherwise.').optional(),
        overdraftExpiryDate: z.string().datetime({ offset: true }).describe('The expiration date of an overdraft.').optional(),
        overdraftLimit: z
            .number()
            .describe('The limit amount that may be taken out as overdraft, where null means 0.')
            .optional(),
    })
    .describe(`Represents information about a deposit account's overdraft settings.`)

export type DepositAccountOverdraftSettings = z.infer<typeof DepositAccountOverdraftSettings>

export const DepositAccountOverdraftInterestSettings = z
    .object({
        interestRateSettings: DepositAccountOverdraftInterestRateSettings.optional(),
    })
    .describe(`Represents information about a deposit account's overdraft interest settings.`)

export type DepositAccountOverdraftInterestSettings = z.infer<typeof DepositAccountOverdraftInterestSettings>

export const DepositAccountInternalControls = z
    .object({
        maxDepositBalance: z.number().describe('The maximum deposit balance of the account.').optional(),
        maxWithdrawalAmount: z.number().describe('The maximum amount allowed for a withdrawal.').optional(),
        recommendedDepositAmount: z.number().describe('The recommended amount for a deposit.').optional(),
        targetAmount: z.number().describe('The target amount for a deposit made towards a savings goal.').optional(),
    })
    .describe('Represents information about internal controls.')

export type DepositAccountInternalControls = z.infer<typeof DepositAccountInternalControls>

export const DepositAccountInterestSettings = z
    .object({
        interestPaymentSettings: DepositAccountInterestPaymentSettings.optional(),
        interestRateSettings: DepositAccountInterestRateSettings.optional(),
    })
    .describe(`Represents information about the deposit account's interest settings.`)

export type DepositAccountInterestSettings = z.infer<typeof DepositAccountInterestSettings>

export const DepositAccountBalances = z
    .object({
        availableBalance: z.number().describe('The current available balance for deposit transactions.').optional(),
        blockedBalance: z.number().describe('The sum of all the blocked amounts on an account.').optional(),
        feesDue: z.number().describe('The amount of fees due to be paid on this account.').optional(),
        forwardAvailableBalance: z
            .number()
            .describe(
                'The sum of all the authorization hold amounts that have `CRDT` as the `creditDebitIndicator` for an account.',
            )
            .optional(),
        holdBalance: z
            .number()
            .describe(
                'The sum of all the authorization hold amounts that have `DBIT` as the `creditDebitIndicator` for an account.',
            )
            .optional(),
        lockedBalance: z
            .number()
            .describe(
                'The locked amount that is not available for withdrawal in the account. For more information, see [Deposit Account Overview Details](https://support.mambu.com/docs/deposit-account-overview-details).',
            )
            .optional(),
        overdraftAmount: z
            .number()
            .describe(
                'The overdraft amount that has been taken out in the account. For more information, see [Overdraft Products](https://support.mambu.com/docs/en/overdraft-products).',
            )
            .optional(),
        overdraftInterestDue: z
            .number()
            .describe('The amount of interest due to be paid on an account as a result of an authorized overdraft.')
            .optional(),
        technicalOverdraftAmount: z
            .number()
            .describe(
                'The technical overdraft amount that has been taken out in the account. For more information, see [Technical Overdraft](https://support.mambu.com/docs/en/overdraft-products#technical-overdraft).',
            )
            .optional(),
        technicalOverdraftInterestDue: z
            .number()
            .describe('The amount of interest due to be paid on an account as a result of a technical overdraft.')
            .optional(),
        totalBalance: z.number().describe('The current balance of the account.').optional(),
    })
    .describe('Represents information about the balances of a deposit account.')

export type DepositAccountBalances = z.infer<typeof DepositAccountBalances>

export const DepositAccountAccruedAmounts = z
    .object({
        interestAccrued: z.number().describe('The amount of positive interest that has been accrued in the account.').optional(),
        negativeInterestAccrued: z
            .number()
            .describe('The amount of negative interest that has been accrued in the account.')
            .optional(),
        overdraftInterestAccrued: z
            .number()
            .describe('The amount of overdraft interest that has been accrued in the account.')
            .optional(),
        technicalOverdraftInterestAccrued: z
            .number()
            .describe('The amount of technical overdraft interest that has been accrued in the account.')
            .optional(),
    })
    .describe('Represents information about the accrued amounts of deposit accounts.')

export type DepositAccountAccruedAmounts = z.infer<typeof DepositAccountAccruedAmounts>

export const DataImportErrorColumn = z
    .object({
        index: z.number().int().describe('Column index').optional(),
        name: z.string().describe('Column name').optional(),
    })
    .describe('Holds basic information for an error column: the index and the corresponding name')

export type DataImportErrorColumn = z.infer<typeof DataImportErrorColumn>

export const DepositTerms = z
    .object({
        interestSettings: DepositTransactionInterestSettings.optional(),
        overdraftInterestSettings: DepositOverdraftInterestSettings.optional(),
        overdraftSettings: DepositOverdraftSettings.optional(),
    })
    .describe('The deposit transaction terms')

export type DepositTerms = z.infer<typeof DepositTerms>

export const DepositTaxes = z
    .object({
        taxRate: z.number().describe('The tax rate that was set or changed in this transaction').optional(),
    })
    .describe('The taxes applied within a transaction')

export type DepositTaxes = z.infer<typeof DepositTaxes>

export const DepositInterestAccruedAmounts = z
    .object({
        interestAccrued: z
            .number()
            .describe(
                'The amount of positive interest accrued since last interest application/activation date and applied within Interest Applied transaction',
            )
            .optional(),
        negativeInterestAccrued: z
            .number()
            .describe(
                'The amount of negative interest accrued since last interest application/activation date and applied within Interest Applied transaction',
            )
            .optional(),
        overdraftInterestAccrued: z
            .number()
            .describe(
                'The amount of overdraft interest accrued since last interest application/activation date and applied within Interest Applied transaction',
            )
            .optional(),
        technicalOverdraftInterestAccrued: z
            .number()
            .describe(
                'The amount of technical overdraft interest accrued since last interest application/activation date and applied within Interest Applied transaction',
            )
            .optional(),
    })
    .describe('Represents the accrued interest amounts for an Interest Applied deposit transaction.')

export type DepositInterestAccruedAmounts = z.infer<typeof DepositInterestAccruedAmounts>

export const DepositFee = z
    .object({
        amount: z
            .number()
            .describe('The amount of the fee that was applied/paid in the transaction for the given predefined fee.')
            .optional(),
        name: z.string().describe('The name of the predefined fee').optional(),
        predefinedFeeKey: z.string().describe('The encoded key of the predefined fee, auto generated, unique'),
        taxAmount: z.number().describe('The amount of the taxes on fee that was applied/paid in the transaction.').optional(),
        trigger: z.enum(['MANUAL', 'MONTHLY_FEE', 'ARBITRARY']).describe('Shows the event that will trigger a fee').optional(),
    })
    .describe('An amount of predefined fee that was applied or paid on an account.')

export type DepositFee = z.infer<typeof DepositFee>

export const DepositAffectedAmounts = z
    .object({
        feesAmount: z
            .number()
            .describe('Amount of fees involved in a transaction that affects an account with positive balance')
            .optional(),
        fractionAmount: z
            .number()
            .describe(
                'In the case of an LOAN_FRACTION_BOUGHT this represent the fraction amount which was bought from another investor',
            )
            .optional(),
        fundsAmount: z
            .number()
            .describe('Balance change amount involved in a transaction that affects an account with positive balance')
            .optional(),
        interestAmount: z
            .number()
            .describe('Amount of interest involved in a transaction that affects an account with positive balance')
            .optional(),
        overdraftAmount: z
            .number()
            .describe('The amount of money that was added/subtracted from the account by this transaction as overdraft')
            .optional(),
        overdraftFeesAmount: z.number().describe('Fees amount involved in a transaction that affects an overdraft').optional(),
        overdraftInterestAmount: z
            .number()
            .describe('Interest amount involved in a transaction that affects an overdraft')
            .optional(),
        technicalOverdraftAmount: z
            .number()
            .describe('The amount of money that was added/subtracted from the account by this transaction as technical overdraft')
            .optional(),
        technicalOverdraftInterestAmount: z
            .number()
            .describe(
                'The amount of money that was added/subtracted from the account by this transaction as technical overdraft interest',
            )
            .optional(),
    })
    .describe('The amounts affected after completing the deposit transaction')

export type DepositAffectedAmounts = z.infer<typeof DepositAffectedAmounts>

export const DepositTransactionBalances = z
    .object({
        totalBalance: z.number().describe('The running balance owed by deposit').optional(),
    })
    .describe('The balances changed within a transaction.')

export type DepositTransactionBalances = z.infer<typeof DepositTransactionBalances>

export const GroupMember = z
    .object({
        clientKey: z.string().describe('The encoded key of the client assigned as member of the group.'),
        roles: GroupRole.array().describe('The group role name associated with a group member.').optional(),
    })
    .describe(
        'Represents a group member. A group member is person that uses the services of the bank and is member of a group. Group members may have associated information, such as their client key and a list of roles they have within the group.',
    )

export type GroupMember = z.infer<typeof GroupMember>

export const Address = z
    .object({
        city: z.string().describe('The city for the address.').optional(),
        country: z.string().describe('The country.').optional(),
        encodedKey: z.string().describe('The address encoded key, which is unique and generated.').optional(),
        indexInList: z.number().int().describe('The index of this address in the list of addresses.').optional(),
        latitude: z
            .number()
            .describe(
                'The GPS latitude of this address in signed degrees format (DDD.dddd) with 6 decimal positions, ranging from -90 to +90.',
            )
            .optional(),
        line1: z.string().describe('The first line of the address.').optional(),
        line2: z.string().describe('The second line of the address.').optional(),
        longitude: z
            .number()
            .describe(
                'The GPS longitude of this address in signed degrees format (DDD.dddd) with 6 decimal positions, ranging from -180 to +180.',
            )
            .optional(),
        parentKey: z
            .string()
            .describe('The address parent key indicating the object owning this address. For example: client, centre, or branch.')
            .optional(),
        postcode: z.string().describe('The post code.').optional(),
        region: z.string().describe('The region for the address.').optional(),
    })
    .describe('Represents an address.')

export type Address = z.infer<typeof Address>

export const DocumentTemplate = z
    .object({
        creationDate: z.string().datetime({ offset: true }).describe('The creation date of the document').optional(),
        encodedKey: z.string().describe('The document encodedKey').optional(),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('The last modified date of the document').optional(),
        name: z.string().describe('The name the document').optional(),
        type: z.enum(['ACCOUNT', 'TRANSACTION', 'ACCOUNT_WITH_TRANSACTIONS']).describe('The type of the template').optional(),
    })
    .describe('Template documents of the product.')

export type DocumentTemplate = z.infer<typeof DocumentTemplate>

export const TaxSettings = z
    .object({
        taxCalculationMethod: z
            .enum(['INCLUSIVE', 'EXCLUSIVE'])
            .describe('Shows whether the tax is added on top of the target amount or not.')
            .optional(),
        taxesOnFeesEnabled: z.boolean().describe('Shows whether taxes on fees are enabled for this product or not.').optional(),
        taxesOnInterestEnabled: z
            .boolean()
            .describe('Shows whether taxes on interest are enabled for this product or not.')
            .optional(),
        taxesOnPenaltyEnabled: z
            .boolean()
            .describe('Shows whether taxes on penalties are enabled for this product or not.')
            .optional(),
        taxSourceKey: z.string().describe('The tax source from where the loan account taxes will be updated.').optional(),
    })
    .describe('Tax settings, defines some settings for taxes on the loan product')

export type TaxSettings = z.infer<typeof TaxSettings>

export const SecuritySettings = z
    .object({
        isCollateralEnabled: z
            .boolean()
            .describe(
                'Shows whether collateral (assets or other goods) are accepted in order to reach required securities percentage from loan amount, as defined in this product.',
            )
            .optional(),
        isGuarantorsEnabled: z
            .boolean()
            .describe(
                'Shows whether guarantors (other clients) are accepted in order to reach the required securities percentage from loan amount, as defined in this product.',
            )
            .optional(),
        requiredGuaranties: z
            .number()
            .describe(
                'The securities percentage from loan amount that is needed in order for this account to be approved. Null if the securities are not required.',
            )
            .optional(),
    })
    .describe('The settings and constraints for securities.')

export type SecuritySettings = z.infer<typeof SecuritySettings>

export const LoanProductScheduleSettings = z
    .object({
        amortizationPeriod: ProductAmortizationPeriod.optional(),
        billingCycles: BillingCyclesProductSettings.optional(),
        defaultRepaymentPeriodCount: z.number().int().describe('Interval Repayment Methodology Settings.').optional(),
        firstRepaymentDueDateOffset: IntegerIntervalConstraints.optional(),
        fixedDaysOfMonth: z
            .number()
            .int()
            .array()
            .describe(
                ' Specifies the days of the month when the repayment due dates should be. Only available if the Repayment Methodology is ScheduleDueDatesMethodDTO#FIXED_DAYS_OF_MONTH.',
            )
            .optional(),
        interestAccrualSince: z
            .enum(['DISBURSEMENT', 'DUE_DATE'])
            .describe('Represents the moment the interest will start getting accrued.')
            .optional(),
        keepInstallmentsEqualIfLongFirstPeriod: z
            .boolean()
            .describe(
                'For optimized payments only, indicates whether the installments should remain equal when the first period is long',
            )
            .optional(),
        numInstallments: IntegerIntervalConstraints.optional(),
        previewSchedule: PreviewScheduleSettings.optional(),
        repaymentMethod: z.enum(['AMOUNT', 'INSTALLMENTS']).describe('The repayment method value').optional(),
        repaymentPeriodUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS', 'YEARS'])
            .describe('The frequency of the loan repayment.')
            .optional(),
        repaymentReschedulingMethod: z
            .enum(['NONE', 'NEXT_WORKING_DAY', 'PREVIOUS_WORKING_DAY', 'EXTEND_SCHEDULE'])
            .describe('The repayment rescheduling method used in calculations.'),
        repaymentScheduleEditOptions: z
            .enum([
                'ADJUST_PAYMENT_DATES',
                'ADJUST_PRINCIPAL_PAYMENT_SCHEDULE',
                'ADJUST_INTEREST_PAYMENT_SCHEDULE',
                'ADJUST_FEE_PAYMENT_SCHEDULE',
                'ADJUST_PENALTY_PAYMENT_SCHEDULE',
                'ADJUST_NUMBER_OF_INSTALLMENTS',
                'ADJUST_PAYMENT_HOLIDAYS',
            ])
            .array()
            .describe('Shows the properties from the repayment schedule can be edited.')
            .optional(),
        repaymentScheduleMethod: z
            .enum(['NONE', 'FIXED', 'DYNAMIC'])
            .describe(
                `The repayment schedule method. Represents the method that determines whether the schedule will be fixed all over the loan account's life cycle or will be dynamically recomputed when required.`,
            ),
        roundingSettings: RoundingSettings.optional(),
        scheduleDueDatesMethod: z
            .enum(['INTERVAL', 'FIXED_DAYS_OF_MONTH'])
            .describe('The methodology used by this product to compute the due dates of the repayments.'),
        scheduleEditOptionDetails: RepaymentScheduleEditOptionDetails.optional(),
        shortMonthHandlingMethod: z
            .enum(['LAST_DAY_IN_MONTH', 'FIRST_DAY_OF_NEXT_MONTH'])
            .describe(
                'Determines how to handle the short months, if they select a fixed day of month > 28. Will be null if no such date is selected and also for the Interval methodology. Only available if the Schedule Due Dates Method is ScheduleDueDatesMethodDTO#FIXED_DAYS_OF_MONTHs.',
            )
            .optional(),
    })
    .describe('Defines the settings and constraints for schedule for the loans that are created based on this product.')

export type LoanProductScheduleSettings = z.infer<typeof LoanProductScheduleSettings>

export const ProductRedrawSettings = z
    .object({
        allowRedraw: z
            .boolean()
            .describe(
                'Indicates whether the product support redraw (prepayments which are stored at loan account level as a Redrawable balance)',
            ),
    })
    .describe('The redraw settings for the product.')

export type ProductRedrawSettings = z.infer<typeof ProductRedrawSettings>

export const ProductPenaltySettings = z
    .object({
        loanPenaltyCalculationMethod: z
            .enum(['NONE', 'OVERDUE_BALANCE', 'OVERDUE_BALANCE_AND_INTEREST', 'OUTSTANDING_PRINCIPAL'])
            .describe('The penalty calculation method'),
        loanPenaltyGracePeriod: z
            .number()
            .int()
            .describe('Number of days to wait before applying the loan penalty amounts')
            .optional(),
        penaltyRate: DecimalConstraints.optional(),
    })
    .describe('Defines the penalty settings for the product that will be used by the loan accounts based on this product')

export type ProductPenaltySettings = z.infer<typeof ProductPenaltySettings>

export const PaymentSettings = z
    .object({
        amortizationMethod: z
            .enum(['STANDARD_PAYMENTS', 'BALLOON_PAYMENTS', 'OPTIMIZED_PAYMENTS', 'PAYMENT_PLAN'])
            .describe('Payments Method used by loan accounts for repayments schedule generation.')
            .optional(),
        latePaymentsRecalculationMethod: z
            .enum(['OVERDUE_INSTALLMENTS_INCREASE', 'LAST_INSTALLMENT_INCREASE', 'NO_RECALCULATION'])
            .describe('Recalculate the schedule when late payments are posted on dynamic Equal Installments loans.'),
        paymentMethod: z
            .enum(['HORIZONTAL', 'VERTICAL'])
            .describe(
                'The payment method. Represents the interest payment method that determines whether the payments are made Horizontally (on the Repayments) or Vertically (on the Loan Account)',
            ),
        prepaymentSettings: ProductPrepaymentSettings.optional(),
        principalPaymentSettings: PrincipalPaymentProductSettings.optional(),
        repaymentAllocationOrder: z
            .enum(['PRINCIPAL', 'INTEREST', 'FEE', 'PENALTY'])
            .array()
            .describe('A list of basic repayment allocation elements such as the principal, interest & fees.'),
    })
    .describe('Defines the payment settings for the loan product and for loans crated based on this product.')

export type PaymentSettings = z.infer<typeof PaymentSettings>

export const OffsetSettings = z
    .object({
        allowOffset: z.boolean().describe('Indicates whether the product supports offset').optional(),
    })
    .describe('The offset settings, holds information about offset.')

export type OffsetSettings = z.infer<typeof OffsetSettings>

export const NewAccountSettings = z
    .object({
        accountInitialState: z
            .enum([
                'PARTIAL_APPLICATION',
                'PENDING_APPROVAL',
                'APPROVED',
                'ACTIVE',
                'ACTIVE_IN_ARREARS',
                'CLOSED',
                'CLOSED_WRITTEN_OFF',
                'CLOSED_REJECTED',
            ])
            .describe('The initial state of the account when is created.'),
        idGeneratorType: z
            .enum(['INCREMENTAL_NUMBER', 'RANDOM_PATTERN'])
            .describe('The type of generator used for IDs creation.'),
        idPattern: z.string().describe('The pattern that will be used for ID validation (as referred to as an input mask).'),
    })
    .describe(
        'The new account settings, defines the settings and constraints used by new loan account created based on this product.',
    )

export type NewAccountSettings = z.infer<typeof NewAccountSettings>

export const LoanAmountSettings = z
    .object({
        loanAmount: AmountDecimalConstraints.optional(),
        trancheSettings: TrancheSettings.optional(),
    })
    .describe('The amount settings, holds all amount properties.')

export type LoanAmountSettings = z.infer<typeof LoanAmountSettings>

export const InternalControls = z
    .object({
        dormancyPeriodDays: z
            .number()
            .int()
            .describe('Specifies the number of days for an account to be fully paid in order to auto close it.')
            .optional(),
        fourEyesPrinciple: FourEyesPrinciple.optional(),
        lockSettings: LockSettings.optional(),
    })
    .describe('Constraints and automated actions and that will be applied on the accounts.')

export type InternalControls = z.infer<typeof InternalControls>

export const ProductInterestSettings = z
    .object({
        accrueLateInterest: z.boolean().describe('Whether late interest should be accrued, applied and paid').optional(),
        compoundingFrequency: z
            .enum(['DAILY', 'SEMI_ANNUALLY'])
            .describe(
                'The frequency on which the accrued interest will be added to the principal for interest calculation. It is used only for InterestType.COMPOUNDING_INTEREST',
            )
            .optional(),
        daysInYear: z
            .enum(['ACTUAL_365_FIXED', 'ACTUAL_364', 'ACTUAL_360', 'ACTUAL_ACTUAL_ISDA', 'E30_360', 'BUS_252', 'E30_42_365'])
            .describe('The days in year that should be used for loan calculations.'),
        decoupleInterestFromArrears: z
            .boolean()
            .describe(
                'Whether interest from arrears is decoupled from regular interest. (Only accepted or returned if the feature is enabled.)',
            )
            .optional(),
        indexRateSettings: InterestProductSettings.optional(),
        interestApplicationDays: DaysInMonth.optional(),
        interestApplicationMethod: z
            .enum(['AFTER_DISBURSEMENT', 'REPAYMENT_DUE_DATE', 'FIXED_DAYS_OF_MONTH'])
            .describe(
                `The interest application method. Represents the interest application method that determines whether the interest gets applied on the account's disbursement or on each repayment.`,
            )
            .optional(),
        interestBalanceCalculationMethod: z
            .enum(['ONLY_PRINCIPAL', 'PRINCIPAL_AND_INTEREST'])
            .describe(
                `The interest balance calculation method. Represents the option which determines the way the balance for the account's interest is computed.`,
            )
            .optional(),
        interestCalculationMethod: z
            .enum(['FLAT', 'DECLINING_BALANCE', 'DECLINING_BALANCE_DISCOUNTED', 'EQUAL_INSTALLMENTS'])
            .describe('The interest calculation method. Holds the type of interest calculation method.'),
        interestRateSettings: ProductInterestRateSettings.array().describe('Adjustable interest rates settings').optional(),
        interestType: z
            .enum(['SIMPLE_INTEREST', 'CAPITALIZED_INTEREST', 'COMPOUNDING_INTEREST'])
            .describe('The possible values for how we compute and apply the interest')
            .optional(),
        pmtAdjustmentThreshold: PMTAdjustmentThreshold.optional(),
        scheduleInterestDaysCountMethod: z
            .enum(['REPAYMENT_PERIODICITY', 'ACTUAL_DAYS_COUNT'])
            .describe(
                'Shows  whether all the installments should compute the interest based on the actual number of days or based on the defined repayment periodicity.',
            ),
    })
    .describe(
        'The interest settings, defines constraints regarding interest that will be used on the loan account crated based on this product.',
    )

export type ProductInterestSettings = z.infer<typeof ProductInterestSettings>

export const GracePeriodSettings = z
    .object({
        gracePeriod: IntegerIntervalConstraints.optional(),
        gracePeriodType: z
            .enum(['NONE', 'PAY_INTEREST_ONLY', 'INTEREST_FORGIVENESS'])
            .describe('The grace period type. Representing the type of grace period which is possible for a loan account.')
            .optional(),
    })
    .describe('The funding settings, holds the settings regarding the funding for the loan product.')

export type GracePeriodSettings = z.infer<typeof GracePeriodSettings>

export const FundingSettings = z
    .object({
        enabled: z.boolean().describe('Indicates whether the product has the investor funds enabled or not.').optional(),
        funderInterestCommission: DecimalConstraints.optional(),
        funderInterestCommissionAllocationType: z
            .enum(['PERCENTAGE_OF_LOAN_FUNDING', 'FIXED_INTEREST_COMMISSIONS'])
            .describe(
                'Define how the Interest is allocated to the investors(if the investors can define their own percentages for their own contribution to the loan, or if all of them are using the same percentage).',
            )
            .optional(),
        lockFundsAtApproval: z
            .boolean()
            .describe(`Shows whether investor funds are locked or not at the loan account's approval.`)
            .optional(),
        organizationInterestCommission: DecimalConstraints.optional(),
        requiredFunds: z
            .number()
            .describe(
                'The required investor funds percentage, for opening an account with external funding. If null, the investor funds are not enabled.',
            )
            .optional(),
    })
    .describe('The funding settings, holds the settings regarding the funding for the loan product.')

export type FundingSettings = z.infer<typeof FundingSettings>

export const FeesSettings = z
    .object({
        allowArbitraryFees: z
            .boolean()
            .describe(
                `Only if true users will be able to apply fees, for current object, of type 'Other'; these fees can have any amount.`,
            )
            .optional(),
        fees: PredefinedFee.array()
            .describe('List of all fees that can be applied for accounts of this loan product.')
            .optional(),
    })
    .describe('Defines fees settings for the product.')

export type FeesSettings = z.infer<typeof FeesSettings>

export const CreditArrangementSettings = z
    .object({
        creditArrangementRequirement: z
            .enum(['OPTIONAL', 'REQUIRED', 'NOT_REQUIRED'])
            .describe('Shows whether accounts created after this product can/should be part of a line of credit.')
            .optional(),
    })
    .describe('The funding settings, holds the settings regarding the funding for the loan product.')

export type CreditArrangementSettings = z.infer<typeof CreditArrangementSettings>

export const ProductAvailabilitySettings = z
    .object({
        availableFor: z
            .enum(['INDIVIDUALS', 'PURE_GROUPS', 'SOLIDARITY_GROUPS'])
            .array()
            .describe('Holds the entities this product is available for. i.e Individuals')
            .optional(),
        branchSettings: BranchSettings.optional(),
    })
    .describe('Holds information about product availability.')

export type ProductAvailabilitySettings = z.infer<typeof ProductAvailabilitySettings>

export const ProductArrearsSettings = z
    .object({
        dateCalculationMethod: z
            .enum(['ACCOUNT_FIRST_WENT_TO_ARREARS', 'LAST_LATE_REPAYMENT', 'ACCOUNT_FIRST_BREACHED_MATERIALITY_THRESHOLD'])
            .describe('The arrears date calculation method.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the arrears base settings, auto generated, unique.').optional(),
        monthlyToleranceDay: z.number().int().describe('Defines the tolerance monthly date').optional(),
        nonWorkingDaysMethod: z
            .enum(['INCLUDED', 'EXCLUDED'])
            .describe(
                'Shows whether the non working days are taken in consideration or not when applying penaltees/late fees or when setting an account into arrears',
            )
            .optional(),
        toleranceCalculationMethod: z
            .enum(['ARREARS_TOLERANCE_PERIOD', 'MONTHLY_ARREARS_TOLERANCE_DAY'])
            .describe('Defines the tolerance calculation method')
            .optional(),
        toleranceFloorAmount: z.number().describe('The tolerance floor amount.').optional(),
        tolerancePercentageOfOutstandingPrincipal: DecimalInterval.optional(),
        tolerancePeriod: IntegerIntervalConstraints.optional(),
    })
    .describe(
        'The product arrears settings, shows whether the non working days are taken in consideration or not when applying penalties/late fees or when setting an account into arrears',
    )

export type ProductArrearsSettings = z.infer<typeof ProductArrearsSettings>

export const AccountLinkSettings = z
    .object({
        enabled: z
            .boolean()
            .describe('Shows whether the loan accounts created using this product can be linked to a savings account.'),
        linkableDepositProductKey: z
            .string()
            .describe(
                'Loan accounts created for this product can only be linked the the savings accounts that use the savings product with this key. If null, the loan accounts for this product can be linked to any savings account.',
            )
            .optional(),
        linkedAccountOptions: z
            .enum(['AUTO_LINK_ACCOUNTS', 'AUTO_CREATE_LINKED_ACCOUNTS'])
            .array()
            .describe('A set of linked account options.')
            .optional(),
        settlementMethod: z
            .enum(['FULL_DUE_AMOUNTS', 'PARTIAL_DUE_AMOUNTS', 'NO_AUTOMATED_TRANSFERS'])
            .describe(
                'Set the option of automated transfer that should be made from linked deposit accounts into loan accounts create from this product.',
            )
            .optional(),
    })
    .describe('Defines the settings for account linking.')

export type AccountLinkSettings = z.infer<typeof AccountLinkSettings>

export const AccountingSettings = z
    .object({
        accountingMethod: z.enum(['NONE', 'CASH', 'ACCRUAL']).describe('The calculation method used for accounting.'),
        accountingRules: GLAccountingRule.array().describe('A list of accounting rules for the product.').optional(),
        interestAccrualCalculation: z
            .enum(['NONE', 'AGGREGATED_AMOUNT', 'BREAKDOWN_PER_ACCOUNT'])
            .describe('The accounting interest calculation option selected for the product.')
            .optional(),
        interestAccruedAccountingMethod: z
            .enum(['NONE', 'DAILY', 'END_OF_MONTH'])
            .describe('The interval defined for a product when the interest accrues should be maintained.')
            .optional(),
    })
    .describe('Accounting settings, defines the accounting settings for the product.')

export type AccountingSettings = z.infer<typeof AccountingSettings>

export const RoleIdentifier = z
    .object({
        encodedKey: z.string().describe('The encoded key of the entity, generated automatically, globally unique.').optional(),
        id: z.string().describe('The ID of the role, which can be generated and customized, but must be unique.').optional(),
    })
    .describe('Represents the role identifier.')

export type RoleIdentifier = z.infer<typeof RoleIdentifier>

export const ApiConsumerAccess = z
    .object({
        administratorAccess: z
            .boolean()
            .describe(
                '`TRUE` if the API consumer has the administrator user type, `FALSE` otherwise. Administrators (admins) have all permissions and can perform any action in Mambu.',
            )
            .optional(),
        apiAccess: z
            .boolean()
            .describe(
                '`TRUE` if the API consumer can authenticate and interact with Mambu APIs, `FALSE` otherwise. The API consumer may still require additional permissions for specific API requests.',
            )
            .optional(),
        canManageAllBranches: z
            .boolean()
            .describe(
                '`TRUE` if the API consumer permissions apply to all branches, `FALSE` if they only apply to specific branches.',
            )
            .optional(),
        canManageEntitiesAssignedToOtherOfficers: z
            .boolean()
            .describe(
                '`TRUE` if the API consumer (that has the credit officer access) can access entities (for example, clients or accounts) assigned to other credit officers, `FALSE` otherwise.',
            )
            .optional(),
        creditOfficerAccess: z
            .boolean()
            .describe(
                '`TRUE` if the API consumer has the credit officer user type, `FALSE` otherwise. Credit officers have the option of having clients and groups assigned to them.',
            )
            .optional(),
        managedBranches: UserManagedBranch.array()
            .describe(
                'The list of branches that can be managed by the API consumer. If the API consumer has the `canManageAllBranches` property set to `TRUE`, this list does not apply.',
            )
            .optional(),
        permissions: z
            .enum([
                'AUDIT_TRANSACTIONS',
                'VIEW_EXCHANGE_RATES',
                'CREATE_EXCHANGE_RATE',
                'VIEW_LOAN_ACCOUNT_DETAILS',
                'CREATE_LOAN_ACCOUNT',
                'EDIT_LOAN_ACCOUNT',
                'APPROVE_LOANS',
                'DIBURSE_LOANS',
                'APPLY_LOAN_FEES',
                'ENTER_REPAYMENT',
                'EDIT_PLANNED_FEES',
                'EDIT_REPAYMENT_SCHEDULE',
                'APPLY_LOAN_ADJUSTMENTS',
                'BACKDATE_LOAN_TRANSACTIONS',
                'APPLY_ACCRUED_LOAN_INTEREST',
                'POST_TRANSACTIONS_ON_LOCKED_LOAN_ACCOUNTS',
                'EDIT_PENALTY_RATE',
                'VIEW_INVESTOR_FUNDS_DETAILS',
                'CREATE_INVESTOR_FUNDS',
                'EDIT_INVESTOR_FUNDS',
                'DELETE_INVESTOR_FUNDS',
                'SELL_LOAN_FRACTION',
                'REQUEST_LOAN_APPROVAL',
                'EDIT_LOAN_TRANCHES',
                'REJECT_LOANS',
                'WRITE_OFF_LOAN_ACCOUNTS',
                'PAY_OFF_LOAN',
                'REVERSE_LOAN_ACCOUNT_WRITE_OFF',
                'CLOSE_LOAN_ACCOUNTS',
                'LOCK_LOAN_ACCOUNTS',
                'WITHDRAW_LOAN_ACCOUNTS',
                'DELETE_LOAN_ACCOUNT',
                'SET_DISBURSEMENT_CONDITIONS',
                'RESCHEDULE_LOAN_ACCOUNT',
                'REFINANCE_LOAN_ACCOUNT',
                'EDIT_LOAN_TRANSACTIONS',
                'BULK_LOAN_CORRECTIONS',
                'EDIT_INTEREST_RATE',
                'EDIT_REPAYMENT_METHOD_VALUE',
                'EDIT_PERIODIC_PAYMENT_FOR_ACTIVE_ACCOUNT',
                'UNDO_LOAN_ACCOUNT_CLOSURE',
                'UNDO_REJECT_LOANS',
                'UNDO_WITHDRAW_LOAN_ACCOUNTS',
                'LINK_ACCOUNTS',
                'EDIT_PRINCIPAL_PAYMENT_ACTIVE_REVOLVING_CREDIT',
                'PERFORM_REPAYMENTS_WITH_CUSTOM_AMOUNTS_ALLOCATION',
                'MANAGE_LOAN_ASSOCIATION',
                'MAKE_WITHDRAWAL_REDRAW',
                'ENTER_REFUND',
                'VIEW_SAVINGS_ACCOUNT_DETAILS',
                'CREATE_SAVINGS_ACCOUNT',
                'EDIT_SAVINGS_ACCOUNT',
                'APPROVE_SAVINGS',
                'MAKE_DEPOSIT',
                'MAKE_BULK_DEPOSITS',
                'MAKE_WITHDRAWAL',
                'BACKDATE_SAVINGS_TRANSACTIONS',
                'APPLY_SAVINGS_ADJUSTMENTS',
                'MAKE_TRANSFER',
                'MAKE_INTER_CLIENTS_TRANSFERS',
                'CLOSE_SAVINGS_ACCOUNTS',
                'REOPEN_SAVINGS_ACCOUNT',
                'APPLY_SAVINGS_FEES',
                'DELETE_SAVINGS_ACCOUNT',
                'POST_TRANSACTIONS_ON_DORMANT_ACCOUNTS',
                'EDIT_SAVINGS_TRANSACTIONS',
                'BULK_DEPOSIT_CORRECTIONS',
                'ACTIVATE_MATURITY',
                'APPLY_ACCRUED_SAVINGS_INTEREST',
                'LOCK_SAVINGS_ACCOUNT',
                'UNLOCK_SAVINGS_ACCOUNT',
                'UNDO_MATURITY',
                'MAKE_EARLY_WITHDRAWALS',
                'BLOCK_AND_SEIZE_FUNDS',
                'WITHDRAW_BLOCKED_FUNDS',
                'MAKE_BULK_CHANGE_INTEREST_AVAILABILITY',
                'MANAGE_DEPOSIT_ACCOUNT_RECIPIENT',
                'MANAGE_DEPOSIT_ASSOCIATION',
                'BYPASS_ACCOUNT_OWNERSHIP_TRANSFER_VIEW_RESTRICTION',
                'CREATE_CARDS',
                'VIEW_CARDS',
                'DELETE_CARDS',
                'REVERSE_CARD_WITHDRAWAL_TRANSACTION',
                'CARD_BALANCE_INQUIRY',
                'CREATE_AUTHORIZATION_HOLD',
                'UPDATE_AUTHORIZATION_HOLD',
                'VIEW_AUTHORIZATION_HOLD',
                'CREATE_CARD_TRANSACTION',
                'CREATE_ACCOUNT_HOLD',
                'UPDATE_ACCOUNT_HOLD',
                'VIEW_ACCOUNT_HOLD',
                'VIEW_SECURITIES_DETAILS',
                'CREATE_SECURITIES',
                'EDIT_SECURITIES',
                'DELETE_SECURITIES',
                'CREATE_LINES_OF_CREDIT',
                'EDIT_LINES_OF_CREDIT',
                'VIEW_LINE_OF_CREDIT_DETAILS',
                'ADD_ACCOUNTS_TO_LINE_OF_CREDIT',
                'REMOVE_ACCOUNTS_FROM_LINE_OF_CREDIT',
                'APPROVE_LINE_OF_CREDIT',
                'UNDO_APPROVE_LINE_OF_CREDIT',
                'WITHDRAW_LINE_OF_CREDIT',
                'UNDO_WITHDRAW_LINE_OF_CREDIT',
                'REJECT_LINE_OF_CREDIT',
                'UNDO_REJECT_LINE_OF_CREDIT',
                'CLOSE_LINES_OF_CREDIT',
                'DELETE_LINES_OF_CREDIT',
                'VIEW_LOAN_PRODUCT_DETAILS',
                'CREATE_LOAN_PRODUCT',
                'DELETE_LOAN_PRODUCTS',
                'EDIT_LOAN_PRODUCT',
                'VIEW_SAVINGS_PRODUCT_DETAILS',
                'CREATE_SAVINGS_PRODUCT',
                'EDIT_SAVINGS_PRODUCT',
                'DELETE_SAVINGS_PRODUCT',
                'VIEW_CLIENT_DETAILS',
                'CREATE_CLIENT',
                'EDIT_CLIENT',
                'DELETE_CLIENTS',
                'VIEW_GROUP_DETAILS',
                'CREATE_GROUP',
                'EDIT_GROUP',
                'DELETE_GROUP',
                'CHANGE_CLIENT_TYPE',
                'CHANGE_GROUP_TYPE',
                'APPROVE_CLIENT',
                'REJECT_CLIENT',
                'EXIT_CLIENT',
                'BLACKLIST_CLIENT',
                'UNDO_CLIENT_STATE_CHANGED',
                'ANONYMIZE_CLIENT',
                'MANAGE_CLIENT_ASSOCIATION',
                'MANAGE_GROUP_ASSOCIATION',
                'EDIT_CLIENT_ID',
                'EDIT_GROUP_ID',
                'EDIT_BLACKLISTED_CLIENT_CFV',
                'VIEW_ACCOUNTING_REPORTS',
                'LOG_JOURNAL_ENTRIES',
                'BOOKING_DATE_LOANS_GL',
                'BOOKING_DATE_SAVINGS_GL',
                'RECTIFY_ADJUSTMENT',
                'VIEW_ACCOUNTING_RATES',
                'CREATE_ACCOUNTING_RATES',
                'VIEW_DOCUMENTS',
                'CREATE_DOCUMENTS',
                'EDIT_DOCUMENTS',
                'DELETE_DOCUMENTS',
                'VIEW_TASK',
                'CREATE_TASK',
                'EDIT_TASK',
                'DELETE_TASK',
                'VIEW_USER_DETAILS',
                'CREATE_USER',
                'EDIT_USER',
                'DELETE_USER',
                'VIEW_ROLE',
                'CREATE_ROLE',
                'EDIT_ROLE',
                'DELETE_ROLE',
                'RESEND_FAILED_MESSAGES',
                'SEND_MANUAL_SMS',
                'SEND_MANUAL_EMAIL',
                'GET_MANAGE_CONFIGURATION_AS_CODE',
                'PUT_MANAGE_CONFIGURATION_AS_CODE',
                'MANAGE_RISK_LEVELS',
                'MANAGE_EOD_PROCESSING',
                'MANAGE_CURRENCIES',
                'VIEW_INTELLIGENCE',
                'CREATE_INDEX_RATE',
                'VIEW_COMMENTS',
                'CREATE_COMMENTS',
                'EDIT_COMMENTS',
                'VIEW_COMMUNICATION_HISTORY',
                'DOWNLOAD_BACKUPS',
                'IMPORT_DATA',
                'VIEW_TRANSACTION_CHANNELS',
                'CREATE_TRANSACTION_CHANNELS',
                'EDIT_TRANSACTION_CHANNELS',
                'DELETE_TRANSACTION_CHANNELS',
                'POST_TRANSACTIONS_WITHOUT_OPENED_TILL',
                'VIEW_CUSTOM_FIELD',
                'VIEW_BRANCH_DETAILS',
                'CREATE_BRANCH',
                'EDIT_BRANCH',
                'VIEW_CENTRE_DETAILS',
                'CREATE_CENTRE',
                'EDIT_CENTRE',
                'DELETE_CENTRE',
                'MANAGE_HOLIDAYS',
                'MANAGE_INDEX_RATES',
                'MANAGE_EVENTS_STREAMING',
                'MANAGE_AUDIT_TRAIL',
                'MANAGE_PAYMENTS',
                'MANAGE_CARDS_CAPABILITY',
                'CREATE_API_CONSUMERS_AND_KEYS',
                'DELETE_API_CONSUMERS_AND_KEYS',
                'EDIT_API_CONSUMERS_AND_KEYS',
                'VIEW_API_CONSUMERS_AND_KEYS',
                'MANAGE_NOTIFICATIONS',
                'VIEW_MAMBU_FUNCTIONS',
                'CREATE_MAMBU_FUNCTIONS',
                'EDIT_MAMBU_FUNCTIONS',
                'DELETE_MAMBU_FUNCTIONS',
                'VIEW_MAMBU_FUNCTIONS_SECRETS',
                'CREATE_MAMBU_FUNCTIONS_SECRETS',
                'EDIT_MAMBU_FUNCTIONS_SECRETS',
                'DELETE_MAMBU_FUNCTIONS_SECRETS',
                'VIEW_PROFIT_SHARING_PROPOSALS',
                'CREATE_PROFIT_SHARING_CASH_FLOWS',
                'VIEW_PROFIT_SHARING_CASH_FLOWS',
                'EDIT_PROFIT_SHARING_CASH_FLOWS',
                'DELETE_PROFIT_SHARING_CASH_FLOWS',
                'CREATE_PROFIT_SHARING_POOLS',
                'VIEW_PROFIT_SHARING_POOLS',
                'EDIT_PROFIT_SHARING_POOLS',
                'DELETE_PROFIT_SHARING_POOLS',
                'CREATE_PROFIT_SHARING_PRODUCT_SETTINGS',
                'VIEW_PROFIT_SHARING_PRODUCT_SETTINGS',
                'EDIT_PROFIT_SHARING_PRODUCT_SETTINGS',
                'DELETE_PROFIT_SHARING_PRODUCT_SETTINGS',
                'CREATE_RATE_SHEET',
                'VIEW_RATE_SHEET',
            ])
            .array()
            .describe(
                'Permissions for the API consumer. The non-admin API consumers and users are authorized to do actions based a set of permissions in order to access Mambu features. Permissions may be relevant for the API and/or the Mambu UI.',
            )
            .optional(),
    })
    .describe('Represents the API consumer permissions and access rights.')

export type ApiConsumerAccess = z.infer<typeof ApiConsumerAccess>

export const Constraint = z
    .object({
        constraints: TransactionChannelConstraint.array()
            .describe(
                'Holds the custom constraints, only for the limited usage case. For the unconstrainedcase, no constraints are applied',
            )
            .optional(),
        matchFiltersOption: z
            .enum(['ALL', 'ANY'])
            .describe(
                'Holds the match filter option for the constraints. It can be ALL so all the constraints must match, or ANY so at least one must match',
            )
            .optional(),
        usage: z
            .enum(['UNCONSTRAINED', 'LIMITED'])
            .describe('States the limited/unconstrained usage of the transaction channel')
            .optional(),
    })
    .describe('The constraints applied to the transaction channel')

export type Constraint = z.infer<typeof Constraint>

export const BaseUserAccess = z
    .object({
        administratorAccess: z
            .boolean()
            .describe(
                '`TRUE` if the user has the administrator user type, `FALSE` otherwise. Administrators (admins) have all permissions and can perform any action in Mambu.',
            )
            .optional(),
        apiAccess: z
            .boolean()
            .describe(
                '`TRUE` if the user can authenticate and interact with Mambu APIs, `FALSE` otherwise. The user may still require additional permissions for specific API requests.',
            )
            .optional(),
        creditOfficerAccess: z
            .boolean()
            .describe(
                '`TRUE` if the user has the credit officer user type, `FALSE` otherwise. Credit officers have the option of having clients and groups assigned to them.',
            )
            .optional(),
        deliveryAccess: z
            .boolean()
            .describe('`TRUE` if the user is part of the Mambu delivery team, `FALSE` otherwise.')
            .optional(),
        mambuAccess: z
            .boolean()
            .describe('TRUE` if the user can log in to the Mambu UI using their login credentials, `FALSE` otherwise.')
            .optional(),
        permissions: z
            .enum([
                'AUDIT_TRANSACTIONS',
                'VIEW_COMMENTS',
                'CREATE_COMMENTS',
                'EDIT_COMMENTS',
                'DELETE_COMMENTS',
                'CREATE_INDEX_RATE',
                'DOWNLOAD_BACKUPS',
                'IMPORT_DATA',
                'VIEW_BACKGROUND_TASKS',
                'VIEW_EXCHANGE_RATES',
                'CREATE_EXCHANGE_RATE',
                'VIEW_CENTRE_DETAILS',
                'CREATE_CENTRE',
                'EDIT_CENTRE',
                'DELETE_CENTRE',
                'MANAGE_CONFIGURATION_AS_CODE',
                'GET_MANAGE_CONFIGURATION_AS_CODE',
                'PUT_MANAGE_CONFIGURATION_AS_CODE',
                'VIEW_BRANCH_DETAILS',
                'CREATE_BRANCH',
                'EDIT_BRANCH',
                'CREATE_COMMUNICATION_TEMPLATES',
                'EDIT_COMMUNICATION_TEMPLATES',
                'SEND_MANUAL_SMS',
                'SEND_MANUAL_EMAIL',
                'VIEW_COMMUNICATION_HISTORY',
                'RESEND_FAILED_MESSAGES',
                'VIEW_TRANSACTION_CHANNELS',
                'CREATE_TRANSACTION_CHANNELS',
                'EDIT_TRANSACTION_CHANNELS',
                'DELETE_TRANSACTION_CHANNELS',
                'MANAGE_HOLIDAYS',
                'MANAGE_INDEX_RATES',
                'MANAGE_EOD_PROCESSING',
                'MANAGE_INTERNAL_CONTROLS',
                'MANAGE_CURRENCIES',
                'MANAGE_AUTHORIZATION_HOLDS_SETUP',
                'MANAGE_RISK_LEVELS',
                'VIEW_LOAN_PRODUCT_DETAILS',
                'CREATE_LOAN_PRODUCT',
                'EDIT_LOAN_PRODUCT',
                'DELETE_LOAN_PRODUCTS',
                'VIEW_SAVINGS_PRODUCT_DETAILS',
                'CREATE_SAVINGS_PRODUCT',
                'EDIT_SAVINGS_PRODUCT',
                'DELETE_SAVINGS_PRODUCT',
                'CREATE_PRODUCT_DOCUMENT_TEMPLATES',
                'EDIT_PRODUCT_DOCUMENT_TEMPLATES',
                'DELETE_PRODUCT_DOCUMENT_TEMPLATES',
                'VIEW_CLIENT_DETAILS',
                'CREATE_CLIENT',
                'EDIT_CLIENT',
                'DELETE_CLIENTS',
                'APPROVE_CLIENT',
                'REJECT_CLIENT',
                'EXIT_CLIENT',
                'ANONYMIZE_CLIENT',
                'BLACKLIST_CLIENT',
                'UNDO_CLIENT_STATE_CHANGED',
                'EDIT_CLIENT_ID',
                'EDIT_BLACKLISTED_CLIENT_CFV',
                'EDIT_GROUP_ID',
                'CHANGE_CLIENT_TYPE',
                'VIEW_GROUP_DETAILS',
                'CREATE_GROUP',
                'EDIT_GROUP',
                'DELETE_GROUP',
                'CHANGE_GROUP_TYPE',
                'VIEW_LINE_OF_CREDIT_DETAILS',
                'CREATE_LINES_OF_CREDIT',
                'EDIT_LINES_OF_CREDIT',
                'ADD_ACCOUNTS_TO_LINE_OF_CREDIT',
                'REMOVE_ACCOUNTS_FROM_LINE_OF_CREDIT',
                'APPROVE_LINE_OF_CREDIT',
                'UNDO_APPROVE_LINE_OF_CREDIT',
                'WITHDRAW_LINE_OF_CREDIT',
                'UNDO_WITHDRAW_LINE_OF_CREDIT',
                'REJECT_LINE_OF_CREDIT',
                'UNDO_REJECT_LINE_OF_CREDIT',
                'CLOSE_LINES_OF_CREDIT',
                'DELETE_LINES_OF_CREDIT',
                'VIEW_LOAN_ACCOUNT_DETAILS',
                'CREATE_LOAN_ACCOUNT',
                'EDIT_LOAN_ACCOUNT',
                'DELETE_LOAN_ACCOUNT',
                'ENTER_REPAYMENT',
                'EDIT_REPAYMENT_SCHEDULE',
                'APPROVE_LOANS',
                'REQUEST_LOAN_APPROVAL',
                'DIBURSE_LOANS',
                'WITHDRAW_LOAN_ACCOUNTS',
                'UNDO_WITHDRAW_LOAN_ACCOUNTS',
                'SET_LOAN_INCOMPLETE',
                'REJECT_LOANS',
                'UNDO_REJECT_LOANS',
                'CLOSE_LOAN_ACCOUNTS',
                'WRITE_OFF_LOAN_ACCOUNTS',
                'TERMINATE_LOAN_ACCOUNTS',
                'PAY_OFF_LOAN',
                'UNDO_LOAN_ACCOUNT_CLOSURE',
                'REVERSE_LOAN_ACCOUNT_WRITE_OFF',
                'REFINANCE_LOAN_ACCOUNT',
                'RESCHEDULE_LOAN_ACCOUNT',
                'APPLY_ACCRUED_LOAN_INTEREST',
                'APPLY_LOAN_FEES',
                'APPLY_LOAN_ADJUSTMENTS',
                'EDIT_PLANNED_FEES',
                'BACKDATE_LOAN_TRANSACTIONS',
                'LINK_ACCOUNTS',
                'COLLECT_GUARANTIES',
                'VIEW_SECURITIES_DETAILS',
                'CREATE_SECURITIES',
                'EDIT_SECURITIES',
                'DELETE_SECURITIES',
                'LOCK_LOAN_ACCOUNTS',
                'POST_TRANSACTIONS_ON_LOCKED_LOAN_ACCOUNTS',
                'EDIT_LOAN_TRANCHES',
                'EDIT_PENALTY_RATE',
                'SET_DISBURSEMENT_CONDITIONS',
                'EDIT_LOAN_TRANSACTIONS',
                'BULK_LOAN_CORRECTIONS',
                'EDIT_INTEREST_RATE',
                'EDIT_REPAYMENT_METHOD_VALUE',
                'EDIT_PERIODIC_PAYMENT_FOR_ACTIVE_ACCOUNT',
                'MANAGE_LOAN_ASSOCIATION',
                'MAKE_WITHDRAWAL_REDRAW',
                'ENTER_REFUND',
                'VIEW_SAVINGS_ACCOUNT_DETAILS',
                'CREATE_SAVINGS_ACCOUNT',
                'EDIT_SAVINGS_ACCOUNT',
                'DELETE_SAVINGS_ACCOUNT',
                'MAKE_DEPOSIT',
                'MAKE_BULK_DEPOSITS',
                'MAKE_WITHDRAWAL',
                'MAKE_EARLY_WITHDRAWALS',
                'APPROVE_SAVINGS',
                'ACTIVATE_MATURITY',
                'UNDO_MATURITY',
                'CLOSE_SAVINGS_ACCOUNTS',
                'APPLY_SAVINGS_FEES',
                'REOPEN_SAVINGS_ACCOUNT',
                'APPLY_SAVINGS_ADJUSTMENTS',
                'LOCK_SAVINGS_ACCOUNT',
                'UNLOCK_SAVINGS_ACCOUNT',
                'REVERSE_SAVINGS_ACCOUNT_WRITE_OFF',
                'BACKDATE_SAVINGS_TRANSACTIONS',
                'MAKE_TRANSFER',
                'MAKE_INTER_CLIENTS_TRANSFERS',
                'POST_TRANSACTIONS_ON_DORMANT_ACCOUNTS',
                'APPLY_ACCRUED_SAVINGS_INTEREST',
                'EDIT_SAVINGS_TRANSACTIONS',
                'BULK_DEPOSIT_CORRECTIONS',
                'BLOCK_AND_SEIZE_FUNDS',
                'WITHDRAW_BLOCKED_FUNDS',
                'MANAGE_DEPOSIT_ACCOUNT_RECIPIENT',
                'MANAGE_DEPOSIT_ASSOCIATION',
                'BYPASS_ACCOUNT_OWNERSHIP_TRANSFER_VIEW_RESTRICTION',
                'CREATE_CARDS',
                'VIEW_CARDS',
                'DELETE_CARDS',
                'REVERSE_CARD_WITHDRAWAL_TRANSACTION',
                'REVERSE_CARD_TRANSACTION',
                'CARD_BALANCE_INQUIRY',
                'CREATE_AUTHORIZATION_HOLD',
                'UPDATE_AUTHORIZATION_HOLD',
                'VIEW_AUTHORIZATION_HOLD',
                'CREATE_CARD_TRANSACTION',
                'CREATE_ACCOUNT_HOLD',
                'UPDATE_ACCOUNT_HOLD',
                'VIEW_ACCOUNT_HOLD',
                'VIEW_DOCUMENTS',
                'CREATE_DOCUMENTS',
                'EDIT_DOCUMENTS',
                'DELETE_DOCUMENTS',
                'VIEW_TASK',
                'CREATE_TASK',
                'EDIT_TASK',
                'DELETE_TASK',
                'VIEW_INTELLIGENCE',
                'VIEW_REPORTS',
                'CREATE_REPORTS',
                'EDIT_REPORTS',
                'DELETE_REPORTS',
                'VIEW_JASPER_REPORTS',
                'CREATE_JASPER_REPORTS',
                'EDIT_JASPER_REPORTS',
                'DELETE_JASPER_REPORTS',
                'VIEW_CHART_OF_ACCOUNTS',
                'MANAGE_ACCOUNTS',
                'VIEW_JOURNAL_ENTRIES',
                'LOG_JOURNAL_ENTRIES',
                'VIEW_ACCOUNTING_REPORTS',
                'MAKE_ACCOUNTING_CLOSURE',
                'APPLY_ACCOUNTING_ADJUSTMENTS',
                'BOOKING_DATE_LOANS_GL',
                'BOOKING_DATE_SAVINGS_GL',
                'RECTIFY_ADJUSTMENT',
                'MANAGE_INTERBRANCH_GLACCOUNT_RULES',
                'VIEW_ACCOUNTING_RATES',
                'CREATE_ACCOUNTING_RATES',
                'OPEN_TILL',
                'CLOSE_TILL',
                'ADD_CASH',
                'REMOVE_CASH',
                'POST_TRANSACTIONS_WITHOUT_OPENED_TILL',
                'VIEW_INVESTOR_FUNDS_DETAILS',
                'CREATE_INVESTOR_FUNDS',
                'EDIT_INVESTOR_FUNDS',
                'DELETE_INVESTOR_FUNDS',
                'SELL_LOAN_FRACTION',
                'CREATE_USER',
                'EDIT_USER',
                'VIEW_USER_DETAILS',
                'DELETE_USER',
                'MANAGE_TWO_FACTOR_AUTHENTICATION',
                'MANAGE_CLIENT_ASSOCIATION',
                'MANAGE_GROUP_ASSOCIATION',
                'EDIT_PRINCIPAL_PAYMENT_ACTIVE_REVOLVING_CREDIT',
                'PERFORM_REPAYMENTS_WITH_CUSTOM_AMOUNTS_ALLOCATION',
                'EXPORT_TO_EXCEL',
                'VIEW_ADMINISTRATION_DETAILS',
                'MANAGE_EVENTS_STREAMING',
                'MANAGE_PAYMENTS',
                'MANAGE_AUDIT_TRAIL',
                'MANAGE_APPS',
                'MANAGE_CARDS_CAPABILITY',
                'MANAGE_NOTIFICATIONS',
                'ADMIN',
                'CREATE_ROLE',
                'EDIT_ROLE',
                'DELETE_ROLE',
                'VIEW_ROLE',
                'MANAGE_FEDERATED_AUTHENTICATION',
                'MANAGE_ACCESS_PREFERENCES',
                'VIEW_API_CONSUMERS_AND_KEYS',
                'CREATE_API_CONSUMERS_AND_KEYS',
                'EDIT_API_CONSUMERS_AND_KEYS',
                'DELETE_API_CONSUMERS_AND_KEYS',
                'VIEW_CUSTOM_FIELD',
                'CREATE_CUSTOM_FIELD',
                'EDIT_CUSTOM_FIELD',
                'DELETE_CUSTOM_FIELD',
                'VIEW_MAMBU_FUNCTIONS',
                'CREATE_MAMBU_FUNCTIONS',
                'EDIT_MAMBU_FUNCTIONS',
                'DELETE_MAMBU_FUNCTIONS',
                'VIEW_MAMBU_FUNCTIONS_SECRETS',
                'CREATE_MAMBU_FUNCTIONS_SECRETS',
                'EDIT_MAMBU_FUNCTIONS_SECRETS',
                'DELETE_MAMBU_FUNCTIONS_SECRETS',
                'VIEW_PROFIT_SHARING_PROPOSALS',
                'CREATE_PROFIT_SHARING_CASH_FLOWS',
                'VIEW_PROFIT_SHARING_CASH_FLOWS',
                'EDIT_PROFIT_SHARING_CASH_FLOWS',
                'DELETE_PROFIT_SHARING_CASH_FLOWS',
                'CREATE_PROFIT_SHARING_POOLS',
                'VIEW_PROFIT_SHARING_POOLS',
                'EDIT_PROFIT_SHARING_POOLS',
                'DELETE_PROFIT_SHARING_POOLS',
                'CREATE_PROFIT_SHARING_PRODUCT_SETTINGS',
                'VIEW_PROFIT_SHARING_PRODUCT_SETTINGS',
                'EDIT_PROFIT_SHARING_PRODUCT_SETTINGS',
                'DELETE_PROFIT_SHARING_PRODUCT_SETTINGS',
                'MAKE_BULK_CHANGE_INTEREST_AVAILABILITY',
                'CREATE_RATE_SHEET',
                'VIEW_RATE_SHEET',
            ])
            .array()
            .describe(
                'Permissions for the user. The non-admin users are authorized to do actions based a set of permissions in order to access Mambu features. Permissions may be relevant for the API and/or the Mambu UI.',
            )
            .optional(),
        supportAccess: z
            .boolean()
            .describe('`TRUE` if the user can provide Mambu technical support, `FALSE` otherwise.')
            .optional(),
        tellerAccess: z
            .boolean()
            .describe(
                '`TRUE` if the user has the teller user type, `FALSE` otherwise. Tellers have access to the teller module and specific tellering permissions, which allow them to take actions such as opening or closing tills, posting transactions on a till, and adding and removing cash from a till.',
            )
            .optional(),
    })
    .describe('Represents the user permissions and access rights.')

export type BaseUserAccess = z.infer<typeof BaseUserAccess>

export const UserAccess = z
    .object({
        administratorAccess: z
            .boolean()
            .describe(
                '`TRUE` if the user has the administrator user type, `FALSE` otherwise. Administrators (admins) have all permissions and can perform any action in Mambu.',
            )
            .optional(),
        apiAccess: z
            .boolean()
            .describe(
                '`TRUE` if the user can authenticate and interact with Mambu APIs, `FALSE` otherwise. The user may still require additional permissions for specific API requests.',
            )
            .optional(),
        canManageAllBranches: z
            .boolean()
            .describe('`TRUE` if the user has access to all branches, `FALSE` if the user only has access to specific branches.'),
        canManageEntitiesAssignedToOtherOfficers: z
            .boolean()
            .describe(
                '`TRUE` if a credit officer user can access entities (for example, clients or accounts) assigned to other credit officers, `FALSE` otherwise.',
            ),
        creditOfficerAccess: z
            .boolean()
            .describe(
                '`TRUE` if the user has the credit officer user type, `FALSE` otherwise. Credit officers have the option of having clients and groups assigned to them.',
            )
            .optional(),
        deliveryAccess: z
            .boolean()
            .describe('`TRUE` if the user is part of the Mambu delivery team, `FALSE` otherwise.')
            .optional(),
        mambuAccess: z
            .boolean()
            .describe('TRUE` if the user can log in to the Mambu UI using their login credentials, `FALSE` otherwise.')
            .optional(),
        managedBranches: UserManagedBranch.array()
            .describe(
                'The list of branches that can be managed by the user. If the user has the `canManageAllBranches` property set to `TRUE`, this list does not apply.',
            )
            .optional(),
        permissions: z
            .enum([
                'AUDIT_TRANSACTIONS',
                'VIEW_COMMENTS',
                'CREATE_COMMENTS',
                'EDIT_COMMENTS',
                'DELETE_COMMENTS',
                'CREATE_INDEX_RATE',
                'DOWNLOAD_BACKUPS',
                'IMPORT_DATA',
                'VIEW_BACKGROUND_TASKS',
                'VIEW_EXCHANGE_RATES',
                'CREATE_EXCHANGE_RATE',
                'VIEW_CENTRE_DETAILS',
                'CREATE_CENTRE',
                'EDIT_CENTRE',
                'DELETE_CENTRE',
                'MANAGE_CONFIGURATION_AS_CODE',
                'GET_MANAGE_CONFIGURATION_AS_CODE',
                'PUT_MANAGE_CONFIGURATION_AS_CODE',
                'VIEW_BRANCH_DETAILS',
                'CREATE_BRANCH',
                'EDIT_BRANCH',
                'CREATE_COMMUNICATION_TEMPLATES',
                'EDIT_COMMUNICATION_TEMPLATES',
                'SEND_MANUAL_SMS',
                'SEND_MANUAL_EMAIL',
                'VIEW_COMMUNICATION_HISTORY',
                'RESEND_FAILED_MESSAGES',
                'VIEW_TRANSACTION_CHANNELS',
                'CREATE_TRANSACTION_CHANNELS',
                'EDIT_TRANSACTION_CHANNELS',
                'DELETE_TRANSACTION_CHANNELS',
                'MANAGE_HOLIDAYS',
                'MANAGE_INDEX_RATES',
                'MANAGE_EOD_PROCESSING',
                'MANAGE_INTERNAL_CONTROLS',
                'MANAGE_CURRENCIES',
                'MANAGE_AUTHORIZATION_HOLDS_SETUP',
                'MANAGE_RISK_LEVELS',
                'VIEW_LOAN_PRODUCT_DETAILS',
                'CREATE_LOAN_PRODUCT',
                'EDIT_LOAN_PRODUCT',
                'DELETE_LOAN_PRODUCTS',
                'VIEW_SAVINGS_PRODUCT_DETAILS',
                'CREATE_SAVINGS_PRODUCT',
                'EDIT_SAVINGS_PRODUCT',
                'DELETE_SAVINGS_PRODUCT',
                'CREATE_PRODUCT_DOCUMENT_TEMPLATES',
                'EDIT_PRODUCT_DOCUMENT_TEMPLATES',
                'DELETE_PRODUCT_DOCUMENT_TEMPLATES',
                'VIEW_CLIENT_DETAILS',
                'CREATE_CLIENT',
                'EDIT_CLIENT',
                'DELETE_CLIENTS',
                'APPROVE_CLIENT',
                'REJECT_CLIENT',
                'EXIT_CLIENT',
                'ANONYMIZE_CLIENT',
                'BLACKLIST_CLIENT',
                'UNDO_CLIENT_STATE_CHANGED',
                'EDIT_CLIENT_ID',
                'EDIT_BLACKLISTED_CLIENT_CFV',
                'EDIT_GROUP_ID',
                'CHANGE_CLIENT_TYPE',
                'VIEW_GROUP_DETAILS',
                'CREATE_GROUP',
                'EDIT_GROUP',
                'DELETE_GROUP',
                'CHANGE_GROUP_TYPE',
                'VIEW_LINE_OF_CREDIT_DETAILS',
                'CREATE_LINES_OF_CREDIT',
                'EDIT_LINES_OF_CREDIT',
                'ADD_ACCOUNTS_TO_LINE_OF_CREDIT',
                'REMOVE_ACCOUNTS_FROM_LINE_OF_CREDIT',
                'APPROVE_LINE_OF_CREDIT',
                'UNDO_APPROVE_LINE_OF_CREDIT',
                'WITHDRAW_LINE_OF_CREDIT',
                'UNDO_WITHDRAW_LINE_OF_CREDIT',
                'REJECT_LINE_OF_CREDIT',
                'UNDO_REJECT_LINE_OF_CREDIT',
                'CLOSE_LINES_OF_CREDIT',
                'DELETE_LINES_OF_CREDIT',
                'VIEW_LOAN_ACCOUNT_DETAILS',
                'CREATE_LOAN_ACCOUNT',
                'EDIT_LOAN_ACCOUNT',
                'DELETE_LOAN_ACCOUNT',
                'ENTER_REPAYMENT',
                'EDIT_REPAYMENT_SCHEDULE',
                'APPROVE_LOANS',
                'REQUEST_LOAN_APPROVAL',
                'DIBURSE_LOANS',
                'WITHDRAW_LOAN_ACCOUNTS',
                'UNDO_WITHDRAW_LOAN_ACCOUNTS',
                'SET_LOAN_INCOMPLETE',
                'REJECT_LOANS',
                'UNDO_REJECT_LOANS',
                'CLOSE_LOAN_ACCOUNTS',
                'WRITE_OFF_LOAN_ACCOUNTS',
                'TERMINATE_LOAN_ACCOUNTS',
                'PAY_OFF_LOAN',
                'UNDO_LOAN_ACCOUNT_CLOSURE',
                'REVERSE_LOAN_ACCOUNT_WRITE_OFF',
                'REFINANCE_LOAN_ACCOUNT',
                'RESCHEDULE_LOAN_ACCOUNT',
                'APPLY_ACCRUED_LOAN_INTEREST',
                'APPLY_LOAN_FEES',
                'APPLY_LOAN_ADJUSTMENTS',
                'EDIT_PLANNED_FEES',
                'BACKDATE_LOAN_TRANSACTIONS',
                'LINK_ACCOUNTS',
                'COLLECT_GUARANTIES',
                'VIEW_SECURITIES_DETAILS',
                'CREATE_SECURITIES',
                'EDIT_SECURITIES',
                'DELETE_SECURITIES',
                'LOCK_LOAN_ACCOUNTS',
                'POST_TRANSACTIONS_ON_LOCKED_LOAN_ACCOUNTS',
                'EDIT_LOAN_TRANCHES',
                'EDIT_PENALTY_RATE',
                'SET_DISBURSEMENT_CONDITIONS',
                'EDIT_LOAN_TRANSACTIONS',
                'BULK_LOAN_CORRECTIONS',
                'EDIT_INTEREST_RATE',
                'EDIT_REPAYMENT_METHOD_VALUE',
                'EDIT_PERIODIC_PAYMENT_FOR_ACTIVE_ACCOUNT',
                'MANAGE_LOAN_ASSOCIATION',
                'MAKE_WITHDRAWAL_REDRAW',
                'ENTER_REFUND',
                'VIEW_SAVINGS_ACCOUNT_DETAILS',
                'CREATE_SAVINGS_ACCOUNT',
                'EDIT_SAVINGS_ACCOUNT',
                'DELETE_SAVINGS_ACCOUNT',
                'MAKE_DEPOSIT',
                'MAKE_BULK_DEPOSITS',
                'MAKE_WITHDRAWAL',
                'MAKE_EARLY_WITHDRAWALS',
                'APPROVE_SAVINGS',
                'ACTIVATE_MATURITY',
                'UNDO_MATURITY',
                'CLOSE_SAVINGS_ACCOUNTS',
                'APPLY_SAVINGS_FEES',
                'REOPEN_SAVINGS_ACCOUNT',
                'APPLY_SAVINGS_ADJUSTMENTS',
                'LOCK_SAVINGS_ACCOUNT',
                'UNLOCK_SAVINGS_ACCOUNT',
                'REVERSE_SAVINGS_ACCOUNT_WRITE_OFF',
                'BACKDATE_SAVINGS_TRANSACTIONS',
                'MAKE_TRANSFER',
                'MAKE_INTER_CLIENTS_TRANSFERS',
                'POST_TRANSACTIONS_ON_DORMANT_ACCOUNTS',
                'APPLY_ACCRUED_SAVINGS_INTEREST',
                'EDIT_SAVINGS_TRANSACTIONS',
                'BULK_DEPOSIT_CORRECTIONS',
                'BLOCK_AND_SEIZE_FUNDS',
                'WITHDRAW_BLOCKED_FUNDS',
                'MANAGE_DEPOSIT_ACCOUNT_RECIPIENT',
                'MANAGE_DEPOSIT_ASSOCIATION',
                'BYPASS_ACCOUNT_OWNERSHIP_TRANSFER_VIEW_RESTRICTION',
                'CREATE_CARDS',
                'VIEW_CARDS',
                'DELETE_CARDS',
                'REVERSE_CARD_WITHDRAWAL_TRANSACTION',
                'REVERSE_CARD_TRANSACTION',
                'CARD_BALANCE_INQUIRY',
                'CREATE_AUTHORIZATION_HOLD',
                'UPDATE_AUTHORIZATION_HOLD',
                'VIEW_AUTHORIZATION_HOLD',
                'CREATE_CARD_TRANSACTION',
                'CREATE_ACCOUNT_HOLD',
                'UPDATE_ACCOUNT_HOLD',
                'VIEW_ACCOUNT_HOLD',
                'VIEW_DOCUMENTS',
                'CREATE_DOCUMENTS',
                'EDIT_DOCUMENTS',
                'DELETE_DOCUMENTS',
                'VIEW_TASK',
                'CREATE_TASK',
                'EDIT_TASK',
                'DELETE_TASK',
                'VIEW_INTELLIGENCE',
                'VIEW_REPORTS',
                'CREATE_REPORTS',
                'EDIT_REPORTS',
                'DELETE_REPORTS',
                'VIEW_JASPER_REPORTS',
                'CREATE_JASPER_REPORTS',
                'EDIT_JASPER_REPORTS',
                'DELETE_JASPER_REPORTS',
                'VIEW_CHART_OF_ACCOUNTS',
                'MANAGE_ACCOUNTS',
                'VIEW_JOURNAL_ENTRIES',
                'LOG_JOURNAL_ENTRIES',
                'VIEW_ACCOUNTING_REPORTS',
                'MAKE_ACCOUNTING_CLOSURE',
                'APPLY_ACCOUNTING_ADJUSTMENTS',
                'BOOKING_DATE_LOANS_GL',
                'BOOKING_DATE_SAVINGS_GL',
                'RECTIFY_ADJUSTMENT',
                'MANAGE_INTERBRANCH_GLACCOUNT_RULES',
                'VIEW_ACCOUNTING_RATES',
                'CREATE_ACCOUNTING_RATES',
                'OPEN_TILL',
                'CLOSE_TILL',
                'ADD_CASH',
                'REMOVE_CASH',
                'POST_TRANSACTIONS_WITHOUT_OPENED_TILL',
                'VIEW_INVESTOR_FUNDS_DETAILS',
                'CREATE_INVESTOR_FUNDS',
                'EDIT_INVESTOR_FUNDS',
                'DELETE_INVESTOR_FUNDS',
                'SELL_LOAN_FRACTION',
                'CREATE_USER',
                'EDIT_USER',
                'VIEW_USER_DETAILS',
                'DELETE_USER',
                'MANAGE_TWO_FACTOR_AUTHENTICATION',
                'MANAGE_CLIENT_ASSOCIATION',
                'MANAGE_GROUP_ASSOCIATION',
                'EDIT_PRINCIPAL_PAYMENT_ACTIVE_REVOLVING_CREDIT',
                'PERFORM_REPAYMENTS_WITH_CUSTOM_AMOUNTS_ALLOCATION',
                'EXPORT_TO_EXCEL',
                'VIEW_ADMINISTRATION_DETAILS',
                'MANAGE_EVENTS_STREAMING',
                'MANAGE_PAYMENTS',
                'MANAGE_AUDIT_TRAIL',
                'MANAGE_APPS',
                'MANAGE_CARDS_CAPABILITY',
                'MANAGE_NOTIFICATIONS',
                'ADMIN',
                'CREATE_ROLE',
                'EDIT_ROLE',
                'DELETE_ROLE',
                'VIEW_ROLE',
                'MANAGE_FEDERATED_AUTHENTICATION',
                'MANAGE_ACCESS_PREFERENCES',
                'VIEW_API_CONSUMERS_AND_KEYS',
                'CREATE_API_CONSUMERS_AND_KEYS',
                'EDIT_API_CONSUMERS_AND_KEYS',
                'DELETE_API_CONSUMERS_AND_KEYS',
                'VIEW_CUSTOM_FIELD',
                'CREATE_CUSTOM_FIELD',
                'EDIT_CUSTOM_FIELD',
                'DELETE_CUSTOM_FIELD',
                'VIEW_MAMBU_FUNCTIONS',
                'CREATE_MAMBU_FUNCTIONS',
                'EDIT_MAMBU_FUNCTIONS',
                'DELETE_MAMBU_FUNCTIONS',
                'VIEW_MAMBU_FUNCTIONS_SECRETS',
                'CREATE_MAMBU_FUNCTIONS_SECRETS',
                'EDIT_MAMBU_FUNCTIONS_SECRETS',
                'DELETE_MAMBU_FUNCTIONS_SECRETS',
                'VIEW_PROFIT_SHARING_PROPOSALS',
                'CREATE_PROFIT_SHARING_CASH_FLOWS',
                'VIEW_PROFIT_SHARING_CASH_FLOWS',
                'EDIT_PROFIT_SHARING_CASH_FLOWS',
                'DELETE_PROFIT_SHARING_CASH_FLOWS',
                'CREATE_PROFIT_SHARING_POOLS',
                'VIEW_PROFIT_SHARING_POOLS',
                'EDIT_PROFIT_SHARING_POOLS',
                'DELETE_PROFIT_SHARING_POOLS',
                'CREATE_PROFIT_SHARING_PRODUCT_SETTINGS',
                'VIEW_PROFIT_SHARING_PRODUCT_SETTINGS',
                'EDIT_PROFIT_SHARING_PRODUCT_SETTINGS',
                'DELETE_PROFIT_SHARING_PRODUCT_SETTINGS',
                'MAKE_BULK_CHANGE_INTEREST_AVAILABILITY',
                'CREATE_RATE_SHEET',
                'VIEW_RATE_SHEET',
            ])
            .array()
            .describe(
                'Permissions for the user. The non-admin users are authorized to do actions based a set of permissions in order to access Mambu features. Permissions may be relevant for the API and/or the Mambu UI.',
            )
            .optional(),
        supportAccess: z
            .boolean()
            .describe('`TRUE` if the user can provide Mambu technical support, `FALSE` otherwise.')
            .optional(),
        tellerAccess: z
            .boolean()
            .describe(
                '`TRUE` if the user has the teller user type, `FALSE` otherwise. Tellers have access to the teller module and specific tellering permissions, which allow them to take actions such as opening or closing tills, posting transactions on a till, and adding and removing cash from a till.',
            )
            .optional(),
    })
    .describe('Represents the user permissions and access rights.')

export type UserAccess = z.infer<typeof UserAccess>

export const Holiday = z
    .object({
        creationDate: z.string().datetime({ offset: true }).describe('The date when the holiday was created.').optional(),
        date: z.string().date().describe('The date the holiday takes place.').optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        id: z.number().int().describe('The ID of the holiday.').optional(),
        isAnnuallyRecurring: z.boolean().describe('`TRUE` if a holiday is annually recurring, `FALSE` otherwise.').optional(),
        name: z.string().describe('The name of the holiday.').optional(),
    })
    .describe('Represents the holiday.')

export type Holiday = z.infer<typeof Holiday>

export const PortalSettings = z
    .object({
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        lastLoggedInDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last date the client logged in to the portal.')
            .optional(),
        portalState: z.enum(['ENABLED', 'DISABLED']).describe(`The state of the client's portal preferences.`).optional(),
    })
    .describe('Represents portal settings for an individual client.')

export type PortalSettings = z.infer<typeof PortalSettings>

export const IdentificationDocument = z
    .object({
        attachments: Document.array()
            .describe('A list containing information about the attached files for this document')
            .optional(),
        clientKey: z.string().describe('The encoded key of the client that owns this document').optional(),
        documentId: z.string().describe('The id of the document'),
        documentType: z.string().describe('The type of the document, Passport, Id card Drivers license, etc.'),
        encodedKey: z.string().describe('The encoded key of the document, generated, unique').optional(),
        identificationDocumentTemplateKey: z.string().describe('Encoded key of the template used for this document').optional(),
        indexInList: z.number().int().describe(`This document's index in the list of documents`).optional(),
        issuingAuthority: z.string().describe('Authority that issued the document, eg. Police').optional(),
        validUntil: z.string().date().describe('Date when the validity of the document ends').optional(),
    })
    .describe(
        'An Id document represents a document that can be used to identify a person like a passport, a drivers license an id card etc.',
    )

export type IdentificationDocument = z.infer<typeof IdentificationDocument>

export const CustomFieldSetDisplaySettings = z
    .object({
        builtIn: z
            .boolean()
            .describe(
                `This is used only for builtIn custom field sets and can have two possible values:\\nTrue - when this is a "mambu" field set,\\nFalse - when this is a tenant-defined field set`,
            )
            .optional(),
        displayName: z.string().describe('User-provided name of the custom field set').optional(),
        position: z.number().int().describe('Represents the order of the custom field set (starts from 0)').optional(),
    })
    .describe('Wrapper holds the display properties of a Custom Field Set')

export type CustomFieldSetDisplaySettings = z.infer<typeof CustomFieldSetDisplaySettings>

export const CustomFieldIdentity = z
    .object({
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        id: z.string().describe('User-provided ID of the custom field').optional(),
    })
    .describe('A simple representation, holds only the information that identifies the custom field')

export type CustomFieldIdentity = z.infer<typeof CustomFieldIdentity>

export const DepositProductTaxSettings = z
    .object({
        withholdingTaxEnabled: z.boolean().describe('Whether withholding taxes are enabled for this product or not').optional(),
    })
    .describe('Tax settings, defines some settings for taxes on the loan product')

export type DepositProductTaxSettings = z.infer<typeof DepositProductTaxSettings>

export const DepositProductOverdraftSettings = z
    .object({
        allowOverdraft: z.boolean().describe('Whether the accounts for this product may have overdraft').optional(),
        allowTechnicalOverdraft: z
            .boolean()
            .describe('Whether the accounts for this product may have technical overdraft')
            .optional(),
        maxOverdraftLimit: z.number().describe('How much money may be taken out for the account to go negative').optional(),
    })
    .describe('The overdraft settings of the deposit product')

export type DepositProductOverdraftSettings = z.infer<typeof DepositProductOverdraftSettings>

export const OverdraftInterestSettings = z
    .object({
        daysInYear: z
            .enum(['ACTUAL_365_FIXED', 'ACTUAL_360', 'ACTUAL_ACTUAL_ISDA', 'E30_360', 'E30_42_365', 'BUS_252'])
            .describe('How many days in a year should be used for interest calculations')
            .optional(),
        interestCalculationBalance: z
            .enum(['MINIMUM', 'AVERAGE', 'END_OF_DAY', 'MINIMUM_TO_END_OF_DAY', 'FRENCH_INTEREST_ACCRUAL'])
            .describe(
                'The balance which is used for the overdraft interest calculation. Default value is MINIMUM. If set to null on a PUT call and the product allows overdrafts, the null value is ignored and not changed.',
            )
            .optional(),
        interestRateSettings: DepositProductOverdraftInterestRateSettings.optional(),
    })
    .describe('Overdraft settings for the product')

export type OverdraftInterestSettings = z.infer<typeof OverdraftInterestSettings>

export const DepositProductOffsetSettings = z
    .object({
        allowOffset: z
            .boolean()
            .describe('Specify if the product allow to create accounts which can be used as offset for loans')
            .optional(),
    })
    .describe('The offset settings, holds information about offset.')

export type DepositProductOffsetSettings = z.infer<typeof DepositProductOffsetSettings>

export const DepositNewAccountSettings = z
    .object({
        idGeneratorType: z
            .enum(['INCREMENTAL_NUMBER', 'RANDOM_PATTERN'])
            .describe('The type of generator used for IDs creation.'),
        idPattern: z.string().describe('The pattern that will be used for ID validation (as referred to as an input mask).'),
    })
    .describe('New Account settings for deposit accounts')

export type DepositNewAccountSettings = z.infer<typeof DepositNewAccountSettings>

export const DepositMaturitySettings = z
    .object({
        maturityPeriod: IntegerInterval.optional(),
        maturityPeriodUnit: z.enum(['DAYS', 'WEEKS', 'MONTHS']).describe('maturity period measurement unit').optional(),
    })
    .describe('The maturity settings for the product.')

export type DepositMaturitySettings = z.infer<typeof DepositMaturitySettings>

export const DepositProductInternalControls = z
    .object({
        dormancyPeriodDays: z
            .number()
            .int()
            .describe('Specifies the number of days for an account to be fully paid in order to auto close it.')
            .optional(),
        maxWithdrawalAmount: z.number().describe('Max amount per withdrawal').optional(),
        openingBalance: AmountDecimalInterval.optional(),
        recommendedDepositAmount: z.number().describe('Recommended amount for a deposit').optional(),
    })
    .describe('Constraints and automated actions and that will be applied on the accounts.')

export type DepositProductInternalControls = z.infer<typeof DepositProductInternalControls>

export const DepositProductInterestSettings = z
    .object({
        collectInterestWhenLocked: z.boolean().describe('Whether locked accounts still collect Interest or not').optional(),
        daysInYear: z
            .enum(['ACTUAL_365_FIXED', 'ACTUAL_360', 'ACTUAL_ACTUAL_ISDA', 'E30_360', 'E30_42_365', 'BUS_252'])
            .describe('How many days in a year should be used for interest calculations')
            .optional(),
        interestCalculationBalance: z
            .enum(['MINIMUM', 'AVERAGE', 'END_OF_DAY', 'MINIMUM_TO_END_OF_DAY', 'FRENCH_INTEREST_ACCRUAL'])
            .describe('The balance which is used for the Interest calculation')
            .optional(),
        interestGainsProvidedEndDate: z
            .string()
            .date()
            .describe('The date when the accounts under this product, will no longer have interest gains provided')
            .optional(),
        interestGainsProvidedStartDate: z
            .string()
            .date()
            .describe(
                'The date when the accounts of this product will start to have interest gains provided. Starting with this date 0 interest rate is enforced on the accounts of this product.',
            )
            .optional(),
        interestPaidIntoAccount: z.boolean().describe('If interest should be payed into the deposit account').optional(),
        interestPaymentSettings: InterestPaymentSettings.optional(),
        interestRateSettings: DepositProductInterestRateSettings.optional(),
        maximumBalance: z.number().describe('The maximum balance used for Interest calculation').optional(),
    })
    .describe(
        'The interest settings, defines constraints regarding interest that will be used on the deposit account based on this product.',
    )

export type DepositProductInterestSettings = z.infer<typeof DepositProductInterestSettings>

export const DepositProductFeeSettings = z
    .object({
        allowArbitraryFees: z
            .boolean()
            .describe(
                `Only if true users will be able to apply fees, for current object, of type 'Other'; these fees can have any amount.`,
            )
            .optional(),
        fees: DepositProductPredefinedFee.array()
            .describe('List of all fees that can be applied for accounts of this loan product.')
            .optional(),
    })
    .describe('Defines fees settings for the product.')

export type DepositProductFeeSettings = z.infer<typeof DepositProductFeeSettings>

export const DepositProductCurrencySettings = z
    .object({
        currencies: Currency.array().describe('Currencies that can be used by accounts of this product').optional(),
    })
    .describe('Currency settings for the product.')

export type DepositProductCurrencySettings = z.infer<typeof DepositProductCurrencySettings>

export const DepositProductAvailabilitySettings = z
    .object({
        availableFor: z
            .enum(['INDIVIDUALS', 'PURE_GROUPS'])
            .array()
            .describe('Holds the entities this product is available for. i.e Individuals')
            .optional(),
        branchSettings: BranchSettings.optional(),
    })
    .describe('Holds information about product availability.')

export type DepositProductAvailabilitySettings = z.infer<typeof DepositProductAvailabilitySettings>

export const DepositProductAccountingSettings = z
    .object({
        accountingMethod: z.enum(['NONE', 'CASH', 'ACCRUAL']).describe('The calculation method used for accounting.'),
        accountingRules: DepositGLAccountingRule.array().describe('A list of accounting rules for the product.').optional(),
        interestAccrualCalculation: z
            .enum(['NONE', 'AGGREGATED_AMOUNT', 'BREAKDOWN_PER_ACCOUNT'])
            .describe('The accounting interest calculation option selected for the product.')
            .optional(),
        interestAccruedAccountingMethod: z
            .enum(['NONE', 'DAILY', 'END_OF_MONTH'])
            .describe('The interval defined for a product when the interest accrues should be maintained.')
            .optional(),
    })
    .describe('Accounting settings, defines the accounting settings for the product.')

export type DepositProductAccountingSettings = z.infer<typeof DepositProductAccountingSettings>

export const CustomFieldViewRights = z
    .object({
        allUsers: z
            .boolean()
            .describe(
                '`TRUE` if custom field values of a custom field definition can be viewed by all users, `FALSE` if custom field values of a custom field definition can only be viewed by users with the specified roles.',
            )
            .optional(),
        roles: z
            .string()
            .array()
            .describe(
                'Lists the IDs of the roles that have view rights for the custom field values of a custom field definition if it is not accessible by all users.',
            )
            .optional(),
    })
    .describe('Represents the view rights for custom field values for a particular custom field definition.')

export type CustomFieldViewRights = z.infer<typeof CustomFieldViewRights>

export const CustomFieldValueValidationSettings = z
    .object({
        unique: z.boolean().describe('`TRUE` if this field does not allow duplicate values, `FALSE` otherwise.').optional(),
        validationPattern: z.string().describe('The expected format for the input.').optional(),
    })
    .describe('Represents the settings for field input validation.')

export type CustomFieldValueValidationSettings = z.infer<typeof CustomFieldValueValidationSettings>

export const CustomFieldUsage = z
    .object({
        default: z
            .boolean()
            .describe(
                '`TRUE` if the field is displayed by default on create or edit pages for this record type, `FALSE` otherwise.',
            )
            .optional(),
        objectKey: z.string().describe('The key of the record type.').optional(),
        required: z.boolean().describe('`TRUE` if the field is required for this record type, `FALSE` otherwise.').optional(),
    })
    .describe('Represents the usage settings of the custom field definition.')

export type CustomFieldUsage = z.infer<typeof CustomFieldUsage>

export const CustomFieldSelectionOption = z
    .object({
        availableOptions: CustomFieldAvailableOption.array()
            .describe(
                'The list of options that that are available for the dependent selection custom field value based on the selected parent custom field value.',
            )
            .optional(),
        forSelectionKey: z.string().describe('The key for the parent selection custom field value.').optional(),
        forValue: z.string().describe('The parent selection custom field value.').optional(),
    })
    .describe('Represents the information related to the options of a selection custom field definition.')

export type CustomFieldSelectionOption = z.infer<typeof CustomFieldSelectionOption>

export const CustomFieldEditRights = z
    .object({
        allUsers: z
            .boolean()
            .describe(
                '`TRUE` if custom field values of a custom field definition can be edited by all users, `FALSE` if custom field values of a custom field definition can only be edited by users with the specified roles.',
            )
            .optional(),
        roles: z
            .string()
            .array()
            .describe(
                'The list of IDs of the roles that have edit rights for the custom field values of a custom field definition if it is not accessible by all users.',
            )
            .optional(),
    })
    .describe('Represents the edit rights for custom field values for a particular custom field definition.')

export type CustomFieldEditRights = z.infer<typeof CustomFieldEditRights>

export const CustomFieldDisplaySettings = z
    .object({
        builtInId: z
            .enum([
                'FIRST_NAME',
                'MIDDLE_NAME',
                'LAST_NAME',
                'BIRTHDATE',
                'GENDER',
                'MOBILE_PHONE',
                'MOBILE_PHONE_2',
                'HOME_PHONE',
                'EMAIL_ADDRESS',
            ])
            .describe('The original ID of the built-in custom field definition.')
            .optional(),
        description: z.string().describe('The user-provided description of the custom field definition.').optional(),
        displayName: z.string().describe('The user-provided name of the custom field definition.').optional(),
        fieldSize: z.enum(['SHORT', 'LONG']).describe('The custom field value display size in the UI.').optional(),
        position: z.number().int().describe('The custom field definition position in the custom field set.').optional(),
    })
    .describe('Represents the display settings of a custom field definition.')

export type CustomFieldDisplaySettings = z.infer<typeof CustomFieldDisplaySettings>

export const Installment = z
    .object({
        carryForwardInterestSplit: CarryForwardInterestSplit.optional(),
        customSettingDetails: CustomSettingDetails.array()
            .describe('Custom settings associated with the installment.')
            .optional(),
        dueDate: z.string().datetime({ offset: true }).describe('The installment due date.').optional(),
        encodedKey: z.string().describe('The encoded key of the installment, which is auto generated, and unique.').optional(),
        expectedClosingBalance: z
            .number()
            .describe(
                'The expected closing balance is the remaining amount per installment only applicable for interest only equal installment products.',
            )
            .optional(),
        fee: InstallmentFee.optional(),
        feeDetails: InstallmentFeeDetails.array()
            .describe('The breakdown of the fee amounts that have been applied to the loan account.')
            .optional(),
        fundersInterestDue: z.number().describe('The amount of interest allocated to funders for P2P accounts only.').optional(),
        interest: InstallmentAllocationElementTaxableAmount.optional(),
        interestAccrued: z
            .number()
            .describe(
                'The interest accrued calculated on previous repayment closing balance only applicable interest only equal installment products.',
            )
            .optional(),
        isPaymentHoliday: z
            .boolean()
            .describe('`TRUE` if a payment holiday is offered for the installment, `FALSE` otherwise.')
            .optional(),
        lastPaidDate: z.string().datetime({ offset: true }).describe('The installment last paid date.').optional(),
        lastPenaltyAppliedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The most recent date on which a penalty was applied to the account.')
            .optional(),
        nonScheduledPrincipalBalanceOverpayment: z
            .number()
            .describe('The non-scheduled principal balance overpayment for the loan account')
            .optional(),
        notes: z.string().describe('Any comment or notes added to the installment.').optional(),
        number: z
            .string()
            .describe(
                'The order number of an installment among all the installments generated for a loan. Loan installments are put in ascending order by due date. The order number only applies to the content of a particular JSON response therefore it is not unique.',
            )
            .optional(),
        organizationCommissionDue: z
            .number()
            .describe('The amount of interest allocated to organization as commission for P2P accounts only.')
            .optional(),
        parentAccountKey: z.string().describe('The parent account key of the installment.').optional(),
        penalty: InstallmentAllocationElementTaxableAmount.optional(),
        principal: InstallmentAllocationElementAmount.optional(),
        repaidDate: z.string().datetime({ offset: true }).describe('The installment repaid date.').optional(),
        state: z.enum(['PENDING', 'LATE', 'PAID', 'PARTIALLY_PAID', 'GRACE']).describe('The installment state.').optional(),
    })
    .describe('Represents a single installment details structure.')

export type Installment = z.infer<typeof Installment>

export const DepositsTransaction = z
    .object({
        deposit: DepositTransactionInput.optional(),
        fee: FeeAppliedDepositTransactionInput.optional(),
        withdrawal: WithdrawalDepositTransactionInput.optional(),
    })
    .describe('Transaction to be executed.')

export type DepositsTransaction = z.infer<typeof DepositsTransaction>

export const PeriodicPaymentForSchedulePreview = z
    .object({
        amount: z.number().describe('The PMT value used in periodic payment'),
        toInstallment: z.number().int().describe(`The installment's position up to which the PMT will be used`),
    })
    .describe(
        'For fixed term loans there is the possibility to define a payment plan. A payment plan consists of multiple periodic payments. This class holds information about a periodic payment for schedule preview.',
    )

export type PeriodicPaymentForSchedulePreview = z.infer<typeof PeriodicPaymentForSchedulePreview>

export const RestructureScheduleSettings = z
    .object({
        amortizationPeriod: z
            .number()
            .int()
            .describe('The PMT is calculated as the loan would have [amortizationPeriod] installments.')
            .optional(),
        billingCycleDays: BillingCycleDays.optional(),
        fixedDaysOfMonth: z
            .number()
            .int()
            .array()
            .describe('The days of the month, when the repayment due dates should be')
            .optional(),
        gracePeriod: z.number().int().describe('The grace period').optional(),
        paymentPlan: PeriodicPayment.array().describe('A list of periodic payments for the current loan account.').optional(),
        periodicPayment: z.number().describe('The periodic payment').optional(),
        previewSchedule: RevolvingAccountSettings.optional(),
        repaymentInstallments: z.number().int().describe('The number of installments').optional(),
        repaymentPeriodCount: z.number().int().describe('The payments frequency per set period of time').optional(),
        repaymentPeriodUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS', 'YEARS'])
            .describe('The period of time, within which the payments frequency is set')
            .optional(),
    })
    .describe('The schedule settings, allowed on the loan account restructure')

export type RestructureScheduleSettings = z.infer<typeof RestructureScheduleSettings>

export const RestructurePrincipalPaymentAccountSettings = z
    .object({
        amount: z.number().describe('Fixed principal payment amount').optional(),
        percentage: z.number().describe('Principal payment percentage').optional(),
    })
    .describe('The principal payment account settings, allowed on the loan account restructure')

export type RestructurePrincipalPaymentAccountSettings = z.infer<typeof RestructurePrincipalPaymentAccountSettings>

export const RestructurePenaltySettings = z
    .object({
        penaltyRate: z.number().describe('The penalty rate').optional(),
    })
    .describe('The penalty settings, allowed on the loan account restructure.')

export type RestructurePenaltySettings = z.infer<typeof RestructurePenaltySettings>

export const RestructureInterestSettings = z
    .object({
        accountInterestRateSettings: AccountInterestRateSettings.array()
            .describe('Adjustable interest rates settings for loan account')
            .optional(),
        interestRate: z.number().describe('The interest rate for the restructured loan account').optional(),
        interestSpread: z.number().describe('The interest spread for the restructured loan account').optional(),
        pmtAdjustmentThreshold: PMTAdjustmentThreshold.optional(),
    })
    .describe('The interest settings, allowed on the loan account restructure')

export type RestructureInterestSettings = z.infer<typeof RestructureInterestSettings>

export const RefinanceDisbursementDetails = z
    .object({
        expectedDisbursementDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the expected disbursement')
            .optional(),
        fees: CustomPredefinedFee.array().describe('List of fees that should be applied at the disbursement time.').optional(),
        firstRepaymentDate: z.string().datetime({ offset: true }).describe('The date of the expected first payment'),
    })
    .describe('The disbursement details, allowed on the loan account refinance')

export type RefinanceDisbursementDetails = z.infer<typeof RefinanceDisbursementDetails>

export const RestructureAccountArrearsSettings = z
    .object({
        tolerancePercentageOfOutstandingPrincipal: z.number().describe('The arrears tolerance amount').optional(),
        tolerancePeriod: z.number().int().describe('The arrears tolerance period value').optional(),
    })
    .describe('The arrears settings, allowed on the loan account restructure')

export type RestructureAccountArrearsSettings = z.infer<typeof RestructureAccountArrearsSettings>

export const RescheduleDisbursementDetails = z
    .object({
        firstRepaymentDate: z.string().datetime({ offset: true }).describe('The date of the expected first payment'),
    })
    .describe('The disbursement details, allowed on the loan account restructure')

export type RescheduleDisbursementDetails = z.infer<typeof RescheduleDisbursementDetails>

export const ForeignAmount = z
    .object({
        accountingRate: AccountingRate.optional(),
        amount: z.number().describe('The foreign currency amount of the accounting entry.').optional(),
        currency: Currency.optional(),
    })
    .describe('Represents the details of general ledger journal entries posted in foreign currency.')

export type ForeignAmount = z.infer<typeof ForeignAmount>

export const AccountingReportItem = z
    .object({
        amounts: AccountingReportAmounts.optional(),
        foreignAmounts: AccountingReportAmounts.optional(),
        glAccount: GLAccount.optional(),
    })
    .describe(
        `Represents the accounting report information about general ledger accounts and their amounts in both the organization's currency and foreign currencies.`,
    )

export type AccountingReportItem = z.infer<typeof AccountingReportItem>

export const LoanTransaction = z
    .object({
        accountBalances: TransactionBalances.optional(),
        adjustmentTransactionKey: z
            .string()
            .describe(
                'The key of the loan transaction where the adjustment for the transaction was made (if any adjustment was involved).',
            )
            .optional(),
        affectedAmounts: LoanAffectedAmounts.optional(),
        amount: z.number().describe('The amount that was added or removed on the loan account.').optional(),
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when the corresponding journal entry is booked.')
            .optional(),
        branchKey: z.string().describe('The branch where the transaction was performed.').optional(),
        cardTransaction: CardTransaction.optional(),
        centreKey: z.string().describe('The center where the transaction was performed.').optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when this loan transaction was created.')
            .optional(),
        currency: Currency.optional(),
        customPaymentAmounts: CustomPaymentAmount.array()
            .describe('The list of custom amounts which the user has paid as part of this transaction.')
            .optional(),
        encodedKey: z
            .string()
            .describe('The encoded key of the loan transaction, which is auto generated, and must be unique.')
            .optional(),
        externalId: z
            .string()
            .describe('The external ID of the loan transaction, it is customizable, and must be unique.')
            .optional(),
        fees: Fee.array()
            .describe('The amounts that have been applied or paid as part of this transaction and involved predefined fees.')
            .optional(),
        id: z
            .string()
            .describe('The ID of the loan transaction, can be generated and customized, and must be unique.')
            .optional(),
        installmentEncodedKey: z
            .string()
            .describe('The specific installment encoded key associated to the loan transaction.')
            .optional(),
        migrationEventKey: z
            .string()
            .describe(
                `The migration event encoded key associated with the loan account. If the account was imported, track which 'migration event' it came from.`,
            )
            .optional(),
        notes: z.string().describe('The notes or description for the loan transaction.').optional(),
        originalAmount: z
            .number()
            .describe(
                'The amount that was posted in a foreign currency. This amount was converted using the exchange rate available at entry date and set into the amount field.',
            )
            .optional(),
        originalCurrencyCode: z
            .string()
            .describe(
                'The currency in which this transaction was posted. The amounts are stored in the base currency, but the user may enter it in a foreign currency.',
            )
            .optional(),
        originalTransactionKey: z
            .string()
            .describe(
                'The encoded key of the transaction that was adjusted as part of this one. Available only for adjustment transactions.',
            )
            .optional(),
        parentAccountKey: z.string().describe('The key of the parent loan account.').optional(),
        parentLoanTransactionKey: z.string().describe('The key of the parent loan transaction.').optional(),
        prepaymentRecalculationMethod: z
            .enum([
                'NO_RECALCULATION',
                'RESCHEDULE_REMAINING_REPAYMENTS',
                'RECALCULATE_SCHEDULE_KEEP_SAME_NUMBER_OF_TERMS',
                'RECALCULATE_SCHEDULE_KEEP_SAME_PRINCIPAL_AMOUNT',
                'RECALCULATE_SCHEDULE_KEEP_SAME_TOTAL_REPAYMENT_AMOUNT',
                'REDUCE_AMOUNT_PER_INSTALLMENT',
                'REDUCE_NUMBER_OF_INSTALLMENTS',
                'REDUCE_NUMBER_OF_INSTALLMENTS_NEW',
            ])
            .describe('The prepayment recalculation method of the loan transaction.')
            .optional(),
        taxes: Taxes.optional(),
        terms: LoanTerms.optional(),
        tillKey: z.string().describe('The till key associated with the transaction.').optional(),
        transactionDetails: TransactionDetails.optional(),
        transferDetails: TransferDetails.optional(),
        type: z
            .enum([
                'IMPORT',
                'DISBURSEMENT',
                'DISBURSEMENT_ADJUSTMENT',
                'WRITE_OFF',
                'WRITE_OFF_ADJUSTMENT',
                'REPAYMENT',
                'PAYMENT_MADE',
                'WITHDRAWAL_REDRAW',
                'WITHDRAWAL_REDRAW_ADJUSTMENT',
                'FEE_APPLIED',
                'FEE_CHARGED',
                'FEE_CAPITALISED',
                'SCHEDULE_FIX_APPLIED',
                'FEES_DUE_REDUCED',
                'FEE_REFUND',
                'FEE_REFUND_ADJUSTMENT',
                'FEE_ADJUSTMENT',
                'PENALTY_APPLIED',
                'PENALTY_ADJUSTMENT',
                'PENALTIES_DUE_REDUCED',
                'REPAYMENT_ADJUSTMENT',
                'FEE_CAPITALISED_ADJUSTMENT',
                'PAYMENT_MADE_ADJUSTMENT',
                'INTEREST_RATE_CHANGED',
                'TAX_RATE_CHANGED',
                'PENALTY_RATE_CHANGED',
                'INTEREST_APPLIED',
                'IBF_INTEREST_APPLIED',
                'INTEREST_APPLIED_ADJUSTMENT',
                'INTEREST_DUE_REDUCED',
                'PENALTY_REDUCTION_ADJUSTMENT',
                'FEE_REDUCTION_ADJUSTMENT',
                'INTEREST_REDUCTION_ADJUSTMENT',
                'DEFERRED_INTEREST_APPLIED',
                'DEFERRED_INTEREST_APPLIED_ADJUSTMENT',
                'DEFERRED_INTEREST_PAID',
                'DEFERRED_INTEREST_PAID_ADJUSTMENT',
                'INTEREST_LOCKED',
                'FEE_LOCKED',
                'PENALTY_LOCKED',
                'INTEREST_UNLOCKED',
                'FEE_UNLOCKED',
                'PENALTY_UNLOCKED',
                'REDRAW_TRANSFER',
                'REDRAW_REPAYMENT',
                'REDRAW_TRANSFER_ADJUSTMENT',
                'REDRAW_REPAYMENT_ADJUSTMENT',
                'TRANSFER',
                'TRANSFER_ADJUSTMENT',
                'BRANCH_CHANGED',
                'TERMS_CHANGED',
                'CARD_TRANSACTION_REVERSAL',
                'CARD_TRANSACTION_REVERSAL_ADJUSTMENT',
                'DUE_DATE_CHANGED',
                'DUE_DATE_CHANGED_ADJUSTMENT',
                'ACCOUNT_TERMINATED',
                'ACCOUNT_TERMINATED_ADJUSTMENT',
                'REFUND',
                'REFUND_ADJUSTMENT',
                'REDUCE_BALANCE',
                'REDUCE_BALANCE_ADJUSTMENT',
                'PRINCIPAL_OVERPAYMENT',
                'PRINCIPAL_OVERPAYMENT_ADJUSTMENT',
            ])
            .describe('The type of loan transaction.')
            .optional(),
        userKey: z.string().describe('The user that performed the transaction.').optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the entry in the organization time format and timezone.')
            .optional(),
    })
    .passthrough()
    .describe(`Represents the action performed on a loan account after which the account's amount changes its value.`)

export type LoanTransaction = z.infer<typeof LoanTransaction>

export const AuthorizationHold = z
    .object({
        accountKey: z.string().describe('The key of the account linked with the authorization hold.').optional(),
        advice: z.boolean().describe('Whether the given request should be accepted without balance validations.'),
        amount: z.number().describe('The amount of money to be held as a result of the authorization hold request.'),
        balances: AccountBalances.optional(),
        cardAcceptor: CardAcceptor.optional(),
        cardToken: z.string().describe('The reference token of the card.').optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The organization time when the authorization hold was created')
            .optional(),
        creditDebitIndicator: z
            .enum(['DBIT', 'CRDT'])
            .describe(
                'Indicates whether the authorization hold amount is credited or debited.If not provided, the default values is DBIT.',
            )
            .optional(),
        currencyCode: z
            .string()
            .describe(
                'The ISO currency code in which the hold was created. The amounts are stored in the base currency, but the user could have enter it in a foreign currency.',
            )
            .optional(),
        customExpirationPeriod: z
            .number()
            .int()
            .describe('The custom expiration period for the hold which overwrites mcc and default expiration periods')
            .optional(),
        exchangeRate: z.number().describe('The exchange rate for the original currency.').optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID to be used to reference the account hold in subsequent requests.'),
        originalAmount: z
            .number()
            .describe('The original amount of money to be held as a result of the authorization hold request.')
            .optional(),
        originalCurrency: z.string().describe('The original currency in which the hold was created.').optional(),
        partial: z.boolean().describe('Indicates whether the authorization is partial or not').optional(),
        referenceDateForExpiration: z
            .string()
            .datetime({ offset: true })
            .describe('The date to consider as start date when calculating the number of days passed until expiration')
            .optional(),
        source: z
            .enum(['CARD', 'ACCOUNT'])
            .describe('Indicates the source of the authorization hold, the default values is CARD.')
            .optional(),
        status: z.enum(['PENDING', 'REVERSED', 'SETTLED', 'EXPIRED']).describe('The authorization hold status.').optional(),
        userTransactionTime: z.string().describe('The formatted time at which the user made this authorization hold.').optional(),
    })
    .describe('The authorization hold corresponding to a card token')

export type AuthorizationHold = z.infer<typeof AuthorizationHold>

export const DepositTransactionBulkableInputDTO = z
    .object({
        accountId: z.string().describe('The id of the account'),
        amount: z.number().describe('The amount that was added to an account'),
        externalId: z.string().describe('The external id of the deposit transaction, customizable, unique').optional(),
        holdExternalReferenceId: z.string().describe('The external id of an account authorization hold').optional(),
        notes: z.string().describe('Extra notes about this deposit transaction').optional(),
        paymentDetails: PaymentDetails.optional(),
        paymentOrderId: z.string().describe('The payment order id of the deposit transaction, customizable').optional(),
        skipMaximumBalanceValidation: z
            .boolean()
            .describe('Flag indicating that a maximum balance validation should be skipped')
            .optional(),
        transactionDetails: TransactionDetailsInput.optional(),
    })
    .passthrough()
    .describe('Represents the request payload for creating a deposit transactions when sent in bulk.')

export type DepositTransactionBulkableInputDTO = z.infer<typeof DepositTransactionBulkableInputDTO>

export const InterestAccountSettingsAvailability = z
    .object({
        encodedKey: z.string().describe('The encoded key of the Interest Availability, auto generated, unique.').optional(),
        interestRateSettings: DepositAccountInterestAvailabilitySettings,
        startDate: z.string().date().describe('Start date of the Interest Availability.'),
        type: z.enum(['INTEREST', 'OVERDRAFT', 'TECHNICAL_OVERDRAFT']).describe('Type of the interest.'),
    })
    .describe('Interest Availability of a Deposit Account')

export type InterestAccountSettingsAvailability = z.infer<typeof InterestAccountSettingsAvailability>

export const BulkInterestAccountSettingsAvailabilityFilter = z
    .object({
        ids: z.string().array().describe('Ids of accounts that should be processed').optional(),
        productId: z.string().describe('Product id to be used for selecting all accounts that should be processed').optional(),
    })
    .describe(
        'Represents the filter to be used for selecting the accounts to which new interest availability settings will be pushed. One of the 2 fields: productId or ids should be supplied ',
    )

export type BulkInterestAccountSettingsAvailabilityFilter = z.infer<typeof BulkInterestAccountSettingsAvailabilityFilter>

export const BulkProcessingSuccess = z
    .object({
        externalId: z.string().describe('Optional field populated only when request payload contains an externalId').optional(),
        id: z.string().describe('Unique identifier for the newly created resource').optional(),
        indexInRequest: z
            .number()
            .int()
            .describe('The index of the entity/item from bulk request that failed on processing')
            .optional(),
    })
    .describe('Holds details about successful processed item')

export type BulkProcessingSuccess = z.infer<typeof BulkProcessingSuccess>

export const BulkProcessingError = z
    .object({
        errorCode: z.number().int().describe('Numeric value associated to the error reason').optional(),
        errorReason: z.string().describe('Error reason').optional(),
        errorSource: z.string().describe('Details about the error').optional(),
        externalId: z.string().describe('Optional field populated only when request payload contains an externalId').optional(),
        indexInRequest: z
            .number()
            .int()
            .describe('The index of the entity/item from bulk request that failed on processing')
            .optional(),
    })
    .describe('Holds information about the error encountered processing an item in bulk')

export type BulkProcessingError = z.infer<typeof BulkProcessingError>

export const LinkedTransaction = z
    .object({
        linkedTransactionKey: z.string().describe('The encodedKey of the linked financial transaction.').optional(),
        linkedTransactionType: z
            .enum(['LOAN', 'DEPOSIT'])
            .describe('The type of the linked transaction (Deposit / Loan).')
            .optional(),
    })
    .describe('The details of the linked financial transaction triggered by the card transaction.')

export type LinkedTransaction = z.infer<typeof LinkedTransaction>

export const ClientSortingCriteria = z
    .object({
        field: z
            .enum([
                'encodedKey',
                'id',
                'fullName',
                'firstName',
                'middleName',
                'lastName',
                'creationDate',
                'lastModifiedDate',
                'depositsBalance',
                'loansBalance',
                'pendingLoanAmount',
                'approvedLoanAmount',
                'totalBalance',
                'totalDue',
                'homePhoneNumber',
                'mobilePhoneNumber',
                'mobilePhoneNumber2',
                'emailAddress',
                'birthdate',
                'loanCycle',
                'groupLoanCycle',
                'portalState',
            ])
            .describe(
                'The field to sort by. It can be native (one from the provided list) or otherwise can specify a custom field definition using the format [customFieldSetId].[customFieldId].',
            ),
        order: z.enum(['ASC', 'DESC']).describe('The sorting order: `ASC` or `DESC`. The default order is `DESC`.').optional(),
    })
    .describe('The sorting criteria used for Clients')

export type ClientSortingCriteria = z.infer<typeof ClientSortingCriteria>

export const ClientFilterCriteria = z
    .object({
        field: z.union([
            z
                .enum([
                    'encodedKey',
                    'creditOfficerKey',
                    'clientRoleKey',
                    'branchKey',
                    'centreKey',
                    'groupKey',
                    'fullName',
                    'firstName',
                    'middleName',
                    'lastName',
                    'creationDate',
                    'lastModifiedDate',
                    'id',
                    'depositsBalance',
                    'loansBalance',
                    'pendingLoanAmount',
                    'approvedLoanAmount',
                    'totalBalance',
                    'totalDue',
                    'homePhoneNumber',
                    'mobilePhoneNumber',
                    'mobilePhoneNumber2',
                    'emailAddress',
                    'clientAddress',
                    'birthdate',
                    'gender',
                    'loanCycle',
                    'groupLoanCycle',
                    'clientState',
                    'portalState',
                    'preferredLanguage',
                    'groupId',
                ])
                .describe(
                    'The fields to perform the search. They can be native (one from the provided list) or otherwise can specify a custom field definition using the format [customFieldSetId].[customFieldId].\\n',
                ),
            z.string(),
        ]),
        operator: z
            .enum([
                'EQUALS',
                'EQUALS_CASE_SENSITIVE',
                'DIFFERENT_THAN',
                'MORE_THAN',
                'LESS_THAN',
                'BETWEEN',
                'ON',
                'AFTER',
                'AFTER_INCLUSIVE',
                'BEFORE',
                'BEFORE_INCLUSIVE',
                'STARTS_WITH',
                'STARTS_WITH_CASE_SENSITIVE',
                'IN',
                'TODAY',
                'THIS_WEEK',
                'THIS_MONTH',
                'THIS_YEAR',
                'LAST_DAYS',
                'EMPTY',
                'NOT_EMPTY',
            ])
            .describe(
                '| **Operator**                | **Affected values**  | **Available for**                                                    |\\n|---------------               |----------------------|----------------------------------------------------------------------|\\n| EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |\\n| EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |\\n| MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |\\n| ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| STARTS_WITH                  | ONE_VALUE            | STRING                                                               |\\n| STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |\\n| IN                           | LIST                 | ENUM,KEY                                                             |\\n| TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |\\n| EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |\\n| NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |',
            ),
        secondValue: z
            .string()
            .describe('The second value to match the searching criteria, when the `BETWEEN` operator is used.')
            .optional(),
        value: z.string().describe('The value to match the searching criteria.').optional(),
        values: z.string().array().describe('List of values when the `IN` operator is used.').optional(),
    })
    .describe('The unit that composes the list used for Clients searching')

export type ClientFilterCriteria = z.infer<typeof ClientFilterCriteria>

export const CommunicationMessageFilterCriteria = z
    .object({
        field: z.union([
            z
                .enum([
                    'encodedKey',
                    'creationDate',
                    'sendDate',
                    'senderKey',
                    'clientKey',
                    'groupKey',
                    'userKey',
                    'state',
                    'failureReason',
                    'failureCause',
                    'destination',
                    'type',
                    'event',
                ])
                .describe('The field(s) to use to perform the search.'),
            z.string(),
        ]),
        operator: z
            .enum([
                'EQUALS',
                'EQUALS_CASE_SENSITIVE',
                'DIFFERENT_THAN',
                'MORE_THAN',
                'LESS_THAN',
                'BETWEEN',
                'ON',
                'AFTER',
                'AFTER_INCLUSIVE',
                'BEFORE',
                'BEFORE_INCLUSIVE',
                'STARTS_WITH',
                'STARTS_WITH_CASE_SENSITIVE',
                'IN',
                'TODAY',
                'THIS_WEEK',
                'THIS_MONTH',
                'THIS_YEAR',
                'LAST_DAYS',
                'EMPTY',
                'NOT_EMPTY',
            ])
            .describe(
                '| **Operator**                | **Affected values**  | **Available for**                                                    |\\n|---------------               |----------------------|----------------------------------------------------------------------|\\n| EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |\\n| EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |\\n| MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |\\n| ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| STARTS_WITH                  | ONE_VALUE            | STRING                                                               |\\n| STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |\\n| IN                           | LIST                 | ENUM,KEY                                                             |\\n| TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |\\n| EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |\\n| NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |',
            ),
        secondValue: z
            .string()
            .describe('The second value to match the searching criteria, when the `BETWEEN` operator is used.')
            .optional(),
        value: z.string().describe('The value to match the searching criteria.').optional(),
        values: z.string().array().describe('List of values when the `IN` operator is used.').optional(),
    })
    .describe('The unit that composes the list used for communication messages client directed searching')

export type CommunicationMessageFilterCriteria = z.infer<typeof CommunicationMessageFilterCriteria>

export const CommunicationMessageSearchSortingCriteria = z
    .object({
        field: z
            .enum(['encodedKey', 'creationDate', 'sendDate', 'senderKey', 'clientKey', 'groupKey', 'userKey', 'type'])
            .describe('Sort Messages By'),
        order: z.enum(['ASC', 'DESC']).describe('The sorting order: `ASC` or `DESC`. The default order is `DESC`.').optional(),
    })
    .describe('The sorting criteria used for Messages search.')

export type CommunicationMessageSearchSortingCriteria = z.infer<typeof CommunicationMessageSearchSortingCriteria>

export const GLJournalEntry = z
    .object({
        accountKey: z
            .string()
            .describe(
                'The account associated with this journal entry. `Null` if the journal entry is not associated to any account.',
            )
            .optional(),
        amount: z.number().describe(`The amount which was debited or credited in the organization's currency.`).optional(),
        assignedBranchKey: z
            .string()
            .describe('The key of the assigned branch for this general ledger journal entry.')
            .optional(),
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date and time when the general ledger journal entry was recorded.')
            .optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The creation date of the general ledger journal entry.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        entryID: z.number().int().describe('The ID of the general ledger journal entry.').optional(),
        foreignAmount: GLJournalEntryForeignAmount.optional(),
        glAccount: GLAccount.optional(),
        notes: z.string().describe('Optional notes entered by the user when they performed the journal entry.').optional(),
        productKey: z
            .string()
            .describe(
                'The product associated with this journal entry. `Null` if the journal entry is not associated with any product.',
            )
            .optional(),
        productType: z
            .enum(['LOAN', 'SAVINGS'])
            .describe(
                'The product type that is referenced by the account key. `Null` if the journal entry is not associated to any product.',
            )
            .optional(),
        reversalEntryKey: z
            .string()
            .describe(
                `The entry key of the general ledger journal entry that reverses this general ledger journal entry. Null if the general ledger journal entry isn't reversed.`,
            )
            .optional(),
        transactionId: z.string().describe('The transation ID, which is not unique.').optional(),
        type: z
            .enum(['DEBIT', 'CREDIT'])
            .describe('The general ledger journal entry type, which may be debit or credit.')
            .optional(),
        userKey: z.string().describe('The encoded key of the user that performed the transaction.').optional(),
    })
    .describe('Represents a general ledger journal entry.')

export type GLJournalEntry = z.infer<typeof GLJournalEntry>

export const GLAccountInput = z
    .object({
        allowManualJournalEntries: z
            .boolean()
            .describe(
                '`TRUE` if manual journal entries are allowed, `FALSE` otherwise. This is only available for Detail Accounts.',
            )
            .optional(),
        currency: Currency.optional(),
        description: z.string().describe('The description of the general ledger account.').optional(),
        glCode: z
            .string()
            .describe(
                `The general ledger code used to identify different account types. Also used for grouping and categorizing accounts. For example: an account code of '3201' is considered a subtype of '3200'.`,
            ),
        name: z.string().describe('The name of the general ledger account.'),
        stripTrailingZeros: z
            .boolean()
            .describe('`TRUE` to strip trailing zeros, `FALSE` otherwise. Only available for Header Accounts.')
            .optional(),
        type: z.enum(['ASSET', 'LIABILITY', 'EQUITY', 'INCOME', 'EXPENSE']).describe('The general ledger account type.'),
        usage: z
            .enum(['DETAIL', 'HEADER'])
            .describe(
                '`DETAIL` for general ledger accounts that log transactions, and `HEADER` for general ledger accounts used for reporting and organizational purposes.',
            ),
    })
    .describe('Represents the request payload for creating a GL Account')

export type GLAccountInput = z.infer<typeof GLAccountInput>

export const LoanAccount = z
    .object({
        accountArrearsSettings: AccountArrearsSettings.optional(),
        accountHolderKey: z.string().describe('The encoded key of the account holder.'),
        accountHolderType: z.enum(['CLIENT', 'GROUP']).describe('The type of the account holder.'),
        accountState: z
            .enum([
                'PARTIAL_APPLICATION',
                'PENDING_APPROVAL',
                'APPROVED',
                'ACTIVE',
                'ACTIVE_IN_ARREARS',
                'CLOSED',
                'CLOSED_WRITTEN_OFF',
                'CLOSED_REJECTED',
            ])
            .describe('The state of the loan account.')
            .optional(),
        accountSubState: z
            .enum([
                'PARTIALLY_DISBURSED',
                'LOCKED',
                'LOCKED_CAPPING',
                'REFINANCED',
                'RESCHEDULED',
                'WITHDRAWN',
                'REPAID',
                'REJECTED',
                'WRITTEN_OFF',
                'TERMINATED',
            ])
            .describe(
                'A second state for the loan account. Beside the account state, a second substate is sometimes necessary to provide more information about the exact lifecycle state of a loan account.For example, even if the account state of a loan account is `ACTIVE`, it can also have a substate of `LOCKED`.',
            )
            .optional(),
        accruedInterest: z.number().describe('The amount of interest that has been accrued in the loan account.').optional(),
        accruedPenalty: z
            .number()
            .describe('The accrued penalty, represents the amount of penalty that has been accrued in the loan account.')
            .optional(),
        activationTransactionKey: z
            .string()
            .describe('The encoded key of the transaction that activated the loan account.')
            .optional(),
        adjustTotalDueForInstallmentsWithDifferentInterval: z
            .boolean()
            .describe('Adjust the total due for repayment when the repayment period is different than the repayment frequency')
            .optional(),
        allowOffset: z.boolean().describe('DEPRECATED - Will always be false.').optional(),
        approvedDate: z.string().datetime({ offset: true }).describe('The date the loan account was approved.').optional(),
        arrearsTolerancePeriod: z
            .number()
            .int()
            .describe('The arrears tolerance (period or day of month) depending on the product settings.')
            .optional(),
        assets: Asset.array().describe('The list of assets associated with the current loan account.').optional(),
        assignedBranchKey: z
            .string()
            .describe(
                'The key of the branch this loan account is assigned to. The branch is set to unassigned if no branch field is set.',
            )
            .optional(),
        assignedCentreKey: z.string().describe('The key of the centre this account is assigned to.').optional(),
        assignedUserKey: z.string().describe('The key of the user this loan account is assigned to.').optional(),
        balances: Balances.optional(),
        closedDate: z.string().datetime({ offset: true }).describe('The date the loan was closed.').optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The date the loan account was created.').optional(),
        creditArrangementKey: z
            .string()
            .describe('The key to the line of credit where this account is registered to.')
            .optional(),
        currency: Currency.optional(),
        daysInArrears: z.number().int().describe('The number of days the loan account is in arrears.').optional(),
        daysLate: z.number().int().describe('The number of days a repayment for the loan account is late.').optional(),
        disbursementDetails: DisbursementDetails.optional(),
        encodedKey: z
            .string()
            .describe('The encoded key of the loan account, it is auto generated, and must be unique.')
            .optional(),
        feesSettings: FeesAccountSettings.optional(),
        fundingSources: InvestorFund.array().describe('The list of funds associated with the loan account.').optional(),
        futurePaymentsAcceptance: z
            .enum(['NO_FUTURE_PAYMENTS', 'ACCEPT_FUTURE_PAYMENTS', 'ACCEPT_OVERPAYMENTS'])
            .describe(
                'Shows whether the repayment transactions with entry date set in the future are allowed or not for this loan account.',
            )
            .optional(),
        guarantors: Guarantor.array().describe('The list of guarantees associated with the loan account.').optional(),
        id: z.string().describe('The ID of the loan account, it can be generated and customized, and must be unique.').optional(),
        interestAccruedInBillingCycle: z
            .number()
            .describe('The interest that is accrued in the current billing cycle.')
            .optional(),
        interestCommission: z
            .number()
            .describe(
                'The value of the interest booked by the organization from the accounts funded by investors. Null if the funds are not enabled.',
            )
            .optional(),
        interestFromArrearsAccrued: z
            .number()
            .describe('The amount of interest from arrears that has been accrued in the loan account.')
            .optional(),
        interestSettings: InterestSettings.optional(),
        lastAccountAppraisalDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                'The date the loan account has last been evaluated for interest, principal, fees, and penalties calculations expressed in the organization time format and time zone.',
            )
            .optional(),
        lastInterestAppliedDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                'The date of the last time the loan account had interest applied (stored to interest balance), expressed in the organization time format and time zone.',
            )
            .optional(),
        lastInterestReviewDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date the interest was reviewed last time, stored in the organization time format and time zone.')
            .optional(),
        lastLockedDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                'The date when the loan account was set for the last time in the `LOCKED` state expressed in the organization time format and time zone. If null, the account is not locked anymore.',
            )
            .optional(),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('The last date the loan was updated.').optional(),
        lastSetToArrearsDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                'The date when the loan account was set to last standing or null; if never set, it is expressed in your organization time format and time zone.',
            )
            .optional(),
        lastTaxRateReviewDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                'The date the tax rate on the loan account was last checked, expressed in the organization time format and time zone.',
            )
            .optional(),
        latePaymentsRecalculationMethod: z
            .enum(['OVERDUE_INSTALLMENTS_INCREASE', 'LAST_INSTALLMENT_INCREASE', 'NO_RECALCULATION'])
            .describe(
                'The overdue payments recalculation method inherited from the loan product on which this loan account is based.',
            )
            .optional(),
        loanAmount: z.number().describe('The loan amount.'),
        loanName: z.string().describe('The name of the loan account.').optional(),
        lockedAccountTotalDueType: z
            .enum(['BALANCE_AMOUNT', 'DUE_AMOUNT_ON_LATE_INSTALLMENTS'])
            .describe('The locked account total due type.')
            .optional(),
        lockedOperations: z
            .enum(['APPLY_INTEREST', 'APPLY_FEES', 'APPLY_PENALTIES'])
            .array()
            .describe('A list with operations which are locked when the account is in the AccountState.LOCKED substate.')
            .optional(),
        migrationEventKey: z
            .string()
            .describe(
                `The migration event encoded key associated with this loan account. If this account was imported, track which 'migration event' they came from.`,
            )
            .optional(),
        modifyInterestForFirstInstallment: z
            .boolean()
            .describe(
                'Adjust the interest for the first repayment when the first repayment period is different than the repayment frequency',
            )
            .optional(),
        notes: z.string().describe('The notes about this loan account.').optional(),
        originalAccountKey: z.string().describe('The key of the original rescheduled or refinanced loan account.').optional(),
        paymentHolidaysAccruedInterest: z
            .number()
            .describe('The amount of interest that has been accrued during payment holidays in the loan account.')
            .optional(),
        paymentMethod: z
            .enum(['HORIZONTAL', 'VERTICAL'])
            .describe(
                'The interest payment method that determines whether the payments are made horizontally (on the repayments) or vertically (on the loan account).',
            )
            .optional(),
        penaltySettings: PenaltySettings.optional(),
        plannedInstallmentFees: PlannedInstallmentFee.array()
            .describe('The list with manual fees planned on the installments of the loan account.')
            .optional(),
        prepaymentSettings: PrepaymentSettings.optional(),
        principalPaymentSettings: PrincipalPaymentAccountSettings.optional(),
        productTypeKey: z.string().describe('The key for the type of loan product that this loan account is based on.'),
        redrawSettings: LoanAccountRedrawSettings.optional(),
        rescheduledAccountKey: z
            .string()
            .describe(
                'The key pointing to where this loan account was rescheduled or refinanced to. This value is only not null if rescheduled.',
            )
            .optional(),
        scheduleSettings: ScheduleSettings,
        settlementAccountKey: z.string().describe('The encoded key of the settlement account.').optional(),
        taxRate: z.number().describe('The tax rate.').optional(),
        terminationDate: z.string().datetime({ offset: true }).describe('The date this loan account was terminated.').optional(),
        tranches: LoanTranche.array().describe('The list of disbursement tranches available for the loan account.').optional(),
    })
    .passthrough()
    .describe(
        'Represents a loan account. A loan account defines the amount that your organization lends to a client. The terms and conditions of a loan account are defined by a loan product. In a loan account, Mambu stores all the information related to disbursements, repayments, interest rates, and withdrawals.',
    )

export type LoanAccount = z.infer<typeof LoanAccount>

export const DepositAccount = z
    .object({
        accountHolderKey: z.string().describe('The encoded key of the account holder, which is an individual client or group.'),
        accountHolderType: z.enum(['CLIENT', 'GROUP']).describe('The account holder type.'),
        accountState: z
            .enum([
                'PENDING_APPROVAL',
                'APPROVED',
                'ACTIVE',
                'ACTIVE_IN_ARREARS',
                'MATURED',
                'LOCKED',
                'DORMANT',
                'CLOSED',
                'CLOSED_WRITTEN_OFF',
                'WITHDRAWN',
                'CLOSED_REJECTED',
            ])
            .describe('The state of the deposit account.')
            .optional(),
        accountType: z
            .enum(['CURRENT_ACCOUNT', 'REGULAR_SAVINGS', 'FIXED_DEPOSIT', 'SAVINGS_PLAN', 'INVESTOR_ACCOUNT'])
            .describe('The deposit account type and the product that it belongs to.')
            .optional(),
        accruedAmounts: DepositAccountAccruedAmounts.optional(),
        activationDate: z
            .string()
            .datetime({ offset: true })
            .describe(`The date when the deposit account was activated, in the organization's timezone and time format.`)
            .optional(),
        approvedDate: z
            .string()
            .datetime({ offset: true })
            .describe(`The date when the deposit account was approved, in the organization's timezone and time format.`)
            .optional(),
        assignedBranchKey: z.string().describe('The key of the branch that this deposit account is assigned to.').optional(),
        assignedCentreKey: z.string().describe('The key of the centre that this account is assigned to.').optional(),
        assignedUserKey: z.string().describe('The key of the user that this deposit is assigned to.').optional(),
        balances: DepositAccountBalances.optional(),
        closedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when the deposit account was closed, in UTC.')
            .optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date this deposit account was created, in UTC.')
            .optional(),
        creditArrangementKey: z
            .string()
            .describe('The key to the credit arrangement where this account is registered.')
            .optional(),
        currencyCode: z.string().describe('The currency code.').optional(),
        encodedKey: z.string().describe('The encoded key of the deposit account, which is auto-generated and unique.').optional(),
        id: z
            .string()
            .describe('The ID of the deposit account, which can be generated and customized - but must be unique.')
            .optional(),
        interestSettings: DepositAccountInterestSettings.optional(),
        internalControls: DepositAccountInternalControls.optional(),
        lastAccountAppraisalDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                `The date when the account was last evaluated for interest calculations and maturity, in the organization's timezone and time format.`,
            )
            .optional(),
        lastInterestCalculationDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                `The date when interest was last calculated for the account, in the organization's timezone and time format.`,
            )
            .optional(),
        lastInterestReviewDate: z
            .string()
            .datetime({ offset: true })
            .describe(`The date when regular interest was last reviewed, in the organization's timezone and time format.`)
            .optional(),
        lastInterestStoredDate: z
            .string()
            .datetime({ offset: true })
            .describe(`The date when interest was last applied on the account, in the organization's timezone and time format.`)
            .optional(),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last update date for the deposit account, in UTC.')
            .optional(),
        lastOverdraftInterestReviewDate: z
            .string()
            .datetime({ offset: true })
            .describe(`The date when the overdraft interest was last reviewed, in the organization's timezone and time format.`)
            .optional(),
        lastSetToArrearsDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                `The date when the deposit account was set to In Arrears, or null if the account is not In Arrears. The date is in the organization's timezone and time format.`,
            )
            .optional(),
        linkedSettlementAccountKeys: z
            .string()
            .array()
            .describe('Lists all loan account keys on which the deposit account is used as the settlement account.')
            .optional(),
        lockedDate: z
            .string()
            .datetime({ offset: true })
            .describe(`The date when the deposit account was locked, in the organization's timezone and time format.`)
            .optional(),
        maturityDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                `The date when the account matures, for fixed or compulsory savings plans, in the organization's timezone and time format.`,
            )
            .optional(),
        migrationEventKey: z
            .string()
            .describe(
                'The migration event encoded key associated with this deposit account. If this account was imported, you can track which migration event it came from.',
            )
            .optional(),
        name: z.string().describe('The deposit account name.'),
        notes: z.string().describe('The notes or description attached to this object.').optional(),
        overdraftInterestSettings: DepositAccountOverdraftInterestSettings.optional(),
        overdraftSettings: DepositAccountOverdraftSettings.optional(),
        ownershipHistory: DepositAccountOwnershipHistory.array().describe('The history of deposit account ownership').optional(),
        productTypeKey: z.string().describe('The key to the product type that this account is based on.'),
        withholdingTaxSourceKey: z
            .string()
            .describe('The tax source where the account withholding taxes will be updated.')
            .optional(),
    })
    .passthrough()
    .describe('Represents information about a deposit account.')

export type DepositAccount = z.infer<typeof DepositAccount>

export const CreditArrangementSortingCriteria = z
    .object({
        field: z.enum(['creationDate', 'startDate', 'expireDate', 'amount']).describe('Contains the actual sorting fields'),
        order: z.enum(['ASC', 'DESC']).describe('The sorting order: `ASC` or `DESC`. The default order is `DESC`.').optional(),
    })
    .describe('The sorting criteria used for credit arrangement client directed query')

export type CreditArrangementSortingCriteria = z.infer<typeof CreditArrangementSortingCriteria>

export const CreditArrangementFilterCriteria = z
    .object({
        field: z.union([
            z
                .enum(['id', 'startDate', 'expireDate', 'approvedDate', 'state', 'subState', 'exposureLimitType', 'encodedKey'])
                .describe('Contains the actual searching fields'),
            z.string(),
        ]),
        operator: z
            .enum([
                'EQUALS',
                'EQUALS_CASE_SENSITIVE',
                'DIFFERENT_THAN',
                'MORE_THAN',
                'LESS_THAN',
                'BETWEEN',
                'ON',
                'AFTER',
                'AFTER_INCLUSIVE',
                'BEFORE',
                'BEFORE_INCLUSIVE',
                'STARTS_WITH',
                'STARTS_WITH_CASE_SENSITIVE',
                'IN',
                'TODAY',
                'THIS_WEEK',
                'THIS_MONTH',
                'THIS_YEAR',
                'LAST_DAYS',
                'EMPTY',
                'NOT_EMPTY',
            ])
            .describe(
                '| **Operator**                | **Affected values**  | **Available for**                                                    |\\n|---------------               |----------------------|----------------------------------------------------------------------|\\n| EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |\\n| EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |\\n| MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |\\n| ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| STARTS_WITH                  | ONE_VALUE            | STRING                                                               |\\n| STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |\\n| IN                           | LIST                 | ENUM,KEY                                                             |\\n| TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |\\n| EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |\\n| NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |',
            ),
        secondValue: z
            .string()
            .describe('The second value to match the searching criteria, when the `BETWEEN` operator is used.')
            .optional(),
        value: z.string().describe('The value to match the searching criteria.').optional(),
        values: z.string().array().describe('List of values when the `IN` operator is used.').optional(),
    })
    .describe('Represents credit arrangment filter and search criteria.')

export type CreditArrangementFilterCriteria = z.infer<typeof CreditArrangementFilterCriteria>

export const DataImportError = z
    .object({
        column: DataImportErrorColumn.optional(),
        errorMessage: z.string().describe('Error message').optional(),
        row: z.number().int().describe('Row index').optional(),
        sheet: z.string().describe('Sheet name').optional(),
    })
    .describe('Holds information about the data import error')

export type DataImportError = z.infer<typeof DataImportError>

export const DepositAccountBalanceSummarySortingCriteria = z
    .object({
        field: z
            .enum(['encodedKey', 'id', 'productTypeKey', 'accountingDate'])
            .describe('The field to use to sort the selection. '),
        order: z.enum(['ASC', 'DESC']).describe('The sorting order: `ASC` or `DESC`. The default order is `DESC`.').optional(),
    })
    .describe('The sorting criteria used for searching deposit account balance summary.')

export type DepositAccountBalanceSummarySortingCriteria = z.infer<typeof DepositAccountBalanceSummarySortingCriteria>

export const DepositAccountBalanceSummaryFilterCriteria = z
    .object({
        field: z.union([
            z.enum(['encodedKey', 'id', 'productTypeKey', 'accountingDate']).describe('The fields to search.\\n'),
            z.string(),
        ]),
        operator: z
            .enum([
                'EQUALS',
                'EQUALS_CASE_SENSITIVE',
                'DIFFERENT_THAN',
                'MORE_THAN',
                'LESS_THAN',
                'BETWEEN',
                'ON',
                'AFTER',
                'AFTER_INCLUSIVE',
                'BEFORE',
                'BEFORE_INCLUSIVE',
                'STARTS_WITH',
                'STARTS_WITH_CASE_SENSITIVE',
                'IN',
                'TODAY',
                'THIS_WEEK',
                'THIS_MONTH',
                'THIS_YEAR',
                'LAST_DAYS',
                'EMPTY',
                'NOT_EMPTY',
            ])
            .describe(
                '| **Operator**                | **Affected values**  | **Available for**                                                    |\\n|---------------               |----------------------|----------------------------------------------------------------------|\\n| EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |\\n| EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |\\n| MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |\\n| ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| STARTS_WITH                  | ONE_VALUE            | STRING                                                               |\\n| STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |\\n| IN                           | LIST                 | ENUM,KEY                                                             |\\n| TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |\\n| EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |\\n| NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |',
            ),
        secondValue: z
            .string()
            .describe('The second value to match the searching criteria, when the `BETWEEN` operator is used.')
            .optional(),
        value: z.string().describe('The value to match the searching criteria.').optional(),
        values: z.string().array().describe('List of values when the `IN` operator is used.').optional(),
    })
    .describe('Represents the filter list used for searching deposit account balance summary.')

export type DepositAccountBalanceSummaryFilterCriteria = z.infer<typeof DepositAccountBalanceSummaryFilterCriteria>

export const DepositAccountSortingCriteria = z
    .object({
        field: z
            .enum([
                'encodedKey',
                'id',
                'name',
                'creationDate',
                'activationDate',
                'approvedDate',
                'lastModifiedDate',
                'maturityDate',
                'lastSetToArrearsDate',
                'closedDate',
                'accountHolderName',
                'accruedAmounts.interestAccrued',
                'accruedAmounts.overdraftInterestAccrued',
                'accruedAmounts.technicalOverdraftInterestAccrued',
                'maxBalance',
                'balances.availableBalance',
                'balances.blockedBalance',
                'balances.feesDue',
                'balances.lockedBalance',
                'balances.overdraftAmount',
                'balances.technicalOverdraftAmount',
                'balances.totalBalance',
                'balances.holdBalance',
                'balances.overdraftInterestDue',
                'assignedBranchKey',
                'assignedCentreKey',
                'assignedUserKey',
                'interestSettings.interestRate',
                'currentInterestTier.startingBalance',
                'currentInterestTier.endingBalance',
                'currentInterestTier.index',
                'currentInterestTier.interestRate',
                'currentOverdraftInterestTier.startingBalance',
                'currentOverdraftInterestTier.endingBalance',
                'currentOverdraftInterestTier.index',
                'currentOverdraftInterestTier.interestRate',
                'internalControls.maxWithdrawalAmount',
                'internalControls.recommendedDepositAmount',
                'internalControls.targetAmount',
                'notes',
                'taxApplied',
                'taxRate',
                'withholdingTaxSourceKey',
                'lengthInDays',
                'productCategory',
                'overdraftInterestSettings.interestRateSettings.interestSpread',
                'overdraftInterestSettings.interestRateSettings.interestRate',
                'overdraftSettings.allowOverdraft',
                'overdraftSettings.overdraftExpiryDate',
                'overdraftSettings.overdraftLimit',
                'overdraftDaysInArrears',
                'overdraftInArrears',
                'overdraftAvailableLimit',
            ])
            .describe(
                'The field to use to sort the selection. This can be an enumerated value or a custom field using the format [customFieldSetId].[customFieldId].',
            ),
        order: z.enum(['ASC', 'DESC']).describe('The sorting order: `ASC` or `DESC`. The default order is `DESC`.').optional(),
    })
    .describe('The sorting criteria used for searching deposit accounts.')

export type DepositAccountSortingCriteria = z.infer<typeof DepositAccountSortingCriteria>

export const DepositAccountFilterCriteria = z
    .object({
        field: z.union([
            z
                .enum([
                    'encodedKey',
                    'id',
                    'name',
                    'accountHolderKey',
                    'clientId',
                    'groupId',
                    'accountHolderName',
                    'accountState',
                    'accountType',
                    'creationDate',
                    'activationDate',
                    'approvedDate',
                    'lastModifiedDate',
                    'maturityDate',
                    'lastSetToArrearsDate',
                    'closedDate',
                    'accruedAmounts.interestAccrued',
                    'accruedAmounts.overdraftInterestAccrued',
                    'accruedAmounts.technicalOverdraftInterestAccrued',
                    'maxBalance',
                    'balances.availableBalance',
                    'balances.blockedBalance',
                    'balances.feesDue',
                    'balances.lockedBalance',
                    'balances.overdraftAmount',
                    'balances.overdraftInterestDue',
                    'balances.technicalOverdraftAmount',
                    'balances.totalBalance',
                    'balances.holdBalance',
                    'assignedBranchKey',
                    'assignedCentreKey',
                    'assignedUserKey',
                    'currencyCode',
                    'interestSettings.interestRate',
                    'currentInterestTier.endingBalance',
                    'currentInterestTier.index',
                    'currentInterestTier.interestRate',
                    'currentInterestTier.startingBalance',
                    'internalControls.maxWithdrawalAmount',
                    'internalControls.recommendedDepositAmount',
                    'internalControls.targetAmount',
                    'lengthInDays',
                    'overdraftRiskLevelKey',
                    'overdraftAvailableLimit',
                    'overdraftDaysInArrears',
                    'overdraftInArrears',
                    'overdraftInterestSettings.interestRateSettings.interestRate',
                    'overdraftInterestSettings.interestRateSettings.interestSpread',
                    'currentOverdraftInterestTier.endingBalance',
                    'currentOverdraftInterestTier.index',
                    'currentOverdraftInterestTier.interestRate',
                    'currentOverdraftInterestTier.startingBalance',
                    'overdraftSettings.overdraftExpiryDate',
                    'overdraftSettings.overdraftLimit',
                    'overdraftSettings.allowOverdraft',
                    'productTypeKey',
                    'productCategory',
                    'taxApplied',
                    'withholdingTaxSourceKey',
                    'taxRate',
                ])
                .describe(
                    'The fields to search, which can be enumerated values or custom fields using the format [customFieldSetId].[customFieldId].\\n',
                ),
            z.string(),
        ]),
        operator: z
            .enum([
                'EQUALS',
                'EQUALS_CASE_SENSITIVE',
                'DIFFERENT_THAN',
                'MORE_THAN',
                'LESS_THAN',
                'BETWEEN',
                'ON',
                'AFTER',
                'AFTER_INCLUSIVE',
                'BEFORE',
                'BEFORE_INCLUSIVE',
                'STARTS_WITH',
                'STARTS_WITH_CASE_SENSITIVE',
                'IN',
                'TODAY',
                'THIS_WEEK',
                'THIS_MONTH',
                'THIS_YEAR',
                'LAST_DAYS',
                'EMPTY',
                'NOT_EMPTY',
            ])
            .describe(
                '| **Operator**                | **Affected values**  | **Available for**                                                    |\\n|---------------               |----------------------|----------------------------------------------------------------------|\\n| EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |\\n| EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |\\n| MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |\\n| ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| STARTS_WITH                  | ONE_VALUE            | STRING                                                               |\\n| STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |\\n| IN                           | LIST                 | ENUM,KEY                                                             |\\n| TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |\\n| EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |\\n| NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |',
            ),
        secondValue: z
            .string()
            .describe('The second value to match the searching criteria, when the `BETWEEN` operator is used.')
            .optional(),
        value: z.string().describe('The value to match the searching criteria.').optional(),
        values: z.string().array().describe('List of values when the `IN` operator is used.').optional(),
    })
    .describe('Represents the filter list used for searching deposit accounts.')

export type DepositAccountFilterCriteria = z.infer<typeof DepositAccountFilterCriteria>

export const DepositTransactionSortingCriteria = z
    .object({
        field: z
            .enum([
                'id',
                'externalId',
                'parentAccountId',
                'productId',
                'valueDate',
                'creationDate',
                'amount',
                'branchId',
                'centreId',
                'tillId',
                'fees.name',
                'transactionDetails.transactionChannelId',
                'taxes.taxRate',
                'terms.interestSettings.interestRate',
                'terms.overdraftInterestSettings.interestRate',
                'terms.overdraftSettings.overdraftLimit',
                'affectedAmounts.interestAmount',
                'affectedAmounts.feesAmount',
                'accountBalances.totalBalance',
            ])
            .describe(
                'The field to use to sort the selection. The field can be an enumerated value or a custom field using the format [customFieldSetId].[customFieldId].',
            ),
        order: z.enum(['ASC', 'DESC']).describe('The sorting order: `ASC` or `DESC`. The default order is `DESC`.').optional(),
    })
    .describe('The sorting criteria used for Deposit transactions client directed query')

export type DepositTransactionSortingCriteria = z.infer<typeof DepositTransactionSortingCriteria>

export const DepositTransactionFilterCriteria = z
    .object({
        field: z.union([
            z
                .enum([
                    'encodedKey',
                    'id',
                    'externalId',
                    'holdExternalReferenceId',
                    'productID',
                    'currencyCode',
                    'branchID',
                    'branchKey',
                    'centreID',
                    'centreKey',
                    'tillID',
                    'tillKey',
                    'amount',
                    'affectedAmounts.fundsAmount',
                    'affectedAmounts.interestAmount',
                    'affectedAmounts.feesAmount',
                    'parentAccountKey',
                    'parentAccountID',
                    'productTypeKey',
                    'paymentOrderId',
                    'userKey',
                    'adjustmentTransactionID',
                    'adjustmentTransactionKey',
                    'originalTransactionKey',
                    'originalTransactionID',
                    'transactionDetails.transactionChannelKey',
                    'transactionDetails.transactionChannelId',
                    'type',
                    'creationDate',
                    'accountBalances.totalBalance',
                    'valueDate',
                    'taxes.taxRate',
                    'terms.interestSettings.interestRate',
                    'fees.trigger',
                    'fees.name',
                    'fees.predefinedFeeKey',
                    'wasAdjusted',
                    'typeIsAdjustment',
                    'affectedAmounts.overdraftAmount',
                    'affectedAmounts.overdraftInterestAmount',
                    'affectedAmounts.overdraftFeesAmount',
                    'affectedAmounts.technicalOverdraftAmount',
                    'affectedAmounts.technicalOverdraftInterestAmount',
                    'terms.overdraftInterestSettings.interestRate',
                    'terms.overdraftInterestSettings.indexInterestRate',
                ])
                .describe(
                    'The fields to search can be the enumerated values or a custom field using the format [customFieldSetId].[customFieldId].\\n|Field with limited capabilities          |Data Type |Operators   |\\n|-----------------------------------------|----------|------------|\\n|originalTransactionKey                   |KEY       |EQUALS, IN  |\\n|transactionDetails.transactionChannelId  |STRING    |EQUALS      |\\n|originalTransactionID                    |STRING    |EQUALS      |\\n',
                ),
            z.string(),
        ]),
        operator: z
            .enum([
                'EQUALS',
                'EQUALS_CASE_SENSITIVE',
                'DIFFERENT_THAN',
                'MORE_THAN',
                'LESS_THAN',
                'BETWEEN',
                'ON',
                'AFTER',
                'AFTER_INCLUSIVE',
                'BEFORE',
                'BEFORE_INCLUSIVE',
                'STARTS_WITH',
                'STARTS_WITH_CASE_SENSITIVE',
                'IN',
                'TODAY',
                'THIS_WEEK',
                'THIS_MONTH',
                'THIS_YEAR',
                'LAST_DAYS',
                'EMPTY',
                'NOT_EMPTY',
            ])
            .describe(
                '| **Operator**                | **Affected values**  | **Available for**                                                    |\\n|---------------               |----------------------|----------------------------------------------------------------------|\\n| EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |\\n| EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |\\n| MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |\\n| ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| STARTS_WITH                  | ONE_VALUE            | STRING                                                               |\\n| STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |\\n| IN                           | LIST                 | ENUM,KEY                                                             |\\n| TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |\\n| EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |\\n| NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |',
            ),
        secondValue: z
            .string()
            .describe('The second value to match the searching criteria, when the `BETWEEN` operator is used.')
            .optional(),
        value: z.string().describe('The value to match the searching criteria.').optional(),
        values: z.string().array().describe('List of values when the `IN` operator is used.').optional(),
    })
    .describe('The unit that composes the list used for Deposit transactions client directed searching')

export type DepositTransactionFilterCriteria = z.infer<typeof DepositTransactionFilterCriteria>

export const DisbursementTransferDetailsInput = z
    .object({
        linkedAccountId: z.string().describe('The id of the linked deposit account').optional(),
        linkedAccountKey: z.string().describe('The encoded key of the linked deposit account').optional(),
    })
    .describe('Represents the input for the transfer details for a disbursement transaction')

export type DisbursementTransferDetailsInput = z.infer<typeof DisbursementTransferDetailsInput>

export const FeeInput = z
    .object({
        amount: z.number().describe('The amount of the fee to apply').optional(),
        percentage: z.number().describe('The percentage of the fee to apply').optional(),
        predefinedFeeKey: z.string().describe('The encoded key of the predefined fee'),
    })
    .describe('An amount of predefined fee to apply on account.')

export type FeeInput = z.infer<typeof FeeInput>

export const PatchOperation = z
    .object({
        from: z.string().describe('The field from where a value should be moved, when using move').optional(),
        op: z.enum(['ADD', 'REPLACE', 'REMOVE', 'MOVE']).describe('The change to perform'),
        path: z.string().describe('The field to perform the operation on'),
        value: z.unknown().describe('The value of the field, can be null').optional(),
    })
    .describe('A single change that needs to be made to a resource')

export type PatchOperation = z.infer<typeof PatchOperation>

export const RestError = z.object({
    errorCode: z.number().int().optional(),
    errorReason: z.string().optional(),
    errorSource: z.string().optional(),
})

export type RestError = z.infer<typeof RestError>

export const DuplicateFieldConstraint = z
    .object({
        active: z.boolean().describe('The check will be performed if the field is true').optional(),
        dataField: z.string().describe('The ENUM data field when the field is an ENUM').optional(),
        dataItemType: z
            .enum([
                'LOANS',
                'SAVINGS',
                'CLIENT',
                'CLIENT_ROLE',
                'GROUP',
                'GROUP_ROLE',
                'TRANSACTION',
                'JOURNAL_ENTRY',
                'INTEREST_ACCRUAL_BREAKDOWN',
                'BRANCH',
                'CENTRE',
                'USER',
                'LOAN_PRODUCT',
                'SAVINGS_PRODUCT',
                'NOTIFICATION_MESSAGE',
                'NOTIFICATION_TEMPLATE',
                'REPAYMENT',
                'REPAYMENT_COLLECTION',
                'ACTIVITY',
                'LINE_OF_CREDIT',
                'IDENTIFICATION_DOCUMENT',
                'ATTACHMENT',
                'CURRENCY',
                'PRODUCT',
                'REVENUE',
                'EXPENSE',
                'OUTSTANDING_PORTFOLIO_ACCOUNTS',
                'OUTSTANDING_PORTFOLIO_AMOUNTS',
                'CREATED_ACCOUNTS',
                'WRITTEN_OFF_LOANS',
                'DISBURSED_LOANS',
                'LOAN_GROUP',
                'TRANCHE',
                'DISBURSEMENT_DETAILS',
                'TRANSACTION_DETAILS',
                'TRANSACTION_CHANNEL',
                'CUSTOM_PREDEFINED_FEE',
                'CUSTOM_FIELD_SELECTION',
                'PREDEFINED_FEE',
                'LOAN_TRANSACTION',
                'SAVINGS_TRANSACTION',
                'CARD_TRANSACTION_REVERSAL',
                'COMPOSED_TRANSACTIONS',
                'UNION_TRANSACTIONS',
                'INVESTOR_FUND',
                'PRINCIPAL_PAYMENT_SETTINGS',
                'LOAN_ACCOUNT_GUARANTY',
                'TASK',
                'DOCUMENT_TEMPLATE',
                'INDEX_RATE',
                'INDEX_RATE_SOURCE',
                'INTEREST_PRODUCT_SETTINGS',
                'MCC_EXPIRATION',
                'PRODUCT_ARREARS_SETTINGS',
                'ACCOUNT_INTEREST_RATE_SETTINGS',
                'LENDING_ACCOUNT_CONTRACT',
                'REVOLVING_ACCOUNT',
                'LENDING_PRODUCT_CONTRACT',
            ])
            .describe('The type of the owner (entity) to whom a data field belongs to')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the duplicate field constraint, auto generated, unique').optional(),
        groupIndex: z.number().int().describe('Used for creating an AND clause between constraints').optional(),
    })
    .describe('Represents a duplicate constraint which needs to apply when saving entities')

export type DuplicateFieldConstraint = z.infer<typeof DuplicateFieldConstraint>

export const DashboardConfiguration = z
    .object({
        creationDate: z.string().datetime({ offset: true }).describe('The date dashboard configuration was created').optional(),
        encodedKey: z.string().describe('The encoded key of the dashboard configuration, auto generated, unique').optional(),
        name: z
            .enum([
                'LATEST_ACTIVITY',
                'TASKS',
                'FAVOURITE_VIEWS',
                'INDICATORS',
                'CURRENT_TILLS',
                'CLIENTS',
                'UPCOMING_REPAYMENTS',
                'NONE',
            ])
            .describe('The Dashboard option name')
            .optional(),
    })
    .describe('Response representation of the dashboard configuration')

export type DashboardConfiguration = z.infer<typeof DashboardConfiguration>

export const DepositTransaction = z
    .object({
        accountBalances: DepositTransactionBalances.optional(),
        adjustmentTransactionKey: z
            .string()
            .describe(
                'The key of the deposit transaction where the adjustment for this transaction was made (if any adjustment was involved)',
            )
            .optional(),
        affectedAmounts: DepositAffectedAmounts.optional(),
        amount: z.number().describe('How much was added/removed in account').optional(),
        blockId: z.string().describe('The block fund id associated with the transaction').optional(),
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when corresponding JE is booked (as Organization Time)')
            .optional(),
        branchKey: z.string().describe('The branch where the transaction was performed').optional(),
        cardTransaction: CardTransaction.optional(),
        centreKey: z.string().describe('The center where the transaction was performed').optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when this deposit transaction was created')
            .optional(),
        currencyCode: z.string().describe('The currency in which this transaction was posted').optional(),
        customFieldsArchived: z.boolean().describe('Whether the custom fields of the transaction are archived').optional(),
        encodedKey: z.string().describe('The encoded key of the deposit transaction, auto generated, unique').optional(),
        externalId: z.string().describe('The external id of the deposit transaction, customizable, unique').optional(),
        fees: DepositFee.array()
            .describe('All the amounts that have been applied or paid within this transaction and involved predefined fees')
            .optional(),
        holdExternalReferenceId: z.string().describe('The external id of an account authorization hold').optional(),
        id: z.string().describe('The id of the deposit transaction, auto generated, unique').optional(),
        interestAccruedAmounts: DepositInterestAccruedAmounts.optional(),
        migrationEventKey: z
            .string()
            .describe(
                `The migration event encoded key associated with this deposit account. If this account was imported, track which 'migration event' they came from`,
            )
            .optional(),
        notes: z.string().describe('Extra notes about this deposit transaction').optional(),
        originalTransactionKey: z
            .string()
            .describe(
                'The encodedKey of the transaction that was adjusted as part of this one. Available only for adjustment transactions',
            )
            .optional(),
        parentAccountKey: z.string().describe('The key of the parent deposit account').optional(),
        paymentDetails: PaymentDetails.optional(),
        paymentOrderId: z.string().describe('The payment order id of the deposit transaction, customizable').optional(),
        taxes: DepositTaxes.optional(),
        terms: DepositTerms.optional(),
        tillKey: z.string().describe('The till key associated with this transaction').optional(),
        transactionDetails: TransactionDetails.optional(),
        transferDetails: TransferDetails.optional(),
        type: z
            .enum([
                'IMPORT',
                'WRITE_OFF',
                'WRITE_OFF_ADJUSTMENT',
                'DEPOSIT',
                'ADJUSTMENT',
                'WITHDRAWAL',
                'WITHDRAWAL_ADJUSTMENT',
                'CARD_TRANSACTION_REVERSAL',
                'CARD_TRANSACTION_REVERSAL_ADJUSTMENT',
                'TRANSFER',
                'TRANSFER_ADJUSTMENT',
                'FEE_APPLIED',
                'FEE_ADJUSTED',
                'FEES_DUE_REDUCED',
                'INTEREST_APPLIED',
                'INTEREST_APPLIED_ADJUSTMENT',
                'NET_DIFF_INTEREST',
                'PROFIT_APPLIED',
                'PROFIT_APPLIED_ADJUSTMENT',
                'FEE_REDUCTION_ADJUSTMENT',
                'WITHHOLDING_TAX',
                'WITHHOLDING_TAX_ADJUSTMENT',
                'INTEREST_RATE_CHANGED',
                'OVERDRAFT_INTEREST_RATE_CHANGED',
                'OVERDRAFT_LIMIT_CHANGED',
                'BRANCH_CHANGED',
                'ACCOUNT_HOLDER_CHANGED',
                'LOAN_FUNDED',
                'LOAN_FUNDED_ADJUSTMENT',
                'LOAN_REPAID',
                'LOAN_REPAID_ADJUSTMENT',
                'LOAN_FRACTION_BOUGHT',
                'LOAN_FRACTION_BOUGHT_ADJUSTMENT',
                'LOAN_FRACTION_SOLD',
                'LOAN_FRACTION_SOLD_ADJUSTMENT',
                'SEIZED_AMOUNT',
            ])
            .describe('The type of the deposit transaction')
            .optional(),
        userKey: z.string().describe('The person that performed the transaction').optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('Date of the entry (eg date of repayment or disbursal, etc.) (as Organization Time)')
            .optional(),
    })
    .passthrough()
    .describe(`Represents the action performed on an Deposit Account after which the account's amount changes its value.`)

export type DepositTransaction = z.infer<typeof DepositTransaction>

export const ExchangeRate = z
    .object({
        buyRate: z.number().describe('The buy exchange rate.').optional(),
        endDate: z.string().datetime({ offset: true }).describe('The exchange rate applies starting with this date.').optional(),
        fromCurrencyCode: z.string().describe('Organisation currency code').optional(),
        sellRate: z.number().describe('The sell exchange rate.').optional(),
        startDate: z
            .string()
            .datetime({ offset: true })
            .describe('The exchange rate applies starting with this date.')
            .optional(),
        toCurrencyCode: z.string().describe('Foreign currency code').optional(),
        userKey: z.string().describe('The key for the user that last modified the exchange rate.').optional(),
    })
    .describe('Model representation of an exchange rates.')

export type ExchangeRate = z.infer<typeof ExchangeRate>

export const Group = z
    .object({
        addresses: Address.array().describe('The addresses associated with this group.').optional(),
        assignedBranchKey: z.string().describe('Key of the branch this group is assigned to.').optional(),
        assignedCentreKey: z.string().describe('Key of the centre this group is assigned to.').optional(),
        assignedUserKey: z.string().describe('Key of the user this group is assigned to.').optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The date the group was created.').optional(),
        emailAddress: z.string().describe('The email address associated with the group.').optional(),
        encodedKey: z.string().describe('The encoded key of the group, which is auto generated, and must be unique.').optional(),
        groupMembers: GroupMember.array().describe('The members of this group.').optional(),
        groupName: z.string().describe('The name of the group.'),
        groupRoleKey: z.string().describe('A role which describes the intended use of a group in the system.').optional(),
        homePhone: z.string().describe('The home phone number associated with the group.').optional(),
        id: z.string().describe('The ID of the group, which can be generated and customized, but must be unique.').optional(),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('The last date the group was updated.').optional(),
        loanCycle: z
            .number()
            .int()
            .describe(
                `Number of paid and closed (with 'obligations met') accounts for this client. When the closing operation is reverted, this is reduced.`,
            )
            .optional(),
        migrationEventKey: z.string().describe('The migration event encoded key associated with this group.').optional(),
        mobilePhone: z.string().describe('The mobile phone number associated with the group.').optional(),
        notes: z.string().describe('Extra notes about this group.').optional(),
        preferredLanguage: z
            .enum([
                'ENGLISH',
                'PORTUGESE',
                'SPANISH',
                'RUSSIAN',
                'FRENCH',
                'GEORGIAN',
                'CHINESE',
                'INDONESIAN',
                'ROMANIAN',
                'BURMESE',
                'GERMAN',
                'PORTUGUESE_BRAZIL',
                'VIETNAMESE',
                'ITALIAN',
                'THAI',
                'NORWEGIAN',
                'PHRASE',
            ])
            .describe('The preferred language associated with the group (used for the notifications).')
            .optional(),
    })
    .passthrough()
    .describe(
        'Represents a group. A group is a type of client that can represent a non-physical person such as a company client or a grouping of individual clients. A group can have its own accounts and can optionally have individual clients as members, in which case they also need to have an individual profile in Mambu.',
    )

export type Group = z.infer<typeof Group>

export const IdentificationDocumentTemplate = z
    .object({
        allowAttachments: z.boolean().describe('`TRUE` if a template allows files to be attached, `FALSE` otherwise.').optional(),
        documentIdTemplate: z
            .string()
            .describe(
                'The ID template constraint to define the ID number length and format. Templates consist of the characters `#`, `@`, and `$`, where `#` specifies a number, `@` a letter, and `$` a number or a letter.',
            )
            .optional(),
        documentType: z.string().describe('The type of the document. For example, passport.').optional(),
        encodedKey: z.string().describe('The encoded key of the ID template. It is auto generated and unique.').optional(),
        id: z.string().describe('The unique identifier for the template.').optional(),
        issuingAuthority: z.string().describe('The authority that issued the document.').optional(),
        mandatory: z
            .boolean()
            .describe('`TRUE` if a template is mandatory for all the individual clients, `FALSE` otherwise.')
            .optional(),
    })
    .describe('Represents a template for identification documents.')

export type IdentificationDocumentTemplate = z.infer<typeof IdentificationDocumentTemplate>

export const LoanProduct = z
    .object({
        accountingSettings: AccountingSettings.optional(),
        accountLinkSettings: AccountLinkSettings.optional(),
        adjustInterestForFirstInstallment: z
            .boolean()
            .describe(
                '`TRUE` if it is possible to adjust the interest for the first repayment when the first repayment period is different than the repayment frequency, `FALSE` otherwise.',
            )
            .optional(),
        adjustTotalDueForInstallmentsWithDifferentInterval: z
            .boolean()
            .describe(
                '`TRUE` if it is possible to adjust the total due for the repayment when the repayment period is different than the repayment frequency, `FALSE` otherwise.',
            )
            .optional(),
        allowCustomRepaymentAllocation: z
            .boolean()
            .describe(
                '`TRUE` if an additional payment may be allocated on the account, ignoring the default repayment allocation order, `FALSE` otherwise.',
            )
            .optional(),
        arrearsSettings: ProductArrearsSettings.optional(),
        availabilitySettings: ProductAvailabilitySettings.optional(),
        category: z
            .enum(['PERSONAL_LENDING', 'PURCHASE_FINANCING', 'RETAIL_MORTGAGES', 'SME_LENDING', 'COMMERCIAL', 'UNCATEGORIZED'])
            .describe('The category of the loan product.')
            .optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The date the loan product was created.').optional(),
        creditArrangementSettings: CreditArrangementSettings,
        currency: Currency.optional(),
        encodedKey: z.string().describe('The encoded key of the loan product, it is auto generated, and unique.').optional(),
        feesSettings: FeesSettings.optional(),
        fundingSettings: FundingSettings.optional(),
        gracePeriodSettings: GracePeriodSettings.optional(),
        id: z.string().describe('The ID of the loan product, can be generated and customized, and must be unique.'),
        interestSettings: ProductInterestSettings.optional(),
        internalControls: InternalControls.optional(),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last date the loan product was updated.')
            .optional(),
        loanAmountSettings: LoanAmountSettings.optional(),
        name: z.string().describe('The name of the loan product.'),
        newAccountSettings: NewAccountSettings.optional(),
        notes: z.string().describe('The notes or description of the loan product.').optional(),
        offsetSettings: OffsetSettings.optional(),
        paymentSettings: PaymentSettings.optional(),
        penaltySettings: ProductPenaltySettings.optional(),
        redrawSettings: ProductRedrawSettings.optional(),
        scheduleSettings: LoanProductScheduleSettings.optional(),
        securitySettings: SecuritySettings.optional(),
        state: z.enum(['ACTIVE', 'INACTIVE']).describe('The current state of the loan product.').optional(),
        taxSettings: TaxSettings.optional(),
        templates: DocumentTemplate.array().describe('The template documents of the loan product.').optional(),
        type: z
            .enum([
                'FIXED_TERM_LOAN',
                'DYNAMIC_TERM_LOAN',
                'INTEREST_FREE_LOAN',
                'TRANCHED_LOAN',
                'REVOLVING_CREDIT',
                'INTEREST_ONLY_EQUAL_INSTALLMENTS',
                'DYNAMIC_MORTGAGE',
            ])
            .describe('The type of the loan product.'),
        useFeeIncludedInPMT: z
            .boolean()
            .describe('`TRUE` if Fee should be part of PMT calculation, `FALSE` otherwise.')
            .optional(),
    })
    .describe('Represents a loan product.')

export type LoanProduct = z.infer<typeof LoanProduct>

export const ApiConsumer = z
    .object({
        access: ApiConsumerAccess.optional(),
        assignedBranchKey: z.string().describe('The encoded key of the branch this API consumer is assigned to.').optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when the API consumer was created in UTC.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        id: z.string().describe('The ID of the API consumer.').optional(),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last time the API consumer was modified in UTC.')
            .optional(),
        name: z.string().describe('The API consumer name.'),
        role: RoleIdentifier.optional(),
        transactionLimits: z.record(z.number().optional()).describe('The API consumer transaction limits.').optional(),
    })
    .describe('Represents an API consumer.')

export type ApiConsumer = z.infer<typeof ApiConsumer>

export const Task = z
    .object({
        assignedUserKey: z.string().describe('The key of the user this task is assigned to.').optional(),
        createdByFullName: z.string().describe('The name of the user who created the task.').optional(),
        createdByUserKey: z
            .string()
            .describe(
                'The key of the user that created this task. The value is not editable and it is populated at task creation with the current user key.',
            )
            .optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The date when the task was created.').optional(),
        description: z.string().describe('The description of the task.').optional(),
        dueDate: z.string().date().describe('The due date when the task has to be completed.'),
        encodedKey: z.string().describe('The encoded key of the task, which is auto generated, and must be unique.').optional(),
        id: z.number().int().describe('The ID of the task, which is uniquely generated for the task.').optional(),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('The last date when the task was modified.').optional(),
        status: z
            .enum(['OPEN', 'COMPLETED'])
            .describe('The status of this task, a new task always has an `OPEN` status.')
            .optional(),
        taskLinkKey: z
            .string()
            .describe('The individual linked to this task. If null, it means nobody is linked to this task.')
            .optional(),
        taskLinkType: z
            .enum([
                'CLIENT',
                'GROUP',
                'LOAN_PRODUCT',
                'SAVINGS_PRODUCT',
                'CENTRE',
                'BRANCH',
                'USER',
                'LOAN_ACCOUNT',
                'DEPOSIT_ACCOUNT',
                'ID_DOCUMENT',
                'LINE_OF_CREDIT',
                'GL_JOURNAL_ENTRY',
            ])
            .describe('The type of the owner represented by the task link key.')
            .optional(),
        templateKey: z.string().describe('The template key used to create the task.').optional(),
        title: z.string().describe('The title of the task.').optional(),
    })
    .describe(
        `Represents a human task that can be assigned by one user to another. When a task is created, it's status is set to \`OPEN\`.`,
    )

export type Task = z.infer<typeof Task>

export const TransactionChannel = z
    .object({
        availableForAll: z
            .boolean()
            .describe('`TRUE` if the transaction channel is available for all users, `FALSE` otherwise.')
            .optional(),
        depositConstraints: Constraint,
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        glAccount: z.string().describe('The general ledger (GL) account associated with the transaction channel.').optional(),
        id: z.string().describe('The ID of the transaction channel.'),
        isDefault: z.boolean().describe('`TRUE` if the transaction channel is set as the default, `FALSE` otherwise.').optional(),
        loanConstraints: Constraint,
        name: z.string().describe('The name of the transaction channel.'),
        state: z.enum(['ACTIVE', 'INACTIVE']).describe('The state of the transaction channel.').optional(),
        usageRights: z.string().array().describe('The usage rights that describe the transaction channel.').optional(),
    })
    .describe('Represents a transaction channel.')

export type TransactionChannel = z.infer<typeof TransactionChannel>

export const Role = z
    .object({
        access: BaseUserAccess.optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The date when the role was created in UTC.').optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated automatically, globally unique.').optional(),
        id: z.string().describe('The ID of the role, which can be generated and customized, but must be unique.').optional(),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last time the role was modified in UTC.')
            .optional(),
        name: z.string().describe('The unique name of the role.'),
        notes: z.string().describe('The notes about the role.').optional(),
    })
    .describe('Represents a user role.')

export type Role = z.infer<typeof Role>

export const User = z
    .object({
        access: UserAccess,
        assignedBranchKey: z.string().describe('The encoded key of the branch this user is assigned to.').optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The date the user was created in UTC.').optional(),
        email: z
            .string()
            .describe('The user email address. Used by Mambu for sending automated notifications or for getting passwords.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        firstName: z.string().describe('The first name of the user.'),
        homePhone: z.string().describe(`The user's home phone number, which can also contain characters.`).optional(),
        id: z.string().describe('The ID of the user, which is generated automatically, but must be unique.').optional(),
        language: z
            .enum([
                'ENGLISH',
                'PORTUGESE',
                'SPANISH',
                'RUSSIAN',
                'FRENCH',
                'GEORGIAN',
                'CHINESE',
                'INDONESIAN',
                'ROMANIAN',
                'BURMESE',
                'GERMAN',
                'PORTUGUESE_BRAZIL',
                'VIETNAMESE',
                'ITALIAN',
                'THAI',
                'NORWEGIAN',
                'PHRASE',
            ])
            .describe(
                'The Mambu display language for the user. The Mambu UI will be displayed in the selected language. Please note: for portuguese, you must use the incorrect spelling `PORTUGESE`.',
            )
            .optional(),
        lastLoggedInDate: z.string().datetime({ offset: true }).describe('The last time the user logged in in UTC.').optional(),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last time the user was modified in UTC.')
            .optional(),
        lastName: z.string().describe('The last name of the user.').optional(),
        mobilePhone: z.string().describe(`The user's mobile phone number, which can also contain characters.`).optional(),
        notes: z.string().describe('The additional information for the user.').optional(),
        role: RoleIdentifier.optional(),
        title: z.string().describe('The user title.').optional(),
        transactionLimits: z.record(z.number().optional()).describe('The user transaction limits.').optional(),
        twoFactorAuthentication: z
            .boolean()
            .describe(
                '`TRUE` if the user has two-factor authentication setup, `FALSE` otherwise. If two-factor authentication is enabled, a user will be sent an SMS to their registered mobile number, which they will need to enter in the Mambu login screen, in addition to their password.',
            )
            .optional(),
        username: z.string().describe('The Mambu login user name.'),
        userState: z.enum(['ACTIVE', 'INACTIVE', 'LOCKED']).describe('The current state of the user.').optional(),
    })
    .passthrough()
    .describe('Represents a user.')

export type User = z.infer<typeof User>

export const CurrencyDetails = z
    .object({
        baseCurrency: z
            .boolean()
            .describe(
                `\`TRUE\` if the currency is the base currency, \`FALSE\` otherwise. It cannot be changed and it's a read-only field not required for update operations.`,
            ),
        code: z.string().describe('The currency code, which cannot be changed once the currency is created.'),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                `The date this currency was created. It cannot be changed and it's a read-only field not required for update operations.`,
            )
            .optional(),
        currencyHolidays: Holiday.array().describe('The list of holidays for this currency.').optional(),
        currencySymbolPosition: z.enum(['BEFORE_NUMBER', 'AFTER_NUMBER']).describe('The currency symbol position.'),
        digitsAfterDecimal: z.number().int().describe('The number of digits that are supported for a given currency.').optional(),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                `The last date this currency was modified. It's updated automatically and it's a read-only field not required for update operations.`,
            )
            .optional(),
        name: z.string().describe('The name of the currency.'),
        numericCode: z.string().describe('The currency numeric code.').optional(),
        symbol: z.string().describe('The currency symbol.'),
        type: z.enum(['FIAT_CURRENCY', 'CRYPTOCURRENCY', 'NON_TRADITIONAL_CURRENCY']).describe('The type of the currency.'),
    })
    .describe('Represents a currency.')

export type CurrencyDetails = z.infer<typeof CurrencyDetails>

export const Branch = z
    .object({
        addresses: Address.array().describe('The list of branch addresses.').optional(),
        branchHolidays: Holiday.array().describe('The list of branch holidays.').optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The creation date of the branch.').optional(),
        emailAddress: z.string().describe('The branch email address.').optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        id: z.string().describe('The branch ID, which must be unique.'),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last date when the branch was modified.')
            .optional(),
        name: z.string().describe('The branch name.'),
        notes: z.string().describe('The notes or description attached to this object.').optional(),
        phoneNumber: z.string().describe('The branch phone number.').optional(),
        state: z.enum(['ACTIVE', 'INACTIVE']).describe('The branch state.').optional(),
    })
    .passthrough()
    .describe('Represents a branch.')

export type Branch = z.infer<typeof Branch>

export const Centre = z
    .object({
        addresses: Address.array().describe('The addresses of this centre.').optional(),
        assignedBranchKey: z.string().describe('The encoded key of the branch this centre is assigned to.').optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The date the centre was created.').optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        id: z.string().describe('The ID of the centre, which must be unique, and can be generated and customized.').optional(),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('The last time the centre was modified.').optional(),
        meetingDay: z
            .string()
            .describe(
                'The day of the week when repayments are collected. This influences the repayments schedule, upon update all repayments are updated to this day of the week.',
            )
            .optional(),
        name: z.string().describe('The name of the centre.').optional(),
        notes: z.string().describe('The notes or description attached to this object.').optional(),
        state: z.enum(['ACTIVE', 'INACTIVE']).describe('The state of the centre.').optional(),
    })
    .passthrough()
    .describe(
        'Represents a centre. A centre is a common meeting area that credit officers and the individual and group clients go to. Each centre is assigned to a branch (a branch can have multiple centres) and might have a specific meeting day and location.',
    )

export type Centre = z.infer<typeof Centre>

export const Client = z
    .object({
        activationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when a client was set as active for the first time.')
            .optional(),
        addresses: Address.array().describe('The addresses associated with this client.').optional(),
        approvedDate: z.string().datetime({ offset: true }).describe('The date when a client was approved.').optional(),
        assignedBranchKey: z.string().describe('The encoded key of the branch a client is assigned to.').optional(),
        assignedCentreKey: z.string().describe('The encoded key of the centre a client is assigned to.').optional(),
        assignedUserKey: z.string().describe('The encoded key of the user a client is assigned to.').optional(),
        birthDate: z.string().date().describe(`The client's date of birth.`).optional(),
        clientRoleKey: z.string().describe('A role which describes the intended use of a client in the system.').optional(),
        closedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when the client state was changed to closed.')
            .optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The date a client was created.').optional(),
        emailAddress: z.string().describe(`The client's email address.`).optional(),
        encodedKey: z.string().describe('The encoded key of the client, which is unique and generated.').optional(),
        firstName: z.string().describe('The first name, personal name, given name, or forename of the client.'),
        gender: z.enum(['MALE', 'FEMALE']).describe(`The client's gender, the options are male or female.`).optional(),
        groupKeys: z.string().array().describe('The groups to which this client belongs.').optional(),
        groupLoanCycle: z
            .number()
            .int()
            .describe(
                `Number of paid and closed (with 'obligations met') accounts for a client's group; when the closing operation is reverted, this is reduced.`,
            )
            .optional(),
        homePhone: z.string().describe(`The client's home phone number.`).optional(),
        id: z.string().describe('The ID of the client, which can be generated and customized - but must be unique.').optional(),
        idDocuments: IdentificationDocument.array().describe('The identification documents for this client.').optional(),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('The last date a client was modified.').optional(),
        lastName: z.string().describe('The last name, surname, or family name of the client.'),
        loanCycle: z
            .number()
            .int()
            .describe(
                `Number of paid and closed (with 'obligations met') accounts for a client; when the closing operation is reverted, this is reduced.`,
            )
            .optional(),
        middleName: z.string().describe('The middle name of the client.').optional(),
        migrationEventKey: z.string().describe('The migration event encoded key associated with a client.').optional(),
        mobilePhone: z.string().describe(`The client's mobile phone number.`).optional(),
        mobilePhone2: z.string().describe(`The client's second mobile phone number.`).optional(),
        notes: z.string().describe('The additional notes about a client.').optional(),
        portalSettings: PortalSettings.optional(),
        preferredLanguage: z
            .enum([
                'ENGLISH',
                'PORTUGESE',
                'SPANISH',
                'RUSSIAN',
                'FRENCH',
                'GEORGIAN',
                'CHINESE',
                'INDONESIAN',
                'ROMANIAN',
                'BURMESE',
                'GERMAN',
                'PORTUGUESE_BRAZIL',
                'VIETNAMESE',
                'ITALIAN',
                'THAI',
                'NORWEGIAN',
                'PHRASE',
            ])
            .describe(
                `The client's preferred language. This will determine the language for the reports, schedules, and account statements you generate for the client.`,
            )
            .optional(),
        profilePictureKey: z.string().describe(`The encoded key of a client's profile picture.`).optional(),
        profileSignatureKey: z.string().describe(`The encoded key of the client's profile signature.`).optional(),
        state: z
            .enum(['PENDING_APPROVAL', 'INACTIVE', 'ACTIVE', 'EXITED', 'BLACKLISTED', 'REJECTED'])
            .describe('The state of a client. It shows where the client is in the client life cycle.')
            .optional(),
    })
    .passthrough()
    .describe('Represents a client.')

export type Client = z.infer<typeof Client>

export const CreditArrangement = z
    .object({
        amount: z.number().describe('The maximum credit amount the client can be exposed to.'),
        approvedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when the credit arrangement was approved.')
            .optional(),
        availableCreditAmount: z.number().describe('The available amount of the credit arrangement.').optional(),
        closedDate: z.string().datetime({ offset: true }).describe('The date when the credit arrangement was closed.').optional(),
        consumedCreditAmount: z
            .number()
            .describe(
                'The consumed amount of the credit arrangement, which is calculated as the difference between the amount and available amount.',
            )
            .optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when the credit arrangement was created.')
            .optional(),
        currency: Currency.optional(),
        encodedKey: z
            .string()
            .describe('The encoded key of the credit arrangement, it is auto generated, and unique.')
            .optional(),
        expireDate: z.string().datetime({ offset: true }).describe('The date when the credit arrangement expires.'),
        exposureLimitType: z
            .enum(['APPROVED_AMOUNT', 'OUTSTANDING_AMOUNT'])
            .describe('The type of exposure limit calculation method used for the credit arrangement.')
            .optional(),
        holderKey: z
            .string()
            .describe('The encoded key of the credit arrangement holder (individual client or group).')
            .optional(),
        holderType: z
            .enum(['CLIENT', 'GROUP'])
            .describe('The type of the credit arrangement holder (individual client or group).'),
        id: z.string().describe('The ID of credit arrangement, can be generated and customized, and must be unique.').optional(),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last date when the credit arrangement was modified.')
            .optional(),
        notes: z.string().describe('The notes or description of the credit arrangement.').optional(),
        startDate: z
            .string()
            .datetime({ offset: true })
            .describe('The start date from which the credit arrangement became active.'),
        state: z
            .enum(['PENDING_APPROVAL', 'APPROVED', 'ACTIVE', 'CLOSED', 'WITHDRAWN', 'REJECTED'])
            .describe('The state of the credit arrangement.')
            .optional(),
        subState: z
            .enum(['PENDING_APPROVAL', 'APPROVED', 'ACTIVE', 'CLOSED', 'WITHDRAWN', 'REJECTED'])
            .describe('The substate of credit arrangement.')
            .optional(),
    })
    .passthrough()
    .describe('Represents a credit arrangement.')

export type CreditArrangement = z.infer<typeof CreditArrangement>

export const CustomFieldSetMeta = z
    .object({
        availableFor: z
            .enum([
                'CLIENT',
                'GROUP',
                'CREDIT_ARRANGEMENT',
                'LOAN_ACCOUNT',
                'GUARANTOR',
                'ASSET',
                'DEPOSIT_ACCOUNT',
                'DEPOSIT_PRODUCT',
                'TRANSACTION_CHANNEL',
                'TRANSACTION_TYPE',
                'BRANCH',
                'CENTRE',
                'USER',
            ])
            .describe(
                'Indicates the entity that the custom field set is associated with (eg. clients or any entity that allows CF definition)',
            )
            .optional(),
        creationDate: z.string().datetime({ offset: true }).describe('Date at which the custom field set was created').optional(),
        customFields: CustomFieldIdentity.array()
            .describe('This section lists all the custom fields associated with this set')
            .optional(),
        description: z
            .string()
            .describe('Free text field to store eventual notes with regard to custom field group purpose/details')
            .optional(),
        displaySettings: CustomFieldSetDisplaySettings.optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        fieldSetType: z
            .enum(['STANDARD', 'GROUPED'])
            .describe(
                'The usage decides how the custom field set will be used in the UI and how the custom field values will be stored. For STANDARD set type the custom field set can be used only once (i.e Personal Information). For GROUPED set type the custom field set can be used multiple times (i.e Addresses). For further details please see [here](https://support.mambu.com/customer/en/portal/articles/1986000-custom-fields?b_id=873#2)',
            )
            .optional(),
        id: z.string().describe('User-defined ID, gobally unique').optional(),
    })
    .describe('Model representation of a Custom Field Set')

export type CustomFieldSetMeta = z.infer<typeof CustomFieldSetMeta>

export const DepositAccountBalanceSummary = z
    .object({
        avgBalance: z.number().describe('The average balance for the entry date').optional(),
        encodedKey: z.string().describe('The encoded key of the deposit account').optional(),
        entryDate: z.string().date().describe('The date for which the balance summary are calculated').optional(),
        id: z.string().describe('The ID of the deposit account').optional(),
        minBalance: z.number().describe('The minimum balance for the entry date').optional(),
        totalBalance: z.number().describe('The total balance for the entry date').optional(),
    })
    .describe(
        'Represents balance summary for a deposit account including average, total, and minimum balances for a specific entry date.',
    )

export type DepositAccountBalanceSummary = z.infer<typeof DepositAccountBalanceSummary>

export const DepositProduct = z
    .object({
        accountingSettings: DepositProductAccountingSettings,
        availabilitySettings: DepositProductAvailabilitySettings.optional(),
        category: z
            .enum([
                'PERSONAL_DEPOSIT',
                'BUSINESS_DEPOSIT',
                'DAILY_BANKING_ACCOUNTS',
                'BUSINESS_BANKING_ACCOUNTS',
                'STORED_VALUE_ACCOUNTS',
                'UNCATEGORIZED',
            ])
            .describe('Indicates the category that the product belongs to')
            .optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The date this product was created').optional(),
        creditArrangementSettings: CreditArrangementSettings.optional(),
        currencySettings: DepositProductCurrencySettings.optional(),
        encodedKey: z.string().describe('The encoded key of the deposit product, auto generated, unique').optional(),
        feesSettings: DepositProductFeeSettings.optional(),
        id: z.string().describe('The id of the product, can be generated and customized, unique'),
        interestSettings: DepositProductInterestSettings.optional(),
        internalControls: DepositProductInternalControls.optional(),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('The last date the product was updated').optional(),
        maturitySettings: DepositMaturitySettings.optional(),
        name: z.string().describe('The name of the product'),
        newAccountSettings: DepositNewAccountSettings,
        notes: z.string().describe('Some notes/a description about the product').optional(),
        offsetSettings: DepositProductOffsetSettings.optional(),
        overdraftInterestSettings: OverdraftInterestSettings.optional(),
        overdraftSettings: DepositProductOverdraftSettings.optional(),
        state: z.enum(['ACTIVE', 'INACTIVE']).describe('Indicates the current state of the product'),
        taxSettings: DepositProductTaxSettings.optional(),
        templates: DocumentTemplate.array().describe('Template documents of the product.').optional(),
        type: z
            .enum(['CURRENT_ACCOUNT', 'REGULAR_SAVINGS', 'FIXED_DEPOSIT', 'SAVINGS_PLAN', 'INVESTOR_ACCOUNT'])
            .describe('Indicates the type of product.'),
    })
    .passthrough()
    .describe('A deposit product defines the terms and constraints on deposit accounts')

export type DepositProduct = z.infer<typeof DepositProduct>

export const GetAuthorizationHold = z
    .object({
        accountKey: z.string().describe('The key of the account linked with the authorization hold.').optional(),
        advice: z.boolean().describe('Whether the given request should be accepted without balance validations.'),
        amount: z.number().describe('The amount of money to be held as a result of the authorization hold request.'),
        balances: AccountBalances.optional(),
        cardAcceptor: CardAcceptor.optional(),
        cardToken: z.string().describe('The reference token of the card.').optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The organization time when the authorization hold was created')
            .optional(),
        creditDebitIndicator: z
            .enum(['DBIT', 'CRDT'])
            .describe(
                'Indicates whether the authorization hold amount is credited or debited.If not provided, the default values is DBIT.',
            )
            .optional(),
        currencyCode: z
            .string()
            .describe(
                'The ISO currency code in which the hold was created. The amounts are stored in the base currency, but the user could have enter it in a foreign currency.',
            )
            .optional(),
        customExpirationPeriod: z
            .number()
            .int()
            .describe('The custom expiration period for the hold which overwrites mcc and default expiration periods')
            .optional(),
        encodedKey: z.string().describe('The internal ID of the authorization hold, auto generated, unique.').optional(),
        exchangeRate: z.number().describe('The exchange rate for the original currency.').optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID to be used to reference the account hold in subsequent requests.'),
        originalAmount: z
            .number()
            .describe('The original amount of money to be held as a result of the authorization hold request.')
            .optional(),
        originalCurrency: z.string().describe('The original currency in which the hold was created.').optional(),
        partial: z.boolean().describe('Indicates whether the authorization is partial or not').optional(),
        referenceDateForExpiration: z
            .string()
            .datetime({ offset: true })
            .describe('The date to consider as start date when calculating the number of days passed until expiration')
            .optional(),
        source: z
            .enum(['CARD', 'ACCOUNT'])
            .describe('Indicates the source of the authorization hold, the default values is CARD.')
            .optional(),
        status: z.enum(['PENDING', 'REVERSED', 'SETTLED', 'EXPIRED']).describe('The authorization hold status.').optional(),
        userTransactionTime: z.string().describe('The formatted time at which the user made this authorization hold.').optional(),
    })
    .describe('Details for retrieving a authorization hold. Deprecated due to encodedKey field.')

export type GetAuthorizationHold = z.infer<typeof GetAuthorizationHold>

export const BlockFund = z
    .object({
        accountKey: z.string().describe('The key of the account which block fund belongs to').optional(),
        amount: z.number().describe('The amount to be blocked'),
        creationDate: z.string().datetime({ offset: true }).describe('The date at which the block fund was created').optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID to be used to reference the block fund in subsequent requests'),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date at which the block fund was created')
            .optional(),
        notes: z.string().describe('Notes about this block fund').optional(),
        seizedAmount: z.number().describe('The amount that has been seized').optional(),
        state: z.enum(['PENDING', 'SEIZED', 'REMOVED', 'PARTIALLY_SEIZED']).describe('The state of the block fund').optional(),
    })
    .describe('Represents the block fund amount that can be later seized on the account')

export type BlockFund = z.infer<typeof BlockFund>

export const CustomFieldMeta = z
    .object({
        availableFor: z
            .enum([
                'CLIENT',
                'GROUP',
                'CREDIT_ARRANGEMENT',
                'LOAN_ACCOUNT',
                'GUARANTOR',
                'ASSET',
                'DEPOSIT_ACCOUNT',
                'DEPOSIT_PRODUCT',
                'TRANSACTION_CHANNEL',
                'TRANSACTION_TYPE',
                'BRANCH',
                'CENTRE',
                'USER',
            ])
            .describe('The entity type the custom field definition is associated with.')
            .optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date the custom field definition was created.')
            .optional(),
        dependentFieldKey: z
            .string()
            .describe(
                'Can be defined only for selection custom field definitions. Indicates the parent custom field definition on which the dependency is based upon.',
            )
            .optional(),
        displaySettings: CustomFieldDisplaySettings.optional(),
        editRights: CustomFieldEditRights.optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        id: z.string().describe('The user-defined ID, which is globally unique.').optional(),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date the latest update was performed for this custom field definition.')
            .optional(),
        selectionOptions: CustomFieldSelectionOption.array()
            .describe(
                'Can be defined only for selection custom field definitions. Indicates that the field has predefined selections and only those can be used to populate it.',
            )
            .optional(),
        state: z
            .enum(['ACTIVE', 'INACTIVE'])
            .describe('Indicates whether the custom field definition is active or inactive.')
            .optional(),
        type: z
            .enum(['FREE_TEXT', 'SELECTION', 'NUMBER', 'CHECKBOX', 'DATE', 'DATE_TIME', 'CLIENT_LINK', 'GROUP_LINK', 'USER_LINK'])
            .describe('The type of custom field definition.')
            .optional(),
        usage: CustomFieldUsage.array().describe('Represents the usage settings of a custom field definition.').optional(),
        valueValidationSettings: CustomFieldValueValidationSettings.optional(),
        viewRights: CustomFieldViewRights.optional(),
    })
    .describe('Represents a custom field definition.')

export type CustomFieldMeta = z.infer<typeof CustomFieldMeta>

export const Card = z
    .object({
        referenceToken: z.string().describe(`The card's reference token.`),
    })
    .describe(
        'Returns a card that can be associated to a deposit or loan  account. Cards consist only of card reference tokens and the card details are not stored in Mambu.',
    )

export type Card = z.infer<typeof Card>

export const IndexRateSource = z
    .object({
        creationDate: z.string().datetime({ offset: true }).describe('The creation date of the index rate source').optional(),
        encodedKey: z
            .string()
            .describe('The encoded key of the index rate source, which is auto generated, and unique.')
            .optional(),
        id: z
            .string()
            .describe('The ID of the index rate source, which can be generated and customized, and must be unique.')
            .optional(),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last date this rate source was modified')
            .optional(),
        name: z.string().describe('The name of the index rate source.').optional(),
        notes: z.string().describe('The notes about the the index rate source.').optional(),
        type: z
            .enum(['INTEREST_RATE', 'TAX_RATE', 'WITHHOLDING_TAX_RATE', 'PRINCIPAL_TAX_RATE'])
            .describe('The type of index rate source.')
            .optional(),
    })
    .describe('Represents an index rate source.')

export type IndexRateSource = z.infer<typeof IndexRateSource>

export const IndexRate = z
    .object({
        assignedIndexRateSourceKey: z.string().describe('The index rate source that the index rate belongs to.').optional(),
        encodedKey: z.string().describe('The encoded key of the index rate, which is auto generated, and unique.').optional(),
        id: z
            .string()
            .describe('The ID of the index rate, which can be generated and customized, and must be unique.')
            .optional(),
        notes: z.string().describe('The notes or description attached to this object.').optional(),
        rate: z.number().describe('The percentage value of the index rate.').optional(),
        startDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when the index rate starts being the active rate for its source.')
            .optional(),
        userKey: z.string().describe('The key for the user that last modified the index rate.').optional(),
    })
    .describe('Represents an index rate.')

export type IndexRate = z.infer<typeof IndexRate>

export const CardTransactionReversal = z
    .object({
        amount: z
            .number()
            .describe(`The amount of money to be credited in the client's account from the original card transaction.`),
        currencyCode: z
            .string()
            .describe(
                'The ISO currency code in which the card reversal transaction is posted. The amounts are stored in the base currency, but the transaction can be created with a foreign currency.',
            )
            .optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID to be used to reference the card reversal transaction in subsequent requests.'),
        id: z.number().int().describe('The id of the Deposit Transaction').optional(),
        transactionChannelId: z
            .string()
            .describe(
                'The ID of the channel through which the payment is done. If the value is not present, the value from the source card transaction is copied.',
            )
            .optional(),
    })
    .describe('A full or partial reversal of a card transaction.')

export type CardTransactionReversal = z.infer<typeof CardTransactionReversal>

export const Comment = z
    .object({
        creationDate: z.string().datetime({ offset: true }).describe('The creation date of the comment.').optional(),
        encodedKey: z.string().describe(`The comments's encoded key, which is auto-generated and unique.`).optional(),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last date when this comment was modified.')
            .optional(),
        ownerKey: z.string().describe('The encoded key of the entity that owns this comment.').optional(),
        ownerType: z
            .enum([
                'CLIENT',
                'GROUP',
                'LOAN_PRODUCT',
                'SAVINGS_PRODUCT',
                'CENTRE',
                'BRANCH',
                'USER',
                'LOAN_ACCOUNT',
                'DEPOSIT_ACCOUNT',
                'ID_DOCUMENT',
                'LINE_OF_CREDIT',
                'GL_JOURNAL_ENTRY',
            ])
            .describe('The type of the entity that owns this comment.')
            .optional(),
        text: z.string().describe('The message in the comment.').optional(),
        userKey: z.string().describe(`The user's key.`).optional(),
    })
    .describe('Represents information about the comment data transfer object.')

export type Comment = z.infer<typeof Comment>

export const InterestAccountSettingsAvailabilityResponse = z
    .object({
        encodedKey: z.string().describe('The encoded key of the Interest Availability, auto generated, unique.').optional(),
        interestRateSettings: DepositAccountInterestRateSettings.optional(),
        startDate: z.string().date().describe('Start date of the Interest Availability.').optional(),
        type: z.enum(['INTEREST', 'OVERDRAFT', 'TECHNICAL_OVERDRAFT']).describe('Type of the interest.').optional(),
    })
    .describe('Interest Availability of a Deposit Account')

export type InterestAccountSettingsAvailabilityResponse = z.infer<typeof InterestAccountSettingsAvailabilityResponse>

export const ApiKey = z
    .object({
        apiKey: z
            .string()
            .describe(
                'A six character cleartext prefix of the API key. The prefix is not guaranteed to be unique. You must base any identification process on the API key ID, not the prefix.',
            )
            .optional(),
        expirationTime: z.number().int().nonnegative().describe('The time to live (TTL) for the API key in seconds.').optional(),
        id: z
            .string()
            .describe(
                'The API key ID. You must base any identification process on the the API key ID as it is guaranteed to be unique.',
            )
            .optional(),
    })
    .describe('Represents an API key of an API consumer.')

export type ApiKey = z.infer<typeof ApiKey>

export const LoanAccountRepaymentScheduleVersioning = z
    .object({
        encodedKey: z.string().describe('The encoded key of the versioning.').optional(),
        id: z.number().int().describe('The repayment schedule versioning ID.').optional(),
        loanAccountChangedEventKey: z.string().describe('The loan account event which triggered the versioning.').optional(),
        loanTransactionKey: z.string().describe('The loan transaction key which triggered the versioning.').optional(),
        versioningContent: Installment.array().describe('The loan account repayment schedule versioning list.').optional(),
    })
    .describe('Represents a single repayment versioning details structure.')

export type LoanAccountRepaymentScheduleVersioning = z.infer<typeof LoanAccountRepaymentScheduleVersioning>

export const AccountTax = z
    .object({
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when the rate availability was created.')
            .optional(),
        fromDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when the tax source starts to be used by the account.')
            .optional(),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last date when the rate availability was modified.')
            .optional(),
        rateSourceEncodedKey: z.string().optional(),
        rateSourceId: z.string().describe('The id of the source').optional(),
        rateSourceName: z.string().describe('The name of the source').optional(),
        savingsAccountEncodedKey: z.string().optional(),
        toDate: z
            .string()
            .datetime({ offset: true })
            .describe('The ending date of the tax source used by the account')
            .optional(),
    })
    .describe('The account tax corresponding for deposit account')

export type AccountTax = z.infer<typeof AccountTax>

export const GLJournalEntrySortingCriteria = z
    .object({
        field: z
            .enum([
                'encodedKey',
                'entryId',
                'bookingDate',
                'creationDate',
                'transactionId',
                'glAccountName',
                'glAccountId',
                'glAccountType',
                'debit',
                'credit',
                'foreignDebit',
                'foreignCredit',
                'loanAccountId',
                'userName',
                'user',
                'branchName',
                'foreignCurrency',
            ])
            .describe(
                'The field that can be used to sort the selection. These fields can be from the enumerated values or you can specify a custom field using the format [customFieldSetId].[customFieldId].',
            ),
        order: z.enum(['ASC', 'DESC']).describe('The sorting order: `ASC` or `DESC`. The default order is `DESC`.').optional(),
    })
    .describe('Represents the sorting criteria used for general ledger journal entries.')

export type GLJournalEntrySortingCriteria = z.infer<typeof GLJournalEntrySortingCriteria>

export const GLJournalEntryFilterCriteria = z
    .object({
        field: z.union([
            z
                .enum([
                    'productType',
                    'glAccountKey',
                    'userKey',
                    'encodedKey',
                    'entryId',
                    'bookingDate',
                    'creationDate',
                    'transactionId',
                    'glAccountId',
                    'glAccountType',
                    'source',
                    'debit',
                    'credit',
                    'foreignDebit',
                    'foreignCredit',
                    'loanAccountId',
                    'foreignCurrencyCode',
                    'assignedBranchKey',
                ])
                .describe(
                    'The fields used to search. These fields can be from the enumerated values or you can specify a custom field using the format [customFieldSetId].[customFieldId].',
                ),
            z.string(),
        ]),
        operator: z
            .enum([
                'EQUALS',
                'EQUALS_CASE_SENSITIVE',
                'DIFFERENT_THAN',
                'MORE_THAN',
                'LESS_THAN',
                'BETWEEN',
                'ON',
                'AFTER',
                'AFTER_INCLUSIVE',
                'BEFORE',
                'BEFORE_INCLUSIVE',
                'STARTS_WITH',
                'STARTS_WITH_CASE_SENSITIVE',
                'IN',
                'TODAY',
                'THIS_WEEK',
                'THIS_MONTH',
                'THIS_YEAR',
                'LAST_DAYS',
                'EMPTY',
                'NOT_EMPTY',
            ])
            .describe(
                '| **Operator**                | **Affected values**  | **Available for**                                                    |\\n|---------------               |----------------------|----------------------------------------------------------------------|\\n| EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |\\n| EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |\\n| MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |\\n| ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| STARTS_WITH                  | ONE_VALUE            | STRING                                                               |\\n| STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |\\n| IN                           | LIST                 | ENUM,KEY                                                             |\\n| TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |\\n| EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |\\n| NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |',
            ),
        secondValue: z
            .string()
            .describe('The second value to match the searching criteria, when the `BETWEEN` operator is used.')
            .optional(),
        value: z.string().describe('The value to match the searching criteria.').optional(),
        values: z.string().array().describe('List of values when the `IN` operator is used.').optional(),
    })
    .describe('Represents the filtering criteria used for searching general ledger journal entries.')

export type GLJournalEntryFilterCriteria = z.infer<typeof GLJournalEntryFilterCriteria>

export const GroupSortingCriteria = z
    .object({
        field: z
            .enum([
                'encodedKey',
                'id',
                'creationDate',
                'groupName',
                'lastModifiedDate',
                'depositsBalance',
                'loansBalance',
                'totalBalance',
                'loanCycle',
            ])
            .describe(
                'The field to sort by. It can be a native field (one from the provided list) or otherwise can specify a custom field definitionusing the format [customFieldSetId].[customFieldId].',
            ),
        order: z.enum(['ASC', 'DESC']).describe('The sorting order: `ASC` or `DESC`. The default order is `DESC`.').optional(),
    })
    .describe('The sorting criteria used for Groups search')

export type GroupSortingCriteria = z.infer<typeof GroupSortingCriteria>

export const GroupFilterCriteria = z
    .object({
        field: z.union([
            z
                .enum([
                    'encodedKey',
                    'id',
                    'creationDate',
                    'groupRoleKey',
                    'branchKey',
                    'centreKey',
                    'creditOfficerKey',
                    'groupName',
                    'lastModifiedDate',
                    'preferredLanguage',
                    'depositsBalance',
                    'loansBalance',
                    'totalBalance',
                    'numberOfMembers',
                    'loanCycle',
                ])
                .describe(
                    'The fields to perform the search. They can be native (one from the provided list) or otherwise can specify a custom field definition using the format [customFieldSetId].[customFieldId].\\n',
                ),
            z.string(),
        ]),
        operator: z
            .enum([
                'EQUALS',
                'EQUALS_CASE_SENSITIVE',
                'DIFFERENT_THAN',
                'MORE_THAN',
                'LESS_THAN',
                'BETWEEN',
                'ON',
                'AFTER',
                'AFTER_INCLUSIVE',
                'BEFORE',
                'BEFORE_INCLUSIVE',
                'STARTS_WITH',
                'STARTS_WITH_CASE_SENSITIVE',
                'IN',
                'TODAY',
                'THIS_WEEK',
                'THIS_MONTH',
                'THIS_YEAR',
                'LAST_DAYS',
                'EMPTY',
                'NOT_EMPTY',
            ])
            .describe(
                '| **Operator**                | **Affected values**  | **Available for**                                                    |\\n|---------------               |----------------------|----------------------------------------------------------------------|\\n| EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |\\n| EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |\\n| MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |\\n| ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| STARTS_WITH                  | ONE_VALUE            | STRING                                                               |\\n| STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |\\n| IN                           | LIST                 | ENUM,KEY                                                             |\\n| TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |\\n| EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |\\n| NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |',
            ),
        secondValue: z
            .string()
            .describe('The second value to match the searching criteria, when the `BETWEEN` operator is used.')
            .optional(),
        value: z.string().describe('The value to match the searching criteria.').optional(),
        values: z.string().array().describe('List of values when the `IN` operator is used.').optional(),
    })
    .describe('The unit that composes the list used for Groups searching')

export type GroupFilterCriteria = z.infer<typeof GroupFilterCriteria>

export const InterestAccrualSortingCriteria = z
    .object({
        field: z
            .enum([
                'entryId',
                'parentEntryId',
                'bookingDate',
                'creationDate',
                'transactionId',
                'glAccountType',
                'debit',
                'credit',
                'accountId',
                'foreignCredit',
                'foreignDebit',
                'foreignCurrencyCode',
            ])
            .describe('The field to use as the sorting criteria.'),
        order: z.enum(['ASC', 'DESC']).describe('The sorting order: `ASC` or `DESC`. The default order is `DESC`.').optional(),
    })
    .describe('The sorting criteria used for sorting interest accrual entries.')

export type InterestAccrualSortingCriteria = z.infer<typeof InterestAccrualSortingCriteria>

export const InterestAccrualFilterCriteria = z
    .object({
        field: z.union([
            z
                .enum([
                    'entryId',
                    'glAccountKey',
                    'parentEntryId',
                    'productType',
                    'bookingDate',
                    'creationDate',
                    'transactionId',
                    'glAccountId',
                    'glAccountType',
                    'debit',
                    'credit',
                    'branchKey',
                    'accountKey',
                    'productKey',
                    'accountId',
                    'foreignCredit',
                    'foreignDebit',
                    'foreignCurrencyCode',
                ])
                .describe('Contains the fields to use for searching.'),
            z.string(),
        ]),
        operator: z
            .enum([
                'EQUALS',
                'EQUALS_CASE_SENSITIVE',
                'DIFFERENT_THAN',
                'MORE_THAN',
                'LESS_THAN',
                'BETWEEN',
                'ON',
                'AFTER',
                'AFTER_INCLUSIVE',
                'BEFORE',
                'BEFORE_INCLUSIVE',
                'STARTS_WITH',
                'STARTS_WITH_CASE_SENSITIVE',
                'IN',
                'TODAY',
                'THIS_WEEK',
                'THIS_MONTH',
                'THIS_YEAR',
                'LAST_DAYS',
                'EMPTY',
                'NOT_EMPTY',
            ])
            .describe(
                '| **Operator**                | **Affected values**  | **Available for**                                                    |\\n|---------------               |----------------------|----------------------------------------------------------------------|\\n| EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |\\n| EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |\\n| MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |\\n| ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| STARTS_WITH                  | ONE_VALUE            | STRING                                                               |\\n| STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |\\n| IN                           | LIST                 | ENUM,KEY                                                             |\\n| TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |\\n| EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |\\n| NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |',
            ),
        secondValue: z
            .string()
            .describe('The second value to match the searching criteria, when the `BETWEEN` operator is used.')
            .optional(),
        value: z.string().describe('The value to match the searching criteria.').optional(),
        values: z.string().array().describe('List of values when the `IN` operator is used.').optional(),
    })
    .describe('Represents the filter criteria used for searching interest accrual entries.')

export type InterestAccrualFilterCriteria = z.infer<typeof InterestAccrualFilterCriteria>

export const PayOffAdjustableAmounts = z
    .object({
        feesPaid: z.number().describe('The fee amount to be paid for Pay Off action').optional(),
        interestFromArrearsPaid: z.number().describe('The interest from arrears amount to be paid for Pay Off action').optional(),
        interestPaid: z.number().describe('The interest amount to be paid for Pay Off action').optional(),
        nonScheduledFeeAmount: z.number().describe('The non-scheduled fee amount to be paid for Pay Off action').optional(),
        penaltyPaid: z.number().describe('The penalty amount to be paid for Pay Off action').optional(),
    })
    .describe('Adjustable amounts to be paid for Pay Off action')

export type PayOffAdjustableAmounts = z.infer<typeof PayOffAdjustableAmounts>

export const LoanAccountSchedulesPreviewProcessPMTTransactionally = z
    .object({
        differences: z.boolean().describe('Whether there differences on schedule or not.').optional(),
        existingSchedule: Installment.array().describe('The loan account existing schedule installments list.').optional(),
        schedule: Installment.array().describe('The loan account new schedule installments list.').optional(),
    })
    .describe('Payload structure to preview the loan account schedule differences when processing PMT transactionally.')

export type LoanAccountSchedulesPreviewProcessPMTTransactionally = z.infer<
    typeof LoanAccountSchedulesPreviewProcessPMTTransactionally
>

export const LoanAccountSortingCriteria = z
    .object({
        field: z
            .enum([
                'encodedKey',
                'loanName',
                'id',
                'accountHolderId',
                'recipient',
                'creationDate',
                'approvedDate',
                'lastModifiedDate',
                'lastSetToArrearsDate',
                'lastLockedDate',
                'closedDate',
                'daysInArrears',
                'daysLate',
                'loanAmount',
                'tranches.amount',
                'numInstallments',
                'accruedInterest',
                'accruedPenalty',
                'penaltySettings.penaltyRate',
                'arrearsTolerancePeriod',
                'interestSettings.interestSpread',
                'totalPaid',
                'totalBalance',
                'totalDue',
                'firstRepaymentDate',
                'lastPaymentDate',
                'lastPaymentAmount',
                'expectedMaturity',
                'rescheduledAccountKey',
                'refinancedAccountId',
                'originalAccountKey',
                'taxRate',
                'taxPaid',
                'taxDue',
                'settlementAccountKey',
                'interestCommission',
                'numberOfFunds',
                'fundsEnabled',
                'availableAmount',
                'wasRescheduled',
                'wasRefinanced',
                'expectedPrincipalRedraw',
                'balances.principalDue',
                'balances.principalPaid',
                'balances.principalBalance',
                'balances.interestDue',
                'balances.interestPaid',
                'balance.interestBalance',
                'balances.redrawBalance',
                'balances.feesDue',
                'balances.feesBalance',
                'balances.feesPaid',
                'balances.penaltyDue',
                'balances.penaltyPaid',
                'balances.penaltyBalance',
                'fundingSources.amount',
                'fundingSources.sharePercentage',
            ])
            .describe(
                'Contains the field that can be used as sorting selection. Can be native (one from the provided list) or otherwise can specify a custom field definition using the format [customFieldSetId].[customFieldId].',
            ),
        order: z.enum(['ASC', 'DESC']).describe('The sorting order: `ASC` or `DESC`. The default order is `DESC`.').optional(),
    })
    .describe('Represents the sorting criteria used for loan account searches.')

export type LoanAccountSortingCriteria = z.infer<typeof LoanAccountSortingCriteria>

export const LoanAccountFilterCriteria = z
    .object({
        field: z.union([
            z
                .enum([
                    'accountHolderKey',
                    'productTypeKey',
                    'loanRiskLevelKey',
                    'encodedKey',
                    'loanName',
                    'id',
                    'accountHolderId',
                    'recipient',
                    'creationDate',
                    'approvedDate',
                    'lastModifiedDate',
                    'lastSetToArrearsDate',
                    'lastLockedDate',
                    'closedDate',
                    'daysInArrears',
                    'daysLate',
                    'accountSubState',
                    'accountState',
                    'loanAmount',
                    'numInstallments',
                    'balances.principalDue',
                    'balances.principalPaid',
                    'balances.principalBalance',
                    'balances.interestDue',
                    'balances.interestPaid',
                    'balance.interestBalance',
                    'accruedInterest',
                    'balances.feesDue',
                    'balances.feesBalance',
                    'balances.feesPaid',
                    'penaltySettings.loanPenaltyCalculationMethod',
                    'balances.penaltyDue',
                    'balances.penaltyPaid',
                    'balances.penaltyBalance',
                    'accruedPenalty',
                    'penaltySettings.penaltyRate',
                    'arrearsTolerancePeriod',
                    'interestSettings.interestRate',
                    'interestSettings.interestSpread',
                    'totalPaid',
                    'totalBalance',
                    'totalDue',
                    'firstRepaymentDate',
                    'lastPaymentDate',
                    'lastPaymentAmount',
                    'expectedMaturityDate',
                    'rescheduledAccountKey',
                    'refinancedAccountId',
                    'originalAccountKey',
                    'taxRate',
                    'taxPaid',
                    'taxDue',
                    'settlementAccountKey',
                    'interestCommission',
                    'fundingSources.amount',
                    'fundingSources.sharePercentage',
                    'numberOfFunds',
                    'fundsEnabled',
                    'availableAmount',
                    'wasRescheduled',
                    'wasRefinanced',
                    'prepaymentSettings.prepaymentRecalculationMethod',
                    'prepaymentSettings.applyInterestOnPrepaymentMethod',
                    'latePaymentsRecalculationMethod',
                    'balances.redrawBalance',
                    'expectedPrincipalRedraw',
                    'tranches.parentAccountKey',
                    'tranches.disbursementDetails.disbursementTransactionKey',
                    'tranches.amount',
                    'tranches.disbursementDetails.expectedDisbursementDate',
                    'disbursementDetails.expectedDisbursementDate',
                    'disbursementDetails.disbursementDate',
                    'lastAccountAppraisalDate',
                ])
                .describe(
                    'Contains the actual searching fields that can be native (one from the provided list) or otherwise can specify a custom field definition using the format [customFieldSetId].[customFieldId].\\n',
                ),
            z.string(),
        ]),
        operator: z
            .enum([
                'EQUALS',
                'EQUALS_CASE_SENSITIVE',
                'DIFFERENT_THAN',
                'MORE_THAN',
                'LESS_THAN',
                'BETWEEN',
                'ON',
                'AFTER',
                'AFTER_INCLUSIVE',
                'BEFORE',
                'BEFORE_INCLUSIVE',
                'STARTS_WITH',
                'STARTS_WITH_CASE_SENSITIVE',
                'IN',
                'TODAY',
                'THIS_WEEK',
                'THIS_MONTH',
                'THIS_YEAR',
                'LAST_DAYS',
                'EMPTY',
                'NOT_EMPTY',
            ])
            .describe(
                '| **Operator**                | **Affected values**  | **Available for**                                                    |\\n|---------------               |----------------------|----------------------------------------------------------------------|\\n| EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |\\n| EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |\\n| MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |\\n| ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| STARTS_WITH                  | ONE_VALUE            | STRING                                                               |\\n| STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |\\n| IN                           | LIST                 | ENUM,KEY                                                             |\\n| TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |\\n| EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |\\n| NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |',
            ),
        secondValue: z
            .string()
            .describe('The second value to match the searching criteria, when the `BETWEEN` operator is used.')
            .optional(),
        value: z.string().describe('The value to match the searching criteria.').optional(),
        values: z.string().array().describe('List of values when the `IN` operator is used.').optional(),
    })
    .describe('Wrapper that holds a list of filtering criteria and a sorting criteria for Loan account directed query')

export type LoanAccountFilterCriteria = z.infer<typeof LoanAccountFilterCriteria>

export const AdjustTransactionInstallmentDetailsDTO = z
    .object({
        amountToAdd: z
            .number()
            .describe(
                'The amount to be added on the fee/penalty due amounts (depending on transaction type), on the corresponding installment',
            )
            .optional(),
        installmentKey: z.string().describe('The encoded key of the installment').optional(),
    })
    .describe('Contains the details for the spread of the adjusted amount over the installments')

export type AdjustTransactionInstallmentDetailsDTO = z.infer<typeof AdjustTransactionInstallmentDetailsDTO>

export const LoanTransactionSortingCriteria = z
    .object({
        field: z
            .enum([
                'id',
                'externalId',
                'creationDate',
                'valueDate',
                'parentAccountId',
                'productId',
                'amount',
                'originalAmount',
                'originalCurrencyCode',
                'branchId',
                'centreId',
                'tillId',
                'terms.interestSettings.interestRate',
                'transactionDetails.transactionChannelId',
                'fees.name',
                'accountBalances.totalBalance',
                'accountBalances.principalBalance',
                'accountBalances.redrawBalance',
                'accountBalances.expectedPrincipalRedraw',
                'accountBalances.advancePosition',
                'accountBalances.arrearsPosition',
                'affectedAmounts.principalAmount',
                'affectedAmounts.interestAmount',
                'affectedAmounts.interestFromArrearsAmount',
                'affectedAmounts.deferredInterestAmount',
                'affectedAmounts.feesAmount',
                'affectedAmounts.penaltyAmount',
                'affectedAmounts.organizationCommissionAmount',
                'affectedAmounts.fundersInterestAmount',
                'taxes.taxRate',
            ])
            .describe(
                'Contains the field that can be used as sorting selection. Can be native (one from the provided list) or otherwise can specify a custom field using the format [customFieldSetId].[customFieldId].',
            ),
        order: z.enum(['ASC', 'DESC']).describe('The sorting order: `ASC` or `DESC`. The default order is `DESC`.').optional(),
    })
    .describe('The sorting criteria used for when searching loan transactions.')

export type LoanTransactionSortingCriteria = z.infer<typeof LoanTransactionSortingCriteria>

export const LoanTransactionFilterCriteria = z
    .object({
        field: z.union([
            z
                .enum([
                    'encodedKey',
                    'id',
                    'externalId',
                    'creationDate',
                    'valueDate',
                    'parentAccountKey',
                    'parentAccountHolderKey',
                    'productTypeKey',
                    'productID',
                    'type',
                    'amount',
                    'originalAmount',
                    'originalCurrencyCode',
                    'affectedAmounts.principalAmount',
                    'affectedAmounts.interestAmount',
                    'affectedAmounts.fundersInterestAmount',
                    'affectedAmounts.organizationCommissionAmount',
                    'affectedAmounts.deferredInterestAmount',
                    'affectedAmounts.feesAmount',
                    'affectedAmounts.penaltyAmount',
                    'taxes.taxRate',
                    'accountBalances.totalBalance',
                    'accountBalances.advancePosition',
                    'accountBalances.arrearsPosition',
                    'accountBalances.expectedPrincipalRedraw',
                    'accountBalances.redrawBalance',
                    'accountBalances.principalBalance',
                    'userKey',
                    'branchKey',
                    'branchID',
                    'centreKey',
                    'centreID',
                    'tillKey',
                    'tillID',
                    'adjustmentTransactionKey',
                    'originalTransactionKey',
                    'terms.interestSettings.interestRate',
                    'transactionDetails.transactionChannelKey',
                    'transactionDetails.transactionChannelId',
                    'wasAdjusted',
                    'typeIsAdjustment',
                    'fees.predefinedFeeKey',
                    'fees.trigger',
                    'fees.name',
                    'parentAccountID',
                    'adjustmentTransactionID',
                    'originalTransactionID',
                ])
                .describe(
                    'Contains the actual searching fields that can be native (one from the provided list) or otherwise can specify a custom field definition using the format [customFieldSetId].[customFieldId].\\n|Field with limited capabilities          |Data Type |Operators   |\\n|-----------------------------------------|----------|------------|\\n|originalTransactionKey                   |KEY       |EQUALS, IN  |\\n|transactionDetails.transactionChannelId  |STRING    |EQUALS      |\\n|originalTransactionID                    |STRING    |EQUALS      |\\n',
                ),
            z.string(),
        ]),
        operator: z
            .enum([
                'EQUALS',
                'EQUALS_CASE_SENSITIVE',
                'DIFFERENT_THAN',
                'MORE_THAN',
                'LESS_THAN',
                'BETWEEN',
                'ON',
                'AFTER',
                'AFTER_INCLUSIVE',
                'BEFORE',
                'BEFORE_INCLUSIVE',
                'STARTS_WITH',
                'STARTS_WITH_CASE_SENSITIVE',
                'IN',
                'TODAY',
                'THIS_WEEK',
                'THIS_MONTH',
                'THIS_YEAR',
                'LAST_DAYS',
                'EMPTY',
                'NOT_EMPTY',
            ])
            .describe(
                '| **Operator**                | **Affected values**  | **Available for**                                                    |\\n|---------------               |----------------------|----------------------------------------------------------------------|\\n| EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |\\n| EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |\\n| MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |\\n| ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| STARTS_WITH                  | ONE_VALUE            | STRING                                                               |\\n| STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |\\n| IN                           | LIST                 | ENUM,KEY                                                             |\\n| TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |\\n| EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |\\n| NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |',
            ),
        secondValue: z
            .string()
            .describe('The second value to match the searching criteria, when the `BETWEEN` operator is used.')
            .optional(),
        value: z.string().describe('The value to match the searching criteria.').optional(),
        values: z.string().array().describe('List of values when the `IN` operator is used.').optional(),
    })
    .describe('The unit that composes the list used for Loan transaction client directed queries searching')

export type LoanTransactionFilterCriteria = z.infer<typeof LoanTransactionFilterCriteria>

export const AtomicGroup = z
    .object({
        atomicGroupId: z.string().describe('The id of the atomic group, customizable, unique').optional(),
        transactions: DepositsTransaction.array().describe('Transactions list').optional(),
    })
    .describe('Group of transactions to be executed atomically.')

export type AtomicGroup = z.infer<typeof AtomicGroup>

export const LoanTransactionDetailsInput = z
    .object({
        transactionChannelId: z
            .string()
            .describe('The id of the transaction channel associated with the transaction details input.')
            .optional(),
        transactionChannelKey: z
            .string()
            .describe('The encoded key of the transaction channel associated with the transaction details input.')
            .optional(),
    })
    .describe('Contains the details about transaction including fields like transaction channel key and channel ID')

export type LoanTransactionDetailsInput = z.infer<typeof LoanTransactionDetailsInput>

export const GLAccountAmount = z
    .object({
        amount: z.number().describe('The amount which was debited or credited.').optional(),
        glAccount: z
            .string()
            .describe(
                'Represents the general ledger account code of the the general ledger account that was debited or credited.',
            )
            .optional(),
    })
    .describe('Represents the general ledger account and amount used in a journal entry record.')

export type GLAccountAmount = z.infer<typeof GLAccountAmount>

export const ScheduleSettingsForSchedulePreview = z
    .object({
        amortizationPeriod: z
            .number()
            .int()
            .describe('The PMT is calculated as the loan would have [amortizationPeriod] installments.')
            .optional(),
        fixedDaysOfMonth: z
            .number()
            .int()
            .array()
            .describe(
                'Specifies the days of the month when the repayment due dates should be. Only available if the Repayment Methodology is FIXED_DAYS_OF_MONTH.',
            )
            .optional(),
        gracePeriod: z
            .number()
            .int()
            .describe('The grace period. Represents the grace period for loan repayment - in number of installments.')
            .optional(),
        paymentPlan: PeriodicPaymentForSchedulePreview.array()
            .describe('A list of periodic payments for the current loan account.')
            .optional(),
        periodicPayment: z
            .number()
            .describe(
                'The periodic payment amount for the accounts which have balloon payments or Reduce Number of Installments and Optimized Payments',
            )
            .optional(),
        principalRepaymentInterval: z
            .number()
            .int()
            .describe('The principal repayment interval. Indicates the interval of repayments that the principal has to be paid.')
            .optional(),
        repaymentInstallments: z
            .number()
            .int()
            .describe('The repayment installments. Represents how many installments are required to pay back the loan.')
            .optional(),
        repaymentPeriodCount: z
            .number()
            .int()
            .describe(
                'The repayment period count. Represents how often the loan is to be repaid: stored based on the type repayment option.',
            )
            .optional(),
        repaymentPeriodUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS', 'YEARS'])
            .describe('The repayment period unit. Represents the frequency of loan repayment.')
            .optional(),
    })
    .describe('The schedule settings, holds all schedule properties needed for schedule preview request.')

export type ScheduleSettingsForSchedulePreview = z.infer<typeof ScheduleSettingsForSchedulePreview>

export const InterestSettingsForSchedulePreview = z
    .object({
        accountInterestRateSettings: AccountInterestRateSettings.array()
            .describe('The interest settings details for schedule preview.')
            .optional(),
        interestRate: z
            .number()
            .describe(
                'The interest rate. Represents the interest rate for the loan account. The interest on loans is accrued on a daily basis, which allows charging the clients only for the days they actually used the loan amount.',
            )
            .optional(),
        interestSpread: z
            .number()
            .describe('Interest to be added to active organization index interest rate in order to find out actual interest rate')
            .optional(),
    })
    .describe('The interest settings, holds all the properties regarding interests for the loan account.')

export type InterestSettingsForSchedulePreview = z.infer<typeof InterestSettingsForSchedulePreview>

export const DisbursementDetailsForSchedulePreview = z
    .object({
        expectedDisbursementDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the expected disbursement.Stored as Organization Time.')
            .optional(),
        fees: CustomPredefinedFee.array().describe('List of fees that should be applied at the disbursement time.').optional(),
        firstRepaymentDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the expected first repayment. Stored as Organization Time.')
            .optional(),
    })
    .describe(
        'The the disbursement details it holds the information related to the disbursement details as disbursement date, first repayment date, disbursement fees.',
    )

export type DisbursementDetailsForSchedulePreview = z.infer<typeof DisbursementDetailsForSchedulePreview>

export const RefinanceWriteOffAmounts = z
    .object({
        fee: z.number().describe('Fee write-off amount').optional(),
        interest: z.number().describe('Interest write-off amount').optional(),
        interestFromArrears: z.number().optional(),
        penalty: z.number().describe('Penalty write-off amount').optional(),
    })
    .describe('The write-off amounts, allowed on the loan account refinance')

export type RefinanceWriteOffAmounts = z.infer<typeof RefinanceWriteOffAmounts>

export const RefinanceLoanAccount = z
    .object({
        accountArrearsSettings: RestructureAccountArrearsSettings.optional(),
        disbursementDetails: RefinanceDisbursementDetails,
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        guarantors: Guarantor.array().describe('The guarantees associated with the refinanced loan account').optional(),
        id: z.string().describe('Id of the new loan account.').optional(),
        interestSettings: RestructureInterestSettings.optional(),
        loanName: z.string().describe('The name of the new loan account.').optional(),
        notes: z.string().describe('The loan account notes').optional(),
        penaltySettings: RestructurePenaltySettings.optional(),
        principalPaymentSettings: RestructurePrincipalPaymentAccountSettings.optional(),
        productTypeKey: z.string().describe('The key of the loan product that this account is based on'),
        scheduleSettings: RestructureScheduleSettings.optional(),
    })
    .describe('The new loan account settings, allowed on the loan account refinance')

export type RefinanceLoanAccount = z.infer<typeof RefinanceLoanAccount>

export const CarryForwardOptions = z
    .object({
        accruedInterestBalance: z
            .boolean()
            .describe('Choose whether to carry forward accruedInterestBalance from the originating account')
            .optional(),
        accruedInterestFromArrearsBalance: z
            .boolean()
            .describe('Choose whether to carry forward accruedInterestFromArrearsBalance from the originating account')
            .optional(),
        interestBalance: z
            .boolean()
            .describe('Choose whether to carry forward interestBalance from the originating account')
            .optional(),
        interestFromArrearsBalance: z
            .boolean()
            .describe('Choose whether to carry forward interestFromArrearsBalance from the originating account')
            .optional(),
        loanAccountState: z
            .boolean()
            .describe('Choose whether to carry forward loanAccountState from the originating account')
            .optional(),
    })
    .describe(
        'The carry forward options that indicates which fields will be carried forward to new account on the loan account reschedule/refinance',
    )

export type CarryForwardOptions = z.infer<typeof CarryForwardOptions>

export const RescheduleWriteOffAmounts = z
    .object({
        fee: z.number().describe('Fee write-off amount').optional(),
        interest: z.number().describe('Interest write-off amount').optional(),
        interestFromArrears: z.number().describe('Interest from Arrears write-off amount').optional(),
        penalty: z.number().describe('Penalty write-off amount').optional(),
        principal: z.number().describe('Principal write-off amount').optional(),
    })
    .describe('The write-off amounts, allowed on the loan account reschedule')

export type RescheduleWriteOffAmounts = z.infer<typeof RescheduleWriteOffAmounts>

export const RescheduleLoanAccount = z
    .object({
        accountArrearsSettings: RestructureAccountArrearsSettings.optional(),
        disbursementDetails: RescheduleDisbursementDetails,
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        guarantors: Guarantor.array().describe('The guarantees associated with the rescheduled loan account').optional(),
        id: z.string().describe('Id of the new loan account.').optional(),
        interestCommission: z.number().describe('The interest commission').optional(),
        interestSettings: RestructureInterestSettings.optional(),
        loanName: z.string().describe('The name of the new loan account.').optional(),
        notes: z.string().describe('Notes for the rescheduled loan account').optional(),
        penaltySettings: RestructurePenaltySettings.optional(),
        principalPaymentSettings: RestructurePrincipalPaymentAccountSettings.optional(),
        productTypeKey: z.string().describe('The key of the loan product that this account is based on'),
        scheduleSettings: RestructureScheduleSettings.optional(),
    })
    .describe('The new loan account settings, allowed on the loan account reschedule')

export type RescheduleLoanAccount = z.infer<typeof RescheduleLoanAccount>

export const InterestAccrualBreakdown = z
    .object({
        accountId: z.string().describe('The loan or deposit account ID for which interest is accrued.').optional(),
        accountKey: z
            .string()
            .describe('The encoded key of the loan or deposit account for which interest is accrued.')
            .optional(),
        amount: z.number().describe('The interest accrued amount for the account in this entry.').optional(),
        bookingDate: z.string().describe(`The booking date in the organization's timezone.`).optional(),
        branchKey: z.string().describe(`The encoded key of the account's branch.`).optional(),
        branchName: z.string().describe(`The name of the account's branch`).optional(),
        creationDate: z.string().describe('The creation date and time of the entry in UTC.').optional(),
        entryId: z.number().int().describe('The generated ID of the interest accrual per account entry.').optional(),
        entryType: z.string().describe('Debit or Credit.').optional(),
        foreignAmount: ForeignAmount.optional(),
        glAccountId: z.string().describe('The ID of the general ledger account.').optional(),
        glAccountKey: z
            .string()
            .describe('The encoded key of the general ledger account used for logging the interest accrual.')
            .optional(),
        glAccountName: z.string().describe('The name of the general ledger account.').optional(),
        glAccountType: z
            .string()
            .describe('The general ledger account type, which can be: `ASSET`, `LIABILITY`, `EQUITY`, `INCOME`, or `EXPENSE`.')
            .optional(),
        parentEntryId: z
            .number()
            .int()
            .describe(
                'The ID of the general ledger journal entry that logged the interest accrual sum for all accounts of the same product.',
            )
            .optional(),
        productId: z.string().describe(`The ID of the account's product.`).optional(),
        productKey: z.string().describe(`The encoded key of the account's product.`).optional(),
        productType: z.string().describe('The product type.').optional(),
        transactionId: z.string().describe('The journal entry transaction ID.').optional(),
    })
    .describe('Represents an interest accrual breakdown entry.')

export type InterestAccrualBreakdown = z.infer<typeof InterestAccrualBreakdown>

export const CommunicationMessage = z
    .object({
        body: z.string().describe('The contents of the message.').optional(),
        clientKey: z.string().describe('The client the message was sent to.').optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date the communication message was created in UTC.')
            .optional(),
        depositAccountKey: z.string().describe('The deposit account that triggered this message.').optional(),
        destination: z.string().describe('The destination (phone number or email address) this message was sent to.').optional(),
        encodedKey: z
            .string()
            .describe('The encoded key of the communication message, which is generated automatically, and must be unique.')
            .optional(),
        event: z
            .enum([
                'MANUAL',
                'DO_NOTHING',
                'CLIENT_CREATED',
                'CLIENT_APPROVED',
                'GROUP_ACTIVITY',
                'GROUP_CREATED',
                'LOAN_CREATED',
                'INTEREST_RATE_CHANGED',
                'CLIENT_REJECTED',
                'CLIENT_ACTIVITY',
                'LOAN_REPAYMENT',
                'LOAN_REPAYMENT_REVERSAL',
                'FEE_APPLIED',
                'FEE_ADJUSTED',
                'FEE_CHARGED',
                'PENALTY_APPLIED',
                'PENALTY_ADJUSTMENT',
                'FEES_DUE_REDUCED',
                'FEE_REDUCTION_ADJUSTMENT',
                'LOAN_APPROVAL',
                'LOAN_ACCOUNT_CLOSURE',
                'LOAN_ACCOUNT_WRITE_OFF',
                'LOAN_ACCOUNT_REJECTION',
                'LOAN_ACCOUNT_RESCHEDULED',
                'LOAN_ACCOUNT_REFINANCED',
                'REPAYMENT_REMINDER',
                'ACCOUNT_IN_ARREARS',
                'LOAN_DISBURSEMENT',
                'LOAN_DISBURSEMENT_REVERSAL',
                'LOAN_ACCOUNT_ACTIVITY',
                'LOAN_ANTICIPATED_DISBURSEMENT',
                'SAVINGS_CREATED',
                'SAVINGS_DEPOSIT',
                'SAVINGS_DEPOSIT_REVERSAL',
                'REAPPLIED_SAVINGS_DEPOSIT',
                'SAVINGS_APPROVAL',
                'SAVINGS_ACCOUNT_ACTIVATED',
                'SAVINGS_ACCOUNT_CLOSURE',
                'SAVINGS_ACCOUNT_REJECTION',
                'SAVINGS_WITHDRAWAL',
                'SAVINGS_WITHDRAWAL_REVERSAL',
                'REAPPLIED_SAVINGS_WITHDRAWAL',
                'SAVINGS_ACCOUNT_ACTIVITY',
                'DEPOSIT_INTEREST_APPLIED',
                'DEPOSIT_INTEREST_APPLIED_ADJUSTMENT',
                'ACCOUNT_AUTHORISATION_HOLD_CREATED',
                'ACCOUNT_AUTHORISATION_HOLD_REVERSED',
                'ACCOUNT_AUTHORISATION_HOLD_SETTLED',
                'CARDS_AUTHORISATION_HOLD_CREATED',
                'CARDS_AUTHORISATION_HOLD_SETTLED',
                'CARDS_AUTHORISATION_HOLD_AMOUNT_DECREASED',
                'CARDS_AUTHORISATION_HOLD_AMOUNT_INCREASED',
                'CARDS_AUTHORISATION_HOLD_EXPIRED',
                'CARDS_AUTHORISATION_HOLD_REVERSED',
                'PORTAL_ACTIVATED',
                'PORTAL_PASSWORD_RESET',
                'END_OF_DAY_PROCESSING_COMPLETED',
                'DATA_ACCESS_STATE_CHANGED',
                'CREDIT_ARRANGEMENT_CREATED',
                'CREDIT_ARRANGEMENT_CLOSED',
                'CREDIT_ARRANGEMENT_APPROVED',
                'CREDIT_ARRANGEMENT_REJECTED',
                'CREDIT_ARRANGEMENT_WITHDRAWN',
                'CREDIT_ARRANGEMENT_DELETED',
                'CREDIT_ARRANGEMENT_ACCOUNT_ADDED',
                'CREDIT_ARRANGEMENT_ACCOUNT_REMOVED',
                'CREDIT_ARRANGEMENT_EDITED',
                'PAYMENT_ORDER_ACTIVITY',
                'COLLECTION_ORDER_ACTIVITY',
                'JOURNAL_ENTRY_ADDED',
                'JOURNAL_ENTRY_ADJUSTED',
                'SAVINGS_TRANSACTION_EDITED',
                'CARD_WITHDRAWAL_REVERSAL',
                'CARD_DEPOSIT_REVERSAL',
            ])
            .describe('The event that triggered this message.')
            .optional(),
        failureCause: z.string().describe('The failure code if the message failed to send.').optional(),
        failureReason: z
            .enum([
                'MESSAGING_EXCEPTION',
                'INVALID_SMTP_CREDENTIALS',
                'UNSUPPORTED_ENCODING_EXCEPTION',
                'EMAIL_SERVICE_NOT_ENABLED',
                'SMS_TOO_LONG',
                'SMS_SERVICE_NOT_ENABLED',
                'SMS_NOT_SENT',
                'SMS_SERVICE_ERROR',
                'SMS_CONNECTION_EXCEPTION',
                'WEBHOOK_NOTIFICATIONS_DISABLED',
                'INVALID_HTTP_RESPONSE',
                'HTTP_ERROR_WHILE_SENDING',
                'INVALID_JSON_BODY_SYNTAX',
                'MISSING_TEMPLATE_KEY',
                'MAX_MESSAGE_SIZE_LIMIT_EXCEEDED',
                'UNDEFINED_DESTINATION',
                'INVALID_HTTP_PROTOCOL',
                'BLACKLISTED_URL',
                'INVALID_SMS_GATEWAY_CREDENTIALS',
                'MISSING_SMS_RECIPIENT',
                'SMS_GATEWAY_ERROR',
                'MISSING_EMAIL_RECIPIENT_ADDRESS',
                'OTHER',
            ])
            .describe('The reason for the communication message failure.')
            .optional(),
        groupKey: z.string().describe('The group the message was sent to.').optional(),
        loanAccountKey: z.string().describe('The loan account that triggered this message.').optional(),
        numRetries: z.number().int().describe('The number of retries to send the message.').optional(),
        referenceId: z
            .string()
            .describe('The reference ID of the communication message, generated by the SMS dispatcher.')
            .optional(),
        repaymentKey: z.string().describe('The repayment that triggered this message.').optional(),
        sendDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date the communication message was sent in UTC.')
            .optional(),
        senderKey: z
            .string()
            .describe('The encoded key of the sender. If specified, it should be the encoded key of the current user.')
            .optional(),
        state: z
            .enum(['SENT', 'QUEUED', 'QUEUED_FOR_STREAM', 'WAITING', 'SENDING_ASYNC', 'FAILED'])
            .describe('The state of the message.')
            .optional(),
        subject: z.string().describe('The subject of the message.').optional(),
        templateKey: z.string().describe('The communication message template key.').optional(),
        type: z
            .enum(['EMAIL', 'SMS', 'WEB_HOOK', 'EVENT_STREAM', 'TASK'])
            .describe('The type of communication message.')
            .optional(),
        userKey: z.string().describe('The user the message was sent to.').optional(),
    })
    .describe('Represents a communication message.')

export type CommunicationMessage = z.infer<typeof CommunicationMessage>

export const ArchivedDepositTransaction = z
    .object({
        transactionId: z.number().int().describe('The id of the archived deposit transaction, unique'),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of entry created for the deposit transaction to be archived')
            .optional(),
    })
    .describe('Represents the archived custom field values of a deposit transaction.')

export type ArchivedDepositTransaction = z.infer<typeof ArchivedDepositTransaction>

export const FundingSourcePurchase = z
    .object({
        amount: z.number().describe('The amount bought (a portion of the whole fraction being sold)'),
        depositAccountKey: z.string().describe('The buyer funding account (savings account) key').optional(),
        price: z.number().describe('The price paid for the amount'),
    })
    .describe('Funding source purchase, hold information about a funding source purchase (buyer, price, amount)')

export type FundingSourcePurchase = z.infer<typeof FundingSourcePurchase>

export const TransferDetailsInput = z
    .object({
        linkedAccountId: z.string().describe('The id of the linked account').optional(),
        linkedAccountKey: z.string().describe('The encoded key of the linked account').optional(),
        linkedAccountType: z.enum(['LOAN', 'DEPOSIT']).describe('The type of the linked account. Can be LOAN or DEPOSIT'),
    })
    .describe('Represents the input for the transfer details for a transfer transaction')

export type TransferDetailsInput = z.infer<typeof TransferDetailsInput>

export const AccountAuthorizationHold = z
    .object({
        accountKey: z.string().describe('The key of the account linked with the authorization hold.').optional(),
        advice: z.boolean().describe('Whether the given request should be accepted without balance validations.').optional(),
        amount: z.number().describe('The amount of money to be held as a result of the authorization hold request.'),
        cardAcceptor: CardAcceptor.optional(),
        cardToken: z.string().describe('The reference token of the card.').optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The organization time when the authorization hold was created')
            .optional(),
        creditDebitIndicator: z
            .enum(['DBIT', 'CRDT'])
            .describe(
                'Indicates whether the authorization hold amount is credited or debited. If not provided, the default value is DBIT.',
            )
            .optional(),
        currencyCode: z
            .string()
            .describe(
                'The ISO currency code in which the hold was created. The amounts are stored in the base currency, but the user could have enter it in a foreign currency.',
            )
            .optional(),
        exchangeRate: z.number().describe('The exchange rate for the original currency.').optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID to be used to reference the account hold in subsequent requests.'),
        originalAmount: z
            .number()
            .describe('The original amount of money to be held as a result of the authorization hold request.')
            .optional(),
        originalCurrency: z.string().describe('The original currency in which the hold was created.').optional(),
        source: z.enum(['CARD', 'ACCOUNT']).describe('Indicates the source of the authorization hold.').optional(),
        status: z.enum(['PENDING', 'REVERSED', 'SETTLED', 'EXPIRED']).describe('The authorization hold status.').optional(),
        userTransactionTime: z.string().describe('The formatted time at which the user made this authorization hold.').optional(),
    })
    .describe('The account authorization hold corresponding to a deposit account')

export type AccountAuthorizationHold = z.infer<typeof AccountAuthorizationHold>

export const AccountingReport = z
    .object({
        items: AccountingReportItem.array().describe('The list of the accounting report items.').optional(),
        reportKey: z.string().describe('The encoded key of the generated accounting report.').optional(),
        status: z
            .enum([
                'QUEUED',
                'IN_PROGRESS',
                'COMPLETE',
                'NOT_FOUND',
                'CANCEL',
                'TO_BE_CANCELED',
                'TIMED_OUT',
                'ERROR',
                'TRANSIENT_ERROR',
                'OVERRIDDEN',
                'RECOVERABLE_ERROR',
            ])
            .describe('The accounting report generation status.')
            .optional(),
    })
    .describe('Represents information about the accounting report.')

export type AccountingReport = z.infer<typeof AccountingReport>

export const AccountingReportGenerationInput = z
    .object({
        balanceTypes: z
            .enum(['OPENING_BALANCE', 'NET_CHANGE', 'CLOSING_BALANCE'])
            .array()
            .describe('The balance types to include in the generated report.')
            .optional(),
        branchId: z.string().describe('The branch ID  or encoded key to filter general ledger journal entries by.').optional(),
        currencyCode: z.string().describe('The ISO currency code to filter general ledger accounts by.').optional(),
        endDate: z
            .string()
            .date()
            .describe(
                `The inclusive end date in the organization time format and timezone that the general ledger journal entries' entry date is filtered to.`,
            ),
        glTypes: z
            .enum(['ASSET', 'LIABILITY', 'EQUITY', 'INCOME', 'EXPENSE'])
            .array()
            .describe(
                'The account types to filter general ledger accounts by. For header general ledger accounts the report will reflect the sum of the detail general ledger accounts that match the given filters used.',
            )
            .optional(),
        startDate: z
            .string()
            .date()
            .describe(
                `The inclusive start date in the organization time format and timezone that the general ledger journal entries' entry date is filtered from.`,
            ),
    })
    .describe('Represents the input for the accounting report generation.')

export type AccountingReportGenerationInput = z.infer<typeof AccountingReportGenerationInput>

export const AccountingReportGenerationResponse = z
    .object({
        reportKey: z.string().describe('The encoded key of the generated report.').optional(),
        status: z
            .enum([
                'QUEUED',
                'IN_PROGRESS',
                'COMPLETE',
                'NOT_FOUND',
                'CANCEL',
                'TO_BE_CANCELED',
                'TIMED_OUT',
                'ERROR',
                'TRANSIENT_ERROR',
                'OVERRIDDEN',
                'RECOVERABLE_ERROR',
            ])
            .describe('The accounting report generation status.')
            .optional(),
    })
    .describe('Represents the information about the accounting report generation status.')

export type AccountingReportGenerationResponse = z.infer<typeof AccountingReportGenerationResponse>

export const AddCreditArrangementAccountInput = z
    .object({
        accountId: z.string().describe('The encoded key of the account.'),
        accountType: z.enum(['LOAN', 'DEPOSIT']).describe('The type of the account.'),
    })
    .describe('Represents the account to add to the credit arrangement.')

export type AddCreditArrangementAccountInput = z.infer<typeof AddCreditArrangementAccountInput>

export const ApiKeyInput = z
    .object({
        expirationTime: z.number().int().nonnegative().describe('The time to live (TTL) for the API key in seconds.').optional(),
    })
    .describe('Represents an API key expiration time.')

export type ApiKeyInput = z.infer<typeof ApiKeyInput>

export const ApiKeyRotationResult = z
    .object({
        apiKey: z.string().describe('The new API key created after rotating an existing API key.').optional(),
        id: z
            .string()
            .describe(
                'The API key ID. You must base any identification process on the the API key ID as it is guaranteed to be unique.',
            )
            .optional(),
        secretKey: z.string().describe('The new secret key created after rotating an existing API key.').optional(),
    })
    .describe('Represents the result of an API key rotation.')

export type ApiKeyRotationResult = z.infer<typeof ApiKeyRotationResult>

export const ApplicationStatus = z
    .object({
        dataAccessState: z.enum(['READ_ONLY_STATE', 'WRITE_READ_STATE']).describe('Data access state').optional(),
    })
    .describe('Describes the application status regarding the data access')

export type ApplicationStatus = z.infer<typeof ApplicationStatus>

export const ApplyInterestInput = z
    .object({
        interestApplicationDate: z.string().datetime({ offset: true }).describe('The date up to which interest is to be posted'),
        isInterestFromArrears: z
            .boolean()
            .describe(
                'Whether the interest amount to apply should be the regular one or interest from arrears. If nothing specified it will be the regular one.',
            )
            .optional(),
        isPaymentHolidaysInterest: z
            .boolean()
            .describe(
                'Whether the interest amount to apply should be the regular one or the one accrued during the Payment Holidays. If nothing specified it will be the regular one.',
            )
            .optional(),
        notes: z.string().describe('Additional information for this action').optional(),
        paymentHolidaysInterestAmount: z.number().describe('The amount of the Payment Holidays interest to apply').optional(),
    })
    .describe('Represents a request for applying the accrued interest ')

export type ApplyInterestInput = z.infer<typeof ApplyInterestInput>

export const ApplyPlannedFeesResponse = LoanTransaction.array()

export type ApplyPlannedFeesResponse = z.infer<typeof ApplyPlannedFeesResponse>

export const AuthorizationHoldAmountAdjustmentRequest = z
    .object({
        advice: z.boolean().describe('Whether the given request should be accepted without balance validations.').optional(),
        amount: z
            .number()
            .describe(
                'The amount of money to be subtracted/added to the authorization hold amount. For the decrease: if the amount is greater or equal to the authorization hold amount, then the authorization hold is reversed.',
            ),
        currencyCode: z.string().describe('The ISO currency code in which the hold was created.').optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID of the decrease/increase request (not of the authorization hold).')
            .optional(),
    })
    .describe('A request to decrease/increase the amount of an authorization hold.')

export type AuthorizationHoldAmountAdjustmentRequest = z.infer<typeof AuthorizationHoldAmountAdjustmentRequest>

export const BackgroundProcess = z
    .object({
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('When this process was created. Stored as Organization Time')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        endDate: z
            .string()
            .datetime({ offset: true })
            .describe('When this process was ended. Stored as Organization Time')
            .optional(),
        startDate: z
            .string()
            .datetime({ offset: true })
            .describe('When this process was started. Stored as Organization Time')
            .optional(),
        state: z
            .enum([
                'QUEUED',
                'IN_PROGRESS',
                'COMPLETE',
                'NOT_FOUND',
                'CANCEL',
                'TO_BE_CANCELED',
                'TIMED_OUT',
                'ERROR',
                'TRANSIENT_ERROR',
                'OVERRIDDEN',
                'RECOVERABLE_ERROR',
            ])
            .describe('The current status of this process')
            .optional(),
        type: z.enum(['CRON_JOBS', 'MANUAL_CRON_JOBS_TRIGGER']).describe('The type of the background process').optional(),
    })
    .describe('Represents details of the Background Process')

export type BackgroundProcess = z.infer<typeof BackgroundProcess>

export const BulkCardAuthorizationHoldsInput = z
    .object({
        holds: AuthorizationHold.array().describe('The list of authorization holds').optional(),
    })
    .describe('Represents the request payload for creating a bulk card authorization holds.')

export type BulkCardAuthorizationHoldsInput = z.infer<typeof BulkCardAuthorizationHoldsInput>

export const BulkDepositTransactionsInput = z
    .object({
        transactions: DepositTransactionBulkableInputDTO.array().describe('The list of transactions').optional(),
    })
    .describe('Represents the request payload for creating a bulk deposit transactions.')

export type BulkDepositTransactionsInput = z.infer<typeof BulkDepositTransactionsInput>

export const BulkInterestAccountSettingsAvailabilityInput = z
    .object({
        accountFilter: BulkInterestAccountSettingsAvailabilityFilter,
        interestAvailability: InterestAccountSettingsAvailability,
    })
    .describe('Represents the bulk payload for storing interest availabilities to a group of accounts')

export type BulkInterestAccountSettingsAvailabilityInput = z.infer<typeof BulkInterestAccountSettingsAvailabilityInput>

export const BulkProcessStatus = z
    .object({
        errors: BulkProcessingError.array().describe('List of errors').optional(),
        processedItems: BulkProcessingSuccess.array().describe('List of successful processed items').optional(),
        status: z
            .enum([
                'QUEUED',
                'IN_PROGRESS',
                'COMPLETE',
                'NOT_FOUND',
                'CANCEL',
                'TO_BE_CANCELED',
                'TIMED_OUT',
                'ERROR',
                'TRANSIENT_ERROR',
                'OVERRIDDEN',
                'RECOVERABLE_ERROR',
            ])
            .describe('Bulk process status')
            .optional(),
    })
    .describe('Holds information about the status of a bulk process')

export type BulkProcessStatus = z.infer<typeof BulkProcessStatus>

export const CardTransactionInput = z
    .object({
        advice: z.boolean().describe('Whether the given request should be accepted without balance validations.'),
        amount: z.number().describe('The amount of money to be withdrawn in the financial transaction.'),
        cardAcceptor: CardAcceptor.optional(),
        cardToken: z.string().describe('The reference token of the card.').optional(),
        creditDebitIndicator: z
            .enum(['DBIT', 'CRDT'])
            .describe('If present, indicates that the card transaction is a refund, and whether is credited or debited')
            .optional(),
        currencyCode: z
            .string()
            .describe(
                'The ISO currency code in which the card reversal transaction is posted. The amounts are stored in the base currency, but the transaction can be created with a foreign currency.',
            )
            .optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        externalAuthorizationReferenceId: z
            .string()
            .describe(
                'The external authorization hold reference ID, which relates this card transaction to a previous authorization hold.',
            )
            .optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID to be used to reference the card transaction in subsequent requests.'),
        firstRepaymentDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the first repayment for the loan account (as Organization Time)')
            .optional(),
        increaseAmountIfNeeded: z.boolean().describe('Increase available amount if needed').optional(),
        partial: z.boolean().describe('Whether the given request should be a partial clearing or not.').optional(),
        transactionChannelId: z.string().describe('The ID of the channel through which the payment is done.'),
        userTransactionTime: z.string().describe('The formatted time at which the user made this card transaction.').optional(),
    })
    .describe('A card transaction entry which will have a corresponding a financial transaction performed.')

export type CardTransactionInput = z.infer<typeof CardTransactionInput>

export const CardTransactionOutput = z
    .object({
        advice: z.boolean().describe('Whether the given request should be accepted without balance validations.'),
        amount: z.number().describe('The amount of money to be withdrawn in the financial transaction.'),
        balances: AccountBalances.optional(),
        cardAcceptor: CardAcceptor.optional(),
        cardToken: z.string().describe('The reference token of the card.').optional(),
        creditDebitIndicator: z
            .enum(['DBIT', 'CRDT'])
            .describe('If present, indicates that the card transaction is a refund, and whether is credited or debited')
            .optional(),
        currencyCode: z
            .string()
            .describe(
                'The ISO currency code in which the card reversal transaction is posted. The amounts are stored in the base currency, but the transaction can be created with a foreign currency.',
            )
            .optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        externalAuthorizationReferenceId: z
            .string()
            .describe(
                'The external authorization hold reference ID, which relates this card transaction to a previous authorization hold.',
            )
            .optional(),
        externalReferenceId: z
            .string()
            .describe('The external reference ID to be used to reference the card transaction in subsequent requests.'),
        firstRepaymentDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the first repayment for the loan account (as Organization Time)')
            .optional(),
        increaseAmountIfNeeded: z.boolean().describe('Increase available amount if needed').optional(),
        linkedTransaction: LinkedTransaction.optional(),
        partial: z.boolean().describe('Whether the given request should be a partial clearing or not.').optional(),
        transactionChannelId: z.string().describe('The ID of the channel through which the payment is done.'),
        userTransactionTime: z.string().describe('The formatted time at which the user made this card transaction.').optional(),
    })
    .describe('A card transaction output after a financial transaction was performed.')

export type CardTransactionOutput = z.infer<typeof CardTransactionOutput>

export const ChangeArrearsSettingsInput = z
    .object({
        arrearsTolerancePeriod: z.number().int().describe('The new arrears tolerance period to be available on the account'),
        entryDate: z.string().datetime({ offset: true }).describe('The date when to change the arrears settings'),
        notes: z.string().describe('The notes for the change arrears settings action performed on the loan account').optional(),
    })
    .describe('Represents the request payload for performing an arrears settings change action')

export type ChangeArrearsSettingsInput = z.infer<typeof ChangeArrearsSettingsInput>

export const ChangeDueDatesSettingsInput = z
    .object({
        entryDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when to change the due dates settings - deprecated, use valueDate instead')
            .optional(),
        fixedDaysOfMonth: z.number().int().array().describe('The new fixed days of month to be used on the account'),
        notes: z.string().describe('The notes for the change due dates settings action performed on the loan account').optional(),
        valueDate: z.string().datetime({ offset: true }).describe('The date when to change the due dates settings').optional(),
    })
    .describe('Represents the request payload for performing change due dates settings action')

export type ChangeDueDatesSettingsInput = z.infer<typeof ChangeDueDatesSettingsInput>

export const ChangeInterestRateAction = z
    .object({
        interestRate: z.number().describe('The new interest rate to set on the account.'),
        notes: z.string().describe('The notes or description attached to this object.').optional(),
        valueDate: z.string().date().describe('The date when the interest rate is changed.'),
    })
    .describe('Change deposit account interest rate')

export type ChangeInterestRateAction = z.infer<typeof ChangeInterestRateAction>

export const ChangeInterestRateLoanAccountInput = z
    .object({
        interestRate: z.number().describe('The new interest rate to be available on the account').optional(),
        interestSpread: z.number().describe('The new interest spread to be available on the account').optional(),
        notes: z.string().describe('The notes for the change interest rate action performed on the loan account').optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when to change the interest rate (as Organization Time)'),
    })
    .describe('Represents the request payload for performing an PMT Adjustment action')

export type ChangeInterestRateLoanAccountInput = z.infer<typeof ChangeInterestRateLoanAccountInput>

export const ChangePeriodicPaymentLoanAccountInput = z
    .object({
        notes: z.string().describe('The notes for the change periodic payment action performed on the loan account').optional(),
        periodicPayment: z.number().describe('The new periodic payment to be available on the account'),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when to change the periodic payment (as Organization Time)'),
    })
    .describe('Represents the request payload for performing a periodic payment change action')

export type ChangePeriodicPaymentLoanAccountInput = z.infer<typeof ChangePeriodicPaymentLoanAccountInput>

export const ChangeRepaymentValueLoanAccountInput = z
    .object({
        amount: z.number().describe('Fixed amount for being used for the repayments principal due').optional(),
        notes: z.string().describe('Notes for the repayment value change action performed on the loan account').optional(),
        percentage: z.number().describe('Percentage of principal amount used for the repayments principal due').optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('Date when to change the repayment value (as Organization Time)'),
    })
    .describe('Represents the request payload for performing a repayment value change action')

export type ChangeRepaymentValueLoanAccountInput = z.infer<typeof ChangeRepaymentValueLoanAccountInput>

export const ChangeWithholdingTaxAction = z
    .object({
        withholdingTaxSourceKey: z.string().describe('The ID or encoded key of the new withholding tax to use for the account.'),
    })
    .describe('Change deposit account withholding tax rate')

export type ChangeWithholdingTaxAction = z.infer<typeof ChangeWithholdingTaxAction>

export const ClientRole = z
    .object({
        canGuarantee: z
            .boolean()
            .describe('`TRUE` if clients with this client role can be used as guarantors, `FALSE` otherwise.')
            .optional(),
        canOpenAccounts: z
            .boolean()
            .describe('`TRUE` if new accounts for this client type can be created, `FALSE` otherwise.')
            .optional(),
        clientType: z.enum(['CLIENT', 'GROUP']).describe('The type of the client for which this role was created.').optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The creation date of the client role.').optional(),
        description: z.string().describe('The text description for this client role.').optional(),
        encodedKey: z.string().describe('The encoded key of the client, which is unique and generated.').optional(),
        id: z
            .string()
            .describe('The ID of the client role, which can be generated and customized - but must be unique.')
            .optional(),
        idPattern: z.string().describe('The pattern used in generating the client ID.').optional(),
        name: z.string().describe('The name of the client role.').optional(),
        requireID: z
            .boolean()
            .describe(
                '`TRUE` if identification documents must be provided for the client to be created, `FALSE` otherwise. Does not apply for groups.',
            )
            .optional(),
        useDefaultAddress: z
            .boolean()
            .describe('`TRUE` if the Mambu default address section is available, `FALSE` otherwise.')
            .optional(),
    })
    .describe('Represents a client or group role.')

export type ClientRole = z.infer<typeof ClientRole>

export const ClientSearchCriteria = z
    .object({
        filterCriteria: ClientFilterCriteria.array().describe('The list of filtering criteria'),
        sortingCriteria: ClientSortingCriteria.optional(),
    })
    .describe('Wrapper that holds a list of filtering criteria and a sorting criteria for clients')

export type ClientSearchCriteria = z.infer<typeof ClientSearchCriteria>

export const CollateralAssetFilter = z
    .object({
        branchKeys: z
            .string()
            .array()
            .describe('Assets of the loan accounts that will be filtered by the branch keys in the background process')
            .optional(),
        currencies: z
            .string()
            .array()
            .describe('Assets of the loan accounts that will be filtered by the currency codes in the background process')
            .optional(),
        productKeys: z
            .string()
            .array()
            .describe('Assets of the loan accounts that will be filtered by the product keys in the background process')
            .optional(),
    })
    .describe('Represents the input for the collateral assets reevaluation background task.')

export type CollateralAssetFilter = z.infer<typeof CollateralAssetFilter>

export const CollateralAssetsReevaluationResponse = z
    .object({
        bulkProcessKey: z.string().describe('The encoded key of the collateral assets reevaluation task').optional(),
        status: z
            .enum([
                'QUEUED',
                'IN_PROGRESS',
                'COMPLETE',
                'NOT_FOUND',
                'CANCEL',
                'TO_BE_CANCELED',
                'TIMED_OUT',
                'ERROR',
                'TRANSIENT_ERROR',
                'OVERRIDDEN',
                'RECOVERABLE_ERROR',
            ])
            .describe('The collateral assets reevaluation status')
            .optional(),
    })
    .describe('Holds the information about collateral assets reevaluation status.')

export type CollateralAssetsReevaluationResponse = z.infer<typeof CollateralAssetsReevaluationResponse>

export const CommunicationMessageAction = z
    .object({
        messages: z.string().array().describe('The list of failed communication messages to resend.'),
    })
    .describe('Represents a list of failed communication messages to resend.')

export type CommunicationMessageAction = z.infer<typeof CommunicationMessageAction>

export const CommunicationMessageEnqueueAction = z
    .object({
        endDate: z.string().datetime({ offset: true }).describe('The upper limit until which created messages will be enqueued.'),
        startDate: z
            .string()
            .datetime({ offset: true })
            .describe('The lower limit from which created messages will be enqueued.'),
        templateTypes: z
            .enum(['EMAIL', 'SMS', 'WEB_HOOK', 'EVENT_STREAM', 'TASK'])
            .array()
            .describe('The list of template message types to enqueue.')
            .optional(),
    })
    .describe('Represents the time interval to resend messages.')

export type CommunicationMessageEnqueueAction = z.infer<typeof CommunicationMessageEnqueueAction>

export const CommunicationMessagesSearchSortCriteria = z
    .object({
        filterCriteria: CommunicationMessageFilterCriteria.array().describe('The list of filtering criteria.'),
        sortingCriteria: CommunicationMessageSearchSortingCriteria,
    })
    .describe('The unit that composes the body used used for communication messages client directed searching.')

export type CommunicationMessagesSearchSortCriteria = z.infer<typeof CommunicationMessagesSearchSortCriteria>

export const Create10Response = GLJournalEntry.array()

export type Create10Response = z.infer<typeof Create10Response>

export const Create19Request = Holiday.array()

export type Create19Request = z.infer<typeof Create19Request>

export const Create19Response = Holiday.array()

export type Create19Response = z.infer<typeof Create19Response>

export const Create9Request = GLAccountInput.array()

export type Create9Request = z.infer<typeof Create9Request>

export const Create9Response = GLAccount.array()

export type Create9Response = z.infer<typeof Create9Response>

export const CreateDocument1Request = z.object({
    file: z.string().describe('The file to be attached for an entity.'),
    id: z
        .string()
        .describe(
            'The ID or encoded key of the entity that owns the document. The ID or encoded key must belong to the entity indicated by the `entity` parameter. Possible entity types are :`CLIENT`, `GROUP`, `LOAN_PRODUCT`, `SAVINGS_PRODUCT`, `CENTRE`, `BRANCH`, `USER`, `LOAN_ACCOUNT`, `DEPOSIT_ACCOUNT`, `ID_DOCUMENT`, `LINE_OF_CREDIT`, `GL_JOURNAL_ENTRY`. If the entity is `GL_JOURNAL_ENTRY`, the value can also represent the Journal Entry Transaction ID.',
        )
        .optional(),
    name: z.string().describe('The name (title) of the attached file.').optional(),
    notes: z.string().describe('The description of the attached file.').optional(),
    ownerType: z
        .enum([
            'CLIENT',
            'GROUP',
            'LOAN_PRODUCT',
            'SAVINGS_PRODUCT',
            'CENTRE',
            'BRANCH',
            'USER',
            'LOAN_ACCOUNT',
            'DEPOSIT_ACCOUNT',
            'ID_DOCUMENT',
            'LINE_OF_CREDIT',
            'GL_JOURNAL_ENTRY',
        ])
        .describe('The type of the owner of the document.')
        .optional(),
})

export type CreateDocument1Request = z.infer<typeof CreateDocument1Request>

export const CreateDocumentRequest = z.object({
    file: z.string().describe('The file to be attached for a client.'),
    name: z.string().describe('The name (title) of the attached file.').optional(),
    notes: z.string().describe('The description of the attached file.').optional(),
})

export type CreateDocumentRequest = z.infer<typeof CreateDocumentRequest>

export const CreateLoanAccountFundingSourcesRequest = InvestorFund.array()

export type CreateLoanAccountFundingSourcesRequest = z.infer<typeof CreateLoanAccountFundingSourcesRequest>

export const CreateLoanAccountFundingSourcesResponse = InvestorFund.array()

export type CreateLoanAccountFundingSourcesResponse = z.infer<typeof CreateLoanAccountFundingSourcesResponse>

export const CreatePlannedFeesRequest = PlannedInstallmentFee.array()

export type CreatePlannedFeesRequest = z.infer<typeof CreatePlannedFeesRequest>

export const CreatePlannedFeesResponse = PlannedInstallmentFee.array()

export type CreatePlannedFeesResponse = z.infer<typeof CreatePlannedFeesResponse>

export const CreditArrangementAccounts = z
    .object({
        depositAccounts: DepositAccount.array()
            .describe('List of the deposit accounts linked to the credit arrangement.')
            .optional(),
        loanAccounts: LoanAccount.array().describe('List of loan accounts linked to the credit arrangement.').optional(),
    })
    .describe('Represents loan and deposit accounts linked to a credit arrangement.')

export type CreditArrangementAccounts = z.infer<typeof CreditArrangementAccounts>

export const CreditArrangementAction = z
    .object({
        action: z
            .enum(['APPROVE', 'UNDO_APPROVE', 'REJECT', 'UNDO_REJECT', 'WITHDRAW', 'UNDO_WITHDRAW', 'CLOSE', 'UNDO_CLOSE'])
            .describe('The action type to be applied.'),
        notes: z.string().describe('The notes related to the action performed.').optional(),
    })
    .describe('The state change to perform on the credit arrangement.')

export type CreditArrangementAction = z.infer<typeof CreditArrangementAction>

export const CreditArrangementSchedule = z
    .object({
        installments: Installment.array().describe('The list of installments for the credit arrangement.').optional(),
    })
    .describe('Represents the credit arrangement schedule.')

export type CreditArrangementSchedule = z.infer<typeof CreditArrangementSchedule>

export const CreditArrangementSearchCriteria = z
    .object({
        filterCriteria: CreditArrangementFilterCriteria.array().describe('The list of filtering criteria.').optional(),
        sortingCriteria: CreditArrangementSortingCriteria.optional(),
    })
    .describe('Represents the filtering and sorting criteria when searching credit arrangements.')

export type CreditArrangementSearchCriteria = z.infer<typeof CreditArrangementSearchCriteria>

export const DataImportAction = z
    .object({
        type: z.enum(['APPROVE', 'REJECT']).describe('Type of the data import action'),
    })
    .describe('Holds information about the data import action')

export type DataImportAction = z.infer<typeof DataImportAction>

export const DataImportRequest = z.object({
    file: z.string().describe('The file to import'),
})

export type DataImportRequest = z.infer<typeof DataImportRequest>

export const DataImportResponse = z
    .object({
        importKey: z.string().describe('Import key').optional(),
        state: z
            .enum([
                'QUEUED',
                'IN_PROGRESS',
                'COMPLETE',
                'NOT_FOUND',
                'CANCEL',
                'TO_BE_CANCELED',
                'TIMED_OUT',
                'ERROR',
                'TRANSIENT_ERROR',
                'OVERRIDDEN',
                'RECOVERABLE_ERROR',
            ])
            .describe('Background process state')
            .optional(),
    })
    .describe('Holds information about the response of the data import action')

export type DataImportResponse = z.infer<typeof DataImportResponse>

export const DataImportStatus = z
    .object({
        errors: DataImportError.array().describe('List of errors').optional(),
        eventKey: z.string().describe('Event key').optional(),
        state: z
            .enum([
                'QUEUED',
                'IN_PROGRESS',
                'COMPLETE',
                'NOT_FOUND',
                'CANCEL',
                'TO_BE_CANCELED',
                'TIMED_OUT',
                'ERROR',
                'TRANSIENT_ERROR',
                'OVERRIDDEN',
                'RECOVERABLE_ERROR',
            ])
            .describe('Background process state')
            .optional(),
    })
    .describe('Holds information about the data import status')

export type DataImportStatus = z.infer<typeof DataImportStatus>

export const DepositAccountAction = z
    .object({
        action: z
            .enum(['APPROVE', 'UNDO_APPROVE', 'LOCK', 'UNLOCK', 'CLOSE', 'CLOSE_WITHDRAW', 'CLOSE_REJECT', 'CLOSE_WRITE_OFF'])
            .describe('The action type to be applied.'),
        notes: z.string().describe('The notes related to the action performed.').optional(),
    })
    .describe('Represents the action details for a deposit account.')

export type DepositAccountAction = z.infer<typeof DepositAccountAction>

export const DepositAccountBalanceSummarySearchCriteria = z
    .object({
        filterCriteria: DepositAccountBalanceSummaryFilterCriteria.array().describe('The list of filtering criteria.').optional(),
        sortingCriteria: DepositAccountBalanceSummarySortingCriteria.optional(),
    })
    .describe('Represents the filtering criteria list and the sorting criteria for searching deposit account balance summary.')

export type DepositAccountBalanceSummarySearchCriteria = z.infer<typeof DepositAccountBalanceSummarySearchCriteria>

export const DepositAccountSearchCriteria = z
    .object({
        filterCriteria: DepositAccountFilterCriteria.array().describe('The list of filtering criteria.').optional(),
        sortingCriteria: DepositAccountSortingCriteria.optional(),
    })
    .describe('Represents the filtering criteria list and the sorting criteria for searching deposit accounts.')

export type DepositAccountSearchCriteria = z.infer<typeof DepositAccountSearchCriteria>

export const DepositProductAction = z
    .object({
        action: z
            .literal('UPDATE_INTEREST_SETTINGS')
            .describe(
                'The action type to be applied. When UPDATE_INTEREST_SETTINGS action type is used, all the existing deposit accounts will be updated with the latest interest-related fields at the end of day job execution',
            ),
    })
    .describe('Specify the batch update action details for a deposit product.')

export type DepositProductAction = z.infer<typeof DepositProductAction>

export const DepositProductActionResponse = z
    .object({
        state: z.literal('QUEUED').describe('The state of the deposit product action').optional(),
    })
    .describe('Represents the response returned after a batch update action for a deposit product.')

export type DepositProductActionResponse = z.infer<typeof DepositProductActionResponse>

export const DepositTransactionAdjustmentDetails = z
    .object({
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                'Date when the adjustment transaction is logged into accounting. Can be null. Available only for DEPOSIT and WITHDRAWAL',
            )
            .optional(),
        notes: z.string().describe('Notes detailing why the transaction is adjusted').optional(),
    })
    .describe('Contains the details of the transaction adjustment')

export type DepositTransactionAdjustmentDetails = z.infer<typeof DepositTransactionAdjustmentDetails>

export const DepositTransactionSearchCriteria = z
    .object({
        filterCriteria: DepositTransactionFilterCriteria.array().describe('The list of filtering criteria'),
        sortingCriteria: DepositTransactionSortingCriteria.optional(),
    })
    .describe(
        'Wrapper that holds a list of filtering criteria and a sorting criteria for Deposit transaction client directed query',
    )

export type DepositTransactionSearchCriteria = z.infer<typeof DepositTransactionSearchCriteria>

export const DisbursementLoanTransactionInput = z
    .object({
        amount: z.number().describe('The amount to disburse').optional(),
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when disbursement is logged into accounting)')
            .optional(),
        externalId: z.string().describe('The external id of the disbursement transaction. Customizable and unique').optional(),
        fees: FeeInput.array().describe('The list of the fees to apply').optional(),
        firstRepaymentDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the first repayment for the loan account (as Organization Time)')
            .optional(),
        notes: z.string().describe('Extra notes related to disbursement action or transaction').optional(),
        originalCurrencyCode: z.string().describe('The currency for the disbursement transaction').optional(),
        shiftAdjustableInterestPeriods: z
            .boolean()
            .describe('Indicates whether the validFrom dates from Adjustable Interest Rates can be shifted automatically or not')
            .optional(),
        transactionDetails: TransactionDetailsInput.optional(),
        transferDetails: DisbursementTransferDetailsInput.optional(),
        valueDate: z.string().datetime({ offset: true }).describe('The date of the disbursal (as Organization Time)').optional(),
    })
    .passthrough()
    .describe('The input representation of a loan transaction when making a disbursement')

export type DisbursementLoanTransactionInput = z.infer<typeof DisbursementLoanTransactionInput>

export const EditScheduleRequest = Installment.array()

export type EditScheduleRequest = z.infer<typeof EditScheduleRequest>

export const EditTranchesRequest = LoanTranche.array()

export type EditTranchesRequest = z.infer<typeof EditTranchesRequest>

export const EditTranchesResponse = LoanTranche.array()

export type EditTranchesResponse = z.infer<typeof EditTranchesResponse>

export const EditTransactionDetailsRequest = PatchOperation.array()

export type EditTransactionDetailsRequest = z.infer<typeof EditTransactionDetailsRequest>

export const ErrorResponse = z.object({
    errors: RestError.array().optional(),
})

export type ErrorResponse = z.infer<typeof ErrorResponse>

export const ExchangeRateInput = z
    .object({
        buyRate: z.number().describe('The buy exchange rate.'),
        sellRate: z.number().describe('The sell exchange rate.'),
        startDate: z
            .string()
            .datetime({ offset: true })
            .describe('The exchange rate applies starting with this date.')
            .optional(),
    })
    .describe('Model representation of an exchange rate inputs for filtering.')

export type ExchangeRateInput = z.infer<typeof ExchangeRateInput>

export const FeeLoanTransactionInput = z
    .object({
        amount: z.number().describe('The fee amount to be applied on the account').optional(),
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when the fee transaction is logged into accounting (as Organization Time)')
            .optional(),
        externalId: z.string().describe('The external id of the repayment transaction, customizable, unique').optional(),
        feeCapitalisation: z.boolean().describe('This flag indicates whether the fee should be capitalised or not').optional(),
        firstRepaymentDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date of the first repayment for the loan account (as Organization Time)')
            .optional(),
        installmentNumber: z.number().int().describe('The installment number on which the fee will be applied').optional(),
        notes: z.string().describe('Extra notes about the current transaction').optional(),
        predefinedFeeKey: z.string().describe('The encodedKey of the predefined fee that defines the current fee').optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when to apply the fee (as Organization Time)')
            .optional(),
    })
    .describe('Represents the request payload for creating a transaction of type FEE_APPLIED')

export type FeeLoanTransactionInput = z.infer<typeof FeeLoanTransactionInput>

export const FilterCriteriaValueDateBetweenDTO = z
    .object({
        dateFrom: z.string().describe('The start date for searching archived data.').optional(),
        dateTo: z.string().describe('The end date for searching archived data.').optional(),
    })
    .describe('Specifies range of dates to be used in searching')

export type FilterCriteriaValueDateBetweenDTO = z.infer<typeof FilterCriteriaValueDateBetweenDTO>

export const GeneralSetup = z
    .object({
        accountingCutOffTime: z.string().describe('The accounting cut off time.').optional(),
        approvalDisbursalTwoManRuleEnabled: z
            .boolean()
            .describe('`TRUE` if separate users are required for approval and disbursal, `FALSE` otherwise.')
            .optional(),
        arrearsDaysBeforeWriteOff: z
            .number()
            .int()
            .describe('The number of days that are required before an account can be written off.')
            .optional(),
        assignmentConstraints: z
            .enum(['BRANCH', 'CENTRE', 'CREDIT_OFFICER', 'GROUP'])
            .array()
            .describe('The list of required assignments for clients and groups.')
            .optional(),
        automatedAccountingClosuresInterval: z
            .number()
            .int()
            .describe(
                'The interval (number of days) between the execution of automated accounting closures. If this number is 0, automated closure is performed.',
            )
            .optional(),
        clientIdFormat: z.string().describe('The pattern for generating individual client IDs.').optional(),
        dashboardConfigurations: DashboardConfiguration.array().describe('The dashboard configuration.').optional(),
        dateFormats: z
            .record(z.string().optional())
            .describe('The date (dd-MM-yyyy) or date time (dd-MM-yyyy HH:mm:ss) formats.')
            .optional(),
        decimalSeparator: z
            .enum(['COMMA', 'POINT'])
            .describe('The symbol used to mark the border between the integral and the fractional parts of a decimal numeral.')
            .optional(),
        defaultClientRoleKey: z.string().describe('The client role used as default.').optional(),
        defaultClientState: z
            .enum(['PENDING_APPROVAL', 'INACTIVE', 'ACTIVE', 'EXITED', 'BLACKLISTED', 'REJECTED'])
            .describe('The client default state.')
            .optional(),
        defaultGroupRoleKey: z.string().describe('The group role used as default.').optional(),
        defaultLineOfCreditState: z
            .enum(['PENDING_APPROVAL', 'APPROVED', 'ACTIVE', 'CLOSED', 'WITHDRAWN', 'REJECTED'])
            .describe('The line of credit default state.')
            .optional(),
        defaultTransactionChannelKey: z.string().describe('The transaction channel that is used as the default.').optional(),
        duplicateClientChecks: DuplicateFieldConstraint.array()
            .describe('The list of duplicate client constraints that are available in the administration and can be performed.')
            .optional(),
        duplicateClientConstraintAction: z
            .enum(['NONE', 'WARNING', 'ERROR'])
            .describe('The action to be taken when the duplicate client validation fails.')
            .optional(),
        enabledComponents: z
            .enum(['LOANS', 'DEPOSITS', 'BRANCHES', 'CENTRES', 'CLIENTS', 'GROUPS', 'ACCOUNTING', 'CREDIT_OFFICERS'])
            .array()
            .describe('The list of all the enabled components for the current tenant.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the general setup, which is auto generated, and unique.').optional(),
        eodProcessingMethod: z
            .enum(['AUTOMATIC', 'MANUAL'])
            .describe(
                'The end of day (EOD) processing settings. The `AUTOMATIC` EOD processing runs every midnight. The `MANUAL` EOD processing runs when the client initiates the action from the Mambu UI.',
            )
            .optional(),
        exposureAmount: z.number().describe('The maximum exposure amount.').optional(),
        exposureType: z
            .enum(['UNLIMITED', 'SUM_OF_LOANS', 'SUM_OF_LOANS_MINUS_SAVINGS'])
            .describe('The maximum exposure a client can have in outstanding loans at any time.')
            .optional(),
        groupIdFormat: z.string().describe('The pattern for generating group client IDs.').optional(),
        groupSizeLimitType: z.enum(['HARD', 'WARNING', 'NONE']).describe('The group size limitation type.').optional(),
        interBranchTransferGLAccountKey: z
            .string()
            .describe('The key of the general ledger (GL) account which will be used for inter-branch transfers.')
            .optional(),
        lineOfCreditIdFormat: z
            .string()
            .describe('The unique pattern after which all the lines of credit IDs should be created.')
            .optional(),
        maxAllowedIdDocumentAttachments: z.number().int().describe('The maximum allowed ID document attachments.').optional(),
        maxAllowedJournalEntryDocumentAttachments: z
            .number()
            .int()
            .describe('The maximum allowed journal entry attachments.')
            .optional(),
        maxAllowedUndoClosurePeriod: z
            .number()
            .int()
            .describe('The maximum number of days users are allowed to undo of close obligations met for a loan account.')
            .optional(),
        maxGroupSizeLimit: z
            .number()
            .int()
            .describe('The maximum group size allowed. A null value means the limit is ignored.')
            .optional(),
        minGroupSizeLimit: z
            .number()
            .int()
            .describe('The minimum group size allowed. A null value means the limit is ignored.')
            .optional(),
        multipleGroupMemberships: z
            .enum(['UNLIMITED', 'ONE_GROUP'])
            .describe('The constraint on whether clients can belong to more than one group or not.')
            .optional(),
        multipleLoans: z
            .enum(['UNLIMITED', 'ONE_LOAN'])
            .describe('The option that shows if multiple loans are allowed or not.')
            .optional(),
        otherIdDocumentsEnabled: z.boolean().describe('`TRUE` if other ID documents are enabled, `FALSE` otherwise.').optional(),
        overdraftInterestEodBalanceDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date used when computing overdraft interest for savings accounts.')
            .optional(),
        tillIdFormat: z.string().describe('The unique pattern after which all the till IDs should be created.').optional(),
    })
    .describe('Represents the general setup for an organization.')

export type GeneralSetup = z.infer<typeof GeneralSetup>

export const GetAll10Response = DepositTransaction.array()

export type GetAll10Response = z.infer<typeof GetAll10Response>

export const GetAll11Response = ExchangeRate.array()

export type GetAll11Response = z.infer<typeof GetAll11Response>

export const GetAll12Response = GLAccount.array()

export type GetAll12Response = z.infer<typeof GetAll12Response>

export const GetAll13Response = GLJournalEntry.array()

export type GetAll13Response = z.infer<typeof GetAll13Response>

export const GetAll14Response = Group.array()

export type GetAll14Response = z.infer<typeof GetAll14Response>

export const GetAll15Response = IdentificationDocumentTemplate.array()

export type GetAll15Response = z.infer<typeof GetAll15Response>

export const GetAll16Response = Installment.array()

export type GetAll16Response = z.infer<typeof GetAll16Response>

export const GetAll17Response = LoanAccount.array()

export type GetAll17Response = z.infer<typeof GetAll17Response>

export const GetAll18Response = LoanProduct.array()

export type GetAll18Response = z.infer<typeof GetAll18Response>

export const GetAll19Response = LoanTransaction.array()

export type GetAll19Response = z.infer<typeof GetAll19Response>

export const GetAll1Response = ApiConsumer.array()

export type GetAll1Response = z.infer<typeof GetAll1Response>

export const GetAll20Response = Task.array()

export type GetAll20Response = z.infer<typeof GetAll20Response>

export const GetAll21Response = TransactionChannel.array()

export type GetAll21Response = z.infer<typeof GetAll21Response>

export const GetAll22Response = Role.array()

export type GetAll22Response = z.infer<typeof GetAll22Response>

export const GetAll23Response = User.array()

export type GetAll23Response = z.infer<typeof GetAll23Response>

export const GetAll24Response = CurrencyDetails.array()

export type GetAll24Response = z.infer<typeof GetAll24Response>

export const GetAll2Response = Branch.array()

export type GetAll2Response = z.infer<typeof GetAll2Response>

export const GetAll3Response = Centre.array()

export type GetAll3Response = z.infer<typeof GetAll3Response>

export const GetAll4Response = Client.array()

export type GetAll4Response = z.infer<typeof GetAll4Response>

export const GetAll5Response = CreditArrangement.array()

export type GetAll5Response = z.infer<typeof GetAll5Response>

export const GetAll6Response = CustomFieldSetMeta.array()

export type GetAll6Response = z.infer<typeof GetAll6Response>

export const GetAll7Response = DepositAccountBalanceSummary.array()

export type GetAll7Response = z.infer<typeof GetAll7Response>

export const GetAll8Response = DepositAccount.array()

export type GetAll8Response = z.infer<typeof GetAll8Response>

export const GetAll9Response = DepositProduct.array()

export type GetAll9Response = z.infer<typeof GetAll9Response>

export const GetAllAuthorizationHolds1Response = GetAuthorizationHold.array()

export type GetAllAuthorizationHolds1Response = z.infer<typeof GetAllAuthorizationHolds1Response>

export const GetAllAuthorizationHoldsResponse = GetAuthorizationHold.array()

export type GetAllAuthorizationHoldsResponse = z.infer<typeof GetAllAuthorizationHoldsResponse>

export const GetAllBlocksResponse = BlockFund.array()

export type GetAllBlocksResponse = z.infer<typeof GetAllBlocksResponse>

export const GetAllBySetIdResponse = CustomFieldMeta.array()

export type GetAllBySetIdResponse = z.infer<typeof GetAllBySetIdResponse>

export const GetAllCards1Response = Card.array()

export type GetAllCards1Response = z.infer<typeof GetAllCards1Response>

export const GetAllCardsResponse = Card.array()

export type GetAllCardsResponse = z.infer<typeof GetAllCardsResponse>

export const GetAllIndexRateSourcesResponse = IndexRateSource.array()

export type GetAllIndexRateSourcesResponse = z.infer<typeof GetAllIndexRateSourcesResponse>

export const GetAllIndexRatesResponse = IndexRate.array()

export type GetAllIndexRatesResponse = z.infer<typeof GetAllIndexRatesResponse>

export const GetAllPlannedFeesResponse = PlannedInstallmentFee.array()

export type GetAllPlannedFeesResponse = z.infer<typeof GetAllPlannedFeesResponse>

export const GetAllResponse = AccountingRate.array()

export type GetAllResponse = z.infer<typeof GetAllResponse>

export const GetCardTransaction = z
    .object({
        accountBalances: DepositTransactionBalances.optional(),
        adjustmentTransactionKey: z
            .string()
            .describe(
                'The key of the deposit transaction where the adjustment for this transaction was made (if any adjustment was involved)',
            )
            .optional(),
        affectedAmounts: DepositAffectedAmounts.optional(),
        amount: z.number().describe('How much was added/removed in account').optional(),
        blockId: z.string().describe('The block fund id associated with the transaction').optional(),
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when corresponding JE is booked (as Organization Time)')
            .optional(),
        branchKey: z.string().describe('The branch where the transaction was performed').optional(),
        cardTransaction: CardTransaction.optional(),
        cardTransactionReversals: CardTransactionReversal.array()
            .describe('Object containing all the associated reversal transactions.')
            .optional(),
        centreKey: z.string().describe('The center where the transaction was performed').optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when this deposit transaction was created')
            .optional(),
        currencyCode: z.string().describe('The currency in which this transaction was posted').optional(),
        encodedKey: z.string().describe('The encoded key of the deposit transaction, auto generated, unique').optional(),
        externalId: z.string().describe('The external id of the deposit transaction, customizable, unique').optional(),
        fees: DepositFee.array()
            .describe('All the amounts that have been applied or paid within this transaction and involved predefined fees')
            .optional(),
        holdExternalReferenceId: z.string().describe('The external id of an account authorization hold').optional(),
        id: z.string().describe('The id of the deposit transaction, auto generated, unique').optional(),
        interestAccruedAmounts: DepositInterestAccruedAmounts.optional(),
        migrationEventKey: z
            .string()
            .describe(
                `The migration event encoded key associated with this deposit account. If this account was imported, track which 'migration event' they came from`,
            )
            .optional(),
        notes: z.string().describe('Extra notes about this deposit transaction').optional(),
        originalTransactionKey: z
            .string()
            .describe(
                'The encodedKey of the transaction that was adjusted as part of this one. Available only for adjustment transactions',
            )
            .optional(),
        parentAccountKey: z.string().describe('The key of the parent deposit account').optional(),
        paymentDetails: PaymentDetails.optional(),
        paymentOrderId: z.string().describe('The payment order id of the deposit transaction, customizable').optional(),
        taxes: DepositTaxes.optional(),
        terms: DepositTerms.optional(),
        tillKey: z.string().describe('The till key associated with this transaction').optional(),
        transactionDetails: TransactionDetails.optional(),
        transferDetails: TransferDetails.optional(),
        type: z
            .enum([
                'IMPORT',
                'WRITE_OFF',
                'WRITE_OFF_ADJUSTMENT',
                'DEPOSIT',
                'ADJUSTMENT',
                'WITHDRAWAL',
                'WITHDRAWAL_ADJUSTMENT',
                'CARD_TRANSACTION_REVERSAL',
                'CARD_TRANSACTION_REVERSAL_ADJUSTMENT',
                'TRANSFER',
                'TRANSFER_ADJUSTMENT',
                'FEE_APPLIED',
                'FEE_ADJUSTED',
                'FEES_DUE_REDUCED',
                'INTEREST_APPLIED',
                'INTEREST_APPLIED_ADJUSTMENT',
                'NET_DIFF_INTEREST',
                'PROFIT_APPLIED',
                'PROFIT_APPLIED_ADJUSTMENT',
                'FEE_REDUCTION_ADJUSTMENT',
                'WITHHOLDING_TAX',
                'WITHHOLDING_TAX_ADJUSTMENT',
                'INTEREST_RATE_CHANGED',
                'OVERDRAFT_INTEREST_RATE_CHANGED',
                'OVERDRAFT_LIMIT_CHANGED',
                'BRANCH_CHANGED',
                'ACCOUNT_HOLDER_CHANGED',
                'LOAN_FUNDED',
                'LOAN_FUNDED_ADJUSTMENT',
                'LOAN_REPAID',
                'LOAN_REPAID_ADJUSTMENT',
                'LOAN_FRACTION_BOUGHT',
                'LOAN_FRACTION_BOUGHT_ADJUSTMENT',
                'LOAN_FRACTION_SOLD',
                'LOAN_FRACTION_SOLD_ADJUSTMENT',
                'SEIZED_AMOUNT',
            ])
            .describe('The type of the deposit transaction')
            .optional(),
        userKey: z.string().describe('The person that performed the transaction').optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('Date of the entry (eg date of repayment or disbursal, etc.) (as Organization Time)')
            .optional(),
    })
    .describe('Details for retrieving a card financial transaction.')

export type GetCardTransaction = z.infer<typeof GetCardTransaction>

export const GetCommentsResponse = Comment.array()

export type GetCommentsResponse = z.infer<typeof GetCommentsResponse>

export const GetCreditArrangementsByClientIdOrKeyResponse = CreditArrangement.array()

export type GetCreditArrangementsByClientIdOrKeyResponse = z.infer<typeof GetCreditArrangementsByClientIdOrKeyResponse>

export const GetCreditArrangementsByGroupIdOrKeyResponse = CreditArrangement.array()

export type GetCreditArrangementsByGroupIdOrKeyResponse = z.infer<typeof GetCreditArrangementsByGroupIdOrKeyResponse>

export const GetDepositAccountDocumentResponse = z.string()

export type GetDepositAccountDocumentResponse = z.infer<typeof GetDepositAccountDocumentResponse>

export const GetDepositTransactionDocumentResponse = z.string()

export type GetDepositTransactionDocumentResponse = z.infer<typeof GetDepositTransactionDocumentResponse>

export const GetDocumentsByClientIdResponse = Document.array()

export type GetDocumentsByClientIdResponse = z.infer<typeof GetDocumentsByClientIdResponse>

export const GetDocumentsByEntityIdResponse = Document.array()

export type GetDocumentsByEntityIdResponse = z.infer<typeof GetDocumentsByEntityIdResponse>

export const GetFundedLoansResponse = LoanAccount.array()

export type GetFundedLoansResponse = z.infer<typeof GetFundedLoansResponse>

export const GetInterestAvailabilitiesListResponse = InterestAccountSettingsAvailabilityResponse.array()

export type GetInterestAvailabilitiesListResponse = z.infer<typeof GetInterestAvailabilitiesListResponse>

export const GetKeysByConsumerIdResponse = ApiKey.array()

export type GetKeysByConsumerIdResponse = z.infer<typeof GetKeysByConsumerIdResponse>

export const GetLoanAccountDocumentResponse = z.string()

export type GetLoanAccountDocumentResponse = z.infer<typeof GetLoanAccountDocumentResponse>

export const GetLoanAccountRsvResponse = LoanAccountRepaymentScheduleVersioning.array()

export type GetLoanAccountRsvResponse = z.infer<typeof GetLoanAccountRsvResponse>

export const GetTranchesResponse = LoanTranche.array()

export type GetTranchesResponse = z.infer<typeof GetTranchesResponse>

export const GetTransactionsForAllVersionsResponse = LoanTransaction.array()

export type GetTransactionsForAllVersionsResponse = z.infer<typeof GetTransactionsForAllVersionsResponse>

export const GetVersionsByIdResponse = LoanAccount.array()

export type GetVersionsByIdResponse = z.infer<typeof GetVersionsByIdResponse>

export const GetWithholdingTaxHistoryResponse = AccountTax.array()

export type GetWithholdingTaxHistoryResponse = z.infer<typeof GetWithholdingTaxHistoryResponse>

export const GLJournalEntrySearchCriteria = z
    .object({
        filterCriteria: GLJournalEntryFilterCriteria.array().describe('The list of filtering criteria.').optional(),
        sortingCriteria: GLJournalEntrySortingCriteria.optional(),
    })
    .describe('Represents the list of filtering criteria and the sorting criteria when searching general ledger journal entries.')

export type GLJournalEntrySearchCriteria = z.infer<typeof GLJournalEntrySearchCriteria>

export const GroupSearchCriteria = z
    .object({
        filterCriteria: GroupFilterCriteria.array().describe('The list of filtering criteria'),
        sortingCriteria: GroupSortingCriteria.optional(),
    })
    .describe('Wrapper that holds a list of filtering criteria and a sorting criteria for Groups client directed query')

export type GroupSearchCriteria = z.infer<typeof GroupSearchCriteria>

export const Holidays = z
    .object({
        holidays: Holiday.array().describe('The general holidays of the organization.').optional(),
        nonWorkingDays: z
            .enum(['MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', 'SUNDAY'])
            .array()
            .describe('The non-working days of the organization.')
            .optional(),
    })
    .describe('Represents the holidays of the organization.')

export type Holidays = z.infer<typeof Holidays>

export const InterestAccountSettingsAvailabilityUpdate = z
    .object({
        encodedKey: z.string().describe('The encoded key of the Interest Availability, auto generated, unique.').optional(),
        interestRateSettings: DepositAccountInterestAvailabilitySettings,
    })
    .describe('Interest Availability of a Deposit Account')

export type InterestAccountSettingsAvailabilityUpdate = z.infer<typeof InterestAccountSettingsAvailabilityUpdate>

export const InterestAccrualSearchCriteria = z
    .object({
        filterCriteria: InterestAccrualFilterCriteria.array().describe('The list of filtering criteria.').optional(),
        sortingCriteria: InterestAccrualSortingCriteria.optional(),
    })
    .describe('Represents the filtering criteria list and sorting criteria for searching interest accrual entries.')

export type InterestAccrualSearchCriteria = z.infer<typeof InterestAccrualSearchCriteria>

export const LoanAccountAction = z
    .object({
        action: z
            .enum([
                'REQUEST_APPROVAL',
                'SET_INCOMPLETE',
                'APPROVE',
                'UNDO_APPROVE',
                'REJECT',
                'WITHDRAW',
                'CLOSE',
                'UNDO_REJECT',
                'UNDO_WITHDRAW',
                'UNDO_CLOSE',
            ])
            .describe('The action type to be applied.'),
        notes: z.string().describe('The notes related to the action performed.').optional(),
    })
    .describe('Represents information for an action to perform on a loan account.')

export type LoanAccountAction = z.infer<typeof LoanAccountAction>

export const LoanAccountBalances = z
    .object({
        balances: z.record(z.number().optional()).describe('Balances for a loan account').optional(),
    })
    .describe('Balances for a loan account')

export type LoanAccountBalances = z.infer<typeof LoanAccountBalances>

export const LoanAccountPayOffInput = z
    .object({
        externalId: z.string().describe('The external ID for the repayment transaction.').optional(),
        notes: z.string().describe('The notes for the repayment transaction logged for the pay off action.').optional(),
        payOffAdjustableAmounts: PayOffAdjustableAmounts.optional(),
        transactionDetails: TransactionDetails.optional(),
    })
    .describe('Represents the information for loan account pay off action.')

export type LoanAccountPayOffInput = z.infer<typeof LoanAccountPayOffInput>

export const LoanAccountPreviewProcessPMTTransactionally = z
    .object({
        error: z.string().describe('The error code of the request.').optional(),
        info: z.string().describe('Additional information about the request.').optional(),
        result: LoanAccountSchedulesPreviewProcessPMTTransactionally.optional(),
        status: z.string().describe('The status of the request.').optional(),
    })
    .describe('Payload structure to preview the schedules of a loan account when processing PMT transactionally.')

export type LoanAccountPreviewProcessPMTTransactionally = z.infer<typeof LoanAccountPreviewProcessPMTTransactionally>

export const LoanAccountSchedule = z
    .object({
        currency: Currency.optional(),
        installments: Installment.array().describe('The loan account schedule installments list.').optional(),
    })
    .describe('Represents a single loan account schedule structure.')

export type LoanAccountSchedule = z.infer<typeof LoanAccountSchedule>

export const LoanAccountSearchCriteria = z
    .object({
        filterCriteria: LoanAccountFilterCriteria.array().describe('The list of filtering criteria').optional(),
        sortingCriteria: LoanAccountSortingCriteria.optional(),
    })
    .describe('Wrapper that holds a list of filtering criteria and a sorting criteria for Loan account directed query')

export type LoanAccountSearchCriteria = z.infer<typeof LoanAccountSearchCriteria>

export const LoanActionDetails = z
    .object({
        notes: z.string().describe('The notes for the action performed on a loan account.').optional(),
    })
    .describe('Represents details about an action performed on a loan account.')

export type LoanActionDetails = z.infer<typeof LoanActionDetails>

export const LoanTransactionAdjustmentDetails = z
    .object({
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                'Date when the adjustment transaction is logged into accounting. Can be null. Available only for REPAYMENT, PAYMENT_MADE and FEE',
            )
            .optional(),
        installments: AdjustTransactionInstallmentDetailsDTO.array()
            .describe('Details of installments with their corresponding amounts to be added to the reduced fee/penalty')
            .optional(),
        notes: z.string().describe('Notes detailing why the transaction is adjusted'),
    })
    .describe('Contains the details of the transaction adjustment')

export type LoanTransactionAdjustmentDetails = z.infer<typeof LoanTransactionAdjustmentDetails>

export const LoanTransactionSearchCriteria = z
    .object({
        filterCriteria: LoanTransactionFilterCriteria.array().describe('The list of filtering criteria.').optional(),
        sortingCriteria: LoanTransactionSortingCriteria.optional(),
    })
    .describe('Represents the filtering and sorting criteria when searching loan transactions.')

export type LoanTransactionSearchCriteria = z.infer<typeof LoanTransactionSearchCriteria>

export const LockLoanAccountInput = z
    .object({
        lockedAccountTotalDueType: z
            .enum(['BALANCE_AMOUNT', 'DUE_AMOUNT_ON_LATE_INSTALLMENTS'])
            .describe('The locked account total due type.')
            .optional(),
        lockedOperations: z
            .enum(['APPLY_INTEREST', 'APPLY_FEES', 'APPLY_PENALTIES'])
            .array()
            .describe(
                'A list with operations which are locked when the account is in substate AccountState.LOCKED. Allowed options are `APPLY_INTEREST`, `APPLY_PENALTIES`, and `APPLY_FEES`.',
            )
            .optional(),
        notes: z.string().describe('The notes about the account locking operation.').optional(),
    })
    .describe('Represents the information for locking an account.')

export type LockLoanAccountInput = z.infer<typeof LockLoanAccountInput>

export const LockLoanTransactionsWrapper = z
    .object({
        loanTransactions: LoanTransaction.array().describe('The list of loan transactions').optional(),
    })
    .describe('Represents a wrapper over a list of loan transactions, to be used when locking and unlocking an account.')

export type LockLoanTransactionsWrapper = z.infer<typeof LockLoanTransactionsWrapper>

export const MultipleAtomicGroupsInput = z
    .object({
        atomicGroups: AtomicGroup.array().describe('Atomic Groups list').optional(),
    })
    .describe('Represents the request payload for creating multiple transactions atomically in groups.')

export type MultipleAtomicGroupsInput = z.infer<typeof MultipleAtomicGroupsInput>

export const MultipleAtomicGroupsResponse = z
    .object({
        atomicGroups: z.string().array().describe('Ordered unique ids for processing accepted atomic groups').optional(),
        requestId: z.string().describe('Unique id for the accepted async request').optional(),
    })
    .describe('Represents the response for accepting multiple transactions atomically in groups.')

export type MultipleAtomicGroupsResponse = z.infer<typeof MultipleAtomicGroupsResponse>

export const NonWorkingDays = z
    .object({
        nonWorkingDays: z
            .enum(['MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', 'SUNDAY'])
            .array()
            .describe('The non-working days of the organization.'),
    })
    .describe('Represents the non-working days of the organization.')

export type NonWorkingDays = z.infer<typeof NonWorkingDays>

export const OrganizationSetup = z
    .object({
        address: Address.optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The creation date of the organization').optional(),
        currency: z.string().describe('The currency of the organization, must be the same as the existing one').optional(),
        dateFormat: z.string().describe('The format used to represent the date'),
        dateTimeFormat: z.string().describe('The format used to represent the time and date'),
        decimalSeparator: z
            .enum(['COMMA', 'POINT'])
            .describe('Symbol used to mark the border between the integral and the fractional parts of a decimal numeral'),
        emailAddress: z.string().describe('The email address of the organization').optional(),
        institutionName: z.string().describe('The name of the organization'),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('The last modified date of the organization').optional(),
        phoneNumber: z.string().describe('The phone number of the organization').optional(),
        timeZoneID: z.string().describe('The timezone id, must be the same as the existing one').optional(),
    })
    .describe('Response representation of the organization setup details')

export type OrganizationSetup = z.infer<typeof OrganizationSetup>

export const Patch10Request = PatchOperation.array()

export type Patch10Request = z.infer<typeof Patch10Request>

export const Patch11Request = PatchOperation.array()

export type Patch11Request = z.infer<typeof Patch11Request>

export const Patch1Request = PatchOperation.array()

export type Patch1Request = z.infer<typeof Patch1Request>

export const Patch2Request = PatchOperation.array()

export type Patch2Request = z.infer<typeof Patch2Request>

export const Patch3Request = PatchOperation.array()

export type Patch3Request = z.infer<typeof Patch3Request>

export const Patch4Request = PatchOperation.array()

export type Patch4Request = z.infer<typeof Patch4Request>

export const Patch5Request = PatchOperation.array()

export type Patch5Request = z.infer<typeof Patch5Request>

export const Patch6Request = PatchOperation.array()

export type Patch6Request = z.infer<typeof Patch6Request>

export const Patch7Request = PatchOperation.array()

export type Patch7Request = z.infer<typeof Patch7Request>

export const Patch8Request = PatchOperation.array()

export type Patch8Request = z.infer<typeof Patch8Request>

export const Patch9Request = PatchOperation.array()

export type Patch9Request = z.infer<typeof Patch9Request>

export const PatchAuthorizationHoldRequest = PatchOperation.array()

export type PatchAuthorizationHoldRequest = z.infer<typeof PatchAuthorizationHoldRequest>

export const PatchBlockFundRequest = PatchOperation.array()

export type PatchBlockFundRequest = z.infer<typeof PatchBlockFundRequest>

export const PatchFundingSourceRequest = PatchOperation.array()

export type PatchFundingSourceRequest = z.infer<typeof PatchFundingSourceRequest>

export const PatchRequest = PatchOperation.array()

export type PatchRequest = z.infer<typeof PatchRequest>

export const PaymentMadeTransactionInput = z
    .object({
        amount: z.number().describe('The amount of the payment'),
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe('The booking date of the payment made transaction (as Organization Time)')
            .optional(),
        externalId: z.string().describe('The external id of the payment made transaction, customizable, unique').optional(),
        notes: z
            .string()
            .describe('Notes about the payment made transaction. The notes can have at most 255 characters in length.')
            .optional(),
        originalCurrencyCode: z.string().describe('The currency code for the payment made transaction').optional(),
        transactionDetails: LoanTransactionDetailsInput.optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The entry date of the payment made transaction (as Organization Time)')
            .optional(),
    })
    .passthrough()
    .describe('Represents the request payload for creating a transaction of type PAYMENT_MADE')

export type PaymentMadeTransactionInput = z.infer<typeof PaymentMadeTransactionInput>

export const PlannedFeeKeys = z
    .object({
        encodedKeys: z.string().array().describe('The list of encoded keys of the planned installment fees.'),
    })
    .describe('The planned installment fees encoded keys list')

export type PlannedFeeKeys = z.infer<typeof PlannedFeeKeys>

export const PostAccountingRateDTO = z
    .object({
        rate: z
            .number()
            .describe(
                'Value of conversions rate used in accounting to convert amounts from one currency to organisation currency',
            ),
        startDate: z
            .string()
            .datetime({ offset: true })
            .describe('The start date from which the accounting rate will be applied (as Organization time)')
            .optional(),
    })
    .describe('The representation of a payload for creating Accounting Rate')

export type PostAccountingRateDTO = z.infer<typeof PostAccountingRateDTO>

export const PostGLJournalEntriesDTO = z
    .object({
        branchId: z.string().describe('The ID of the assigned branch for the journal entries.').optional(),
        credits: GLAccountAmount.array()
            .describe('The list of general ledger accounts to be credited with corresponding amounts.')
            .optional(),
        date: z
            .string()
            .datetime({ offset: true })
            .describe('The date and time when the general ledger journal entries were recorded, also known as the booking date.'),
        debits: GLAccountAmount.array()
            .describe('The list of general ledger accounts to be debited with corresponding amounts.')
            .optional(),
        notes: z.string().describe('The notes entered when the journal entry was posted.').optional(),
        transactionId: z
            .string()
            .describe('A non-unique trasanction ID. This will be autogenerated if an ID is not provided.')
            .optional(),
    })
    .describe('Represents the information to create general ledger journal entries.')

export type PostGLJournalEntriesDTO = z.infer<typeof PostGLJournalEntriesDTO>

export const PreviewLoanAccountSchedule = z
    .object({
        disbursementDetails: DisbursementDetailsForSchedulePreview.optional(),
        interestCommission: z
            .number()
            .describe(
                'The value of the interest booked by the organization from the accounts funded by investors. Null if the funds are not enable',
            )
            .optional(),
        interestSettings: InterestSettingsForSchedulePreview.optional(),
        loanAmount: z.number().describe('The loan amount'),
        plannedInstallmentFees: PlannedInstallmentFee.array()
            .describe('A list with planned manual fees to be applied on the installments for schedule preview.')
            .optional(),
        productTypeKey: z.string().describe('The key to the type of product that this account is based on.'),
        scheduleSettings: ScheduleSettingsForSchedulePreview.optional(),
        topUpAmount: z.number().describe('The top up amount in case of a refinanced account').optional(),
        tranches: LoanTranche.array().describe('List of tranches to be considered for schedule preview.').optional(),
    })
    .describe('Payload structure to preview loan account schedule.')

export type PreviewLoanAccountSchedule = z.infer<typeof PreviewLoanAccountSchedule>

export const PreviewPayOffDueAmountsInAFutureDateInput = z
    .object({
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date until which the amounts due for pay off should be calculated'),
    })
    .describe('Represents the information to preview the pay off due amounts in a future date.')

export type PreviewPayOffDueAmountsInAFutureDateInput = z.infer<typeof PreviewPayOffDueAmountsInAFutureDateInput>

export const PreviewPayOffDueAmountsInAFutureDateWrapper = z
    .object({
        earlyRepaymentCharge: z
            .number()
            .describe('The early repayment charge balance due when pay off the account in a future date')
            .optional(),
        feeBalance: z.number().describe('The fee balance due when pay off the account in a future date').optional(),
        interestBalance: z.number().describe('The interest balance due when pay off the account in a future date').optional(),
        interestFromArrearsBalance: z
            .number()
            .describe('The interest from arrears balance due when pay off the account in a future date')
            .optional(),
        penaltyBalance: z.number().describe('The penalty balance due when pay off the account in a future date').optional(),
        principalBalance: z.number().describe('The principal balance due when pay off the account in a future date').optional(),
        totalBalance: z.number().describe('The total balance due when pay off the account in a future date').optional(),
    })
    .describe('Represents a wrapper over a set of due amounts representing pay off due amounts in a future date')

export type PreviewPayOffDueAmountsInAFutureDateWrapper = z.infer<typeof PreviewPayOffDueAmountsInAFutureDateWrapper>

export const PreviewTranchesOnScheduleRequest = LoanTranche.array()

export type PreviewTranchesOnScheduleRequest = z.infer<typeof PreviewTranchesOnScheduleRequest>

export const PrincipalOverpaymentLoanTransactionInput = z
    .object({
        amount: z.number().describe('The amount of the repayment'),
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe('The booking date of the repayment (as Organization Time)')
            .optional(),
        externalId: z.string().describe('The external id of the repayment transaction, customizable, unique').optional(),
        notes: z
            .string()
            .describe('Extra notes about the repayment transaction. Notes can have at most 255 characters in length.')
            .optional(),
        originalCurrencyCode: z.string().describe('The currency code for the repayment transaction').optional(),
        transactionDetails: LoanTransactionDetailsInput.optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The entry date of the repayment (as Organization Time)')
            .optional(),
    })
    .describe('Represents the request payload for creating a transaction of type PRINCIPAL_OVERPAYMENT')

export type PrincipalOverpaymentLoanTransactionInput = z.infer<typeof PrincipalOverpaymentLoanTransactionInput>

export const RedrawRepaymentTransactionInputDTO = z
    .object({
        amount: z.number().describe('The amount of the redraw repayment').optional(),
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe('The booking date of the repayment (as Organization Time)')
            .optional(),
        notes: z
            .string()
            .describe('Extra notes about the redraw repayment transaction. Notes can have at most 255 characters in length.')
            .optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The entry date of the repayment (as Organization Time)')
            .optional(),
    })
    .describe('Represents the request payload for creating a transaction of type REDRAW_REPAYMENT')

export type RedrawRepaymentTransactionInputDTO = z.infer<typeof RedrawRepaymentTransactionInputDTO>

export const RefinanceLoanAccountAction = z
    .object({
        carryForwardOptions: CarryForwardOptions.optional(),
        keepSameAccountId: z
            .boolean()
            .describe(
                `Choose whether to keep the same account ID as the originating account. If true, the 'id' field in the 'loanAccount' object should not be provided.`,
            )
            .optional(),
        loanAccount: RefinanceLoanAccount,
        topUpAmount: z.number().describe('The top-up amount'),
        writeOffAmounts: RefinanceWriteOffAmounts.optional(),
    })
    .describe('The request structure for performing the refinance loan account action')

export type RefinanceLoanAccountAction = z.infer<typeof RefinanceLoanAccountAction>

export const RefundLoanTransactionInput = z
    .object({
        amount: z.number().describe('The amount of the refund'),
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe('The booking date of the refund (as Organization Time)')
            .optional(),
        externalId: z.string().describe('The external id of the refund transaction. Customizable and unique').optional(),
        linkedDisbursementKey: z.string().describe('The disbursement key for which the refund is performed'),
        notes: z
            .string()
            .describe('Extra notes about the refund transaction. Notes can have at most 255 characters in length.')
            .optional(),
        transactionDetails: LoanTransactionDetailsInput.optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The entry date of the refund (as Organization Time)')
            .optional(),
    })
    .describe('Represents the request payload for creating a transaction of type REFUND')

export type RefundLoanTransactionInput = z.infer<typeof RefundLoanTransactionInput>

export const RemoveCreditArrangementAccountInput = z
    .object({
        accountId: z.string().describe('The encoded key of the account.'),
        accountType: z.enum(['LOAN', 'DEPOSIT']).describe('The type of the account.'),
    })
    .describe('Represents the account to remove from the credit arrangement.')

export type RemoveCreditArrangementAccountInput = z.infer<typeof RemoveCreditArrangementAccountInput>

export const ReopenDepositAction = z
    .object({
        notes: z.string().describe('The notes or description attached to this object.').optional(),
    })
    .describe('Reopen a deposit account')

export type ReopenDepositAction = z.infer<typeof ReopenDepositAction>

export const RepaymentLoanTransactionInput = z
    .object({
        amount: z.number().describe('The amount of the repayment'),
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe('The booking date of the repayment (as Organization Time)')
            .optional(),
        customPaymentAmounts: CustomPaymentAmount.array().describe('The list of custom amounts of the repayment').optional(),
        externalId: z.string().describe('The external id of the repayment transaction, customizable, unique').optional(),
        installmentEncodedKey: z
            .string()
            .describe('The encoded key of the schedule installment to which this repayment is associated')
            .optional(),
        notes: z
            .string()
            .describe('Extra notes about the repayment transaction. Notes can have at most 255 characters in length.')
            .optional(),
        originalCurrencyCode: z.string().describe('The currency code for the repayment transaction').optional(),
        prepaymentRecalculationMethod: z
            .enum([
                'NO_RECALCULATION',
                'RESCHEDULE_REMAINING_REPAYMENTS',
                'RECALCULATE_SCHEDULE_KEEP_SAME_NUMBER_OF_TERMS',
                'RECALCULATE_SCHEDULE_KEEP_SAME_PRINCIPAL_AMOUNT',
                'RECALCULATE_SCHEDULE_KEEP_SAME_TOTAL_REPAYMENT_AMOUNT',
                'REDUCE_AMOUNT_PER_INSTALLMENT',
                'REDUCE_NUMBER_OF_INSTALLMENTS',
                'REDUCE_NUMBER_OF_INSTALLMENTS_NEW',
            ])
            .describe('The prepayment recalculation method of the repayment')
            .optional(),
        transactionDetails: LoanTransactionDetailsInput.optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The entry date of the repayment (as Organization Time)')
            .optional(),
    })
    .passthrough()
    .describe('Represents the request payload for creating a transaction of type REPAYMENT')

export type RepaymentLoanTransactionInput = z.infer<typeof RepaymentLoanTransactionInput>

export const RescheduleLoanAccountAction = z
    .object({
        carryForwardOptions: CarryForwardOptions.optional(),
        keepSameAccountId: z
            .boolean()
            .describe(
                `Choose whether to keep the same account ID as the originating account. If true, the 'id' field in the 'loanAccount' object should not be provided.`,
            )
            .optional(),
        loanAccount: RescheduleLoanAccount,
        writeOffAmounts: RescheduleWriteOffAmounts.optional(),
    })
    .describe('The request payload for performing a reschedule loan account action')

export type RescheduleLoanAccountAction = z.infer<typeof RescheduleLoanAccountAction>

export const Search10Response = InterestAccrualBreakdown.array()

export type Search10Response = z.infer<typeof Search10Response>

export const Search11Response = LoanAccount.array()

export type Search11Response = z.infer<typeof Search11Response>

export const Search1Response = Client.array()

export type Search1Response = z.infer<typeof Search1Response>

export const Search2Request = CommunicationMessageFilterCriteria.array()

export type Search2Request = z.infer<typeof Search2Request>

export const Search2Response = CommunicationMessage.array()

export type Search2Response = z.infer<typeof Search2Response>

export const Search3Response = CommunicationMessage.array()

export type Search3Response = z.infer<typeof Search3Response>

export const Search4Response = CreditArrangement.array()

export type Search4Response = z.infer<typeof Search4Response>

export const Search5Response = DepositAccountBalanceSummary.array()

export type Search5Response = z.infer<typeof Search5Response>

export const Search6Response = DepositAccount.array()

export type Search6Response = z.infer<typeof Search6Response>

export const Search7Response = DepositTransaction.array()

export type Search7Response = z.infer<typeof Search7Response>

export const Search8Response = GLJournalEntry.array()

export type Search8Response = z.infer<typeof Search8Response>

export const Search9Response = Group.array()

export type Search9Response = z.infer<typeof Search9Response>

export const SearchResponse = ArchivedDepositTransaction.array()

export type SearchResponse = z.infer<typeof SearchResponse>

export const SecretKey = z
    .object({
        secretKey: z.string().describe('The secret key').optional(),
    })
    .describe(`Representation of an API Consumer's Secret Key`)

export type SecretKey = z.infer<typeof SecretKey>

export const SeizeBlockAmount = z
    .object({
        amount: z.number().describe('The amount of the block fund').optional(),
        blockId: z.string().describe('The id of the block fund'),
        externalId: z.string().describe('The external id of the current transaction, customizable, unique').optional(),
        notes: z.string().describe('Extra notes about the current transaction').optional(),
        transactionChannelId: z.string().describe('The id of the channel through which the transaction is done.'),
    })
    .passthrough()
    .describe('Represents the information for seizing a block amount on a deposit account.')

export type SeizeBlockAmount = z.infer<typeof SeizeBlockAmount>

export const SellFundingSourceAction = z
    .object({
        purchases: FundingSourcePurchase.array().describe('Funding source purchase list').optional(),
    })
    .describe('Allows specifying sell function source action details')

export type SellFundingSourceAction = z.infer<typeof SellFundingSourceAction>

export const SellResponse = DepositTransaction.array()

export type SellResponse = z.infer<typeof SellResponse>

export const StartMaturityAction = z
    .object({
        maturityDate: z.string().date().describe('The date when the maturity period starts.').optional(),
        notes: z.string().describe('The notes or description attached to this object.').optional(),
    })
    .describe('The action to start the maturity period for a deposit account')

export type StartMaturityAction = z.infer<typeof StartMaturityAction>

export const TerminateLoanAccountInput = z
    .object({
        notes: z.string().describe('The notes for the terminate action performed on the loan account').optional(),
        valueDate: z.string().datetime({ offset: true }).describe('The date when terminate the loan account'),
    })
    .describe('Represents the request payload for the terminate a loan account action')

export type TerminateLoanAccountInput = z.infer<typeof TerminateLoanAccountInput>

export const TransferDepositTransactionInput = z
    .object({
        amount: z.number().describe('The amount to transfer from account'),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        externalId: z.string().describe('The external id of the transfer transaction, customizable, unique').optional(),
        notes: z.string().describe('Extra notes about this deposit transaction').optional(),
        paymentDetails: PaymentDetails.optional(),
        paymentOrderId: z.string().describe('The payment order id of the transfer transaction, customizable').optional(),
        transferDetails: TransferDetailsInput,
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The entry date of the transfer. If not specified it is considered the current date (as Organization Time)')
            .optional(),
    })
    .passthrough()
    .describe('Represents the input for a transfer deposit transaction.')

export type TransferDepositTransactionInput = z.infer<typeof TransferDepositTransactionInput>

export const TransferOwnershipAction = z
    .object({
        targetHolderKey: z.string().describe('The ID or encoded key of the new account holder.'),
    })
    .describe('Transfer the account ownership from current account holder to a new one (client/group).')

export type TransferOwnershipAction = z.infer<typeof TransferOwnershipAction>

export const TriggerDatabaseBackupRequest = z
    .object({
        callback: z
            .string()
            .describe(
                'If provided, it needs to be a valid URL. It will be a webhook call that will later execute when the backup is complete.',
            )
            .optional(),
        createBackupFromDate: z
            .string()
            .datetime({ offset: true })
            .describe(
                'If provided, it needs to be a date time from which the backup should include data. If not provided, the backup will include all the data.',
            )
            .optional(),
        tables: z
            .string()
            .array()
            .describe(
                'If provided, it needs to be a list of tables that exist in the database schema. The backup will only include the specified tables. If not provided, the backup will include all tables.',
            )
            .optional(),
    })
    .describe('Represents a request for triggering a database backup.')

export type TriggerDatabaseBackupRequest = z.infer<typeof TriggerDatabaseBackupRequest>

export const TriggerDatabaseBackupResponse = z
    .object({
        state: z
            .enum([
                'QUEUED',
                'IN_PROGRESS',
                'COMPLETE',
                'NOT_FOUND',
                'CANCEL',
                'TO_BE_CANCELED',
                'TIMED_OUT',
                'ERROR',
                'TRANSIENT_ERROR',
                'OVERRIDDEN',
                'RECOVERABLE_ERROR',
            ])
            .describe('The state of the database backup process')
            .optional(),
    })
    .describe('Represents a response for triggering a database backup')

export type TriggerDatabaseBackupResponse = z.infer<typeof TriggerDatabaseBackupResponse>

export const TriggerHourlyAndEndOfDayProcessingResponse = z
    .object({
        state: z
            .enum([
                'QUEUED',
                'IN_PROGRESS',
                'COMPLETE',
                'NOT_FOUND',
                'CANCEL',
                'TO_BE_CANCELED',
                'TIMED_OUT',
                'ERROR',
                'TRANSIENT_ERROR',
                'OVERRIDDEN',
                'RECOVERABLE_ERROR',
            ])
            .describe('The state of the hourly end of day processing')
            .optional(),
    })
    .describe('Represents the response for triggering hourly and end of day processing')

export type TriggerHourlyAndEndOfDayProcessingResponse = z.infer<typeof TriggerHourlyAndEndOfDayProcessingResponse>

export const UndoMaturityAction = z
    .object({
        notes: z.string().describe('The notes or description attached to this object.').optional(),
    })
    .describe('The action to undo the maturity period for a deposit account')

export type UndoMaturityAction = z.infer<typeof UndoMaturityAction>

export const UnlockLoanAccountInput = z
    .object({
        notes: z.string().describe('Extra notes about the current unlocking of account').optional(),
    })
    .describe('Represents the request payload for unlocking an account')

export type UnlockLoanAccountInput = z.infer<typeof UnlockLoanAccountInput>

export const UpdateLoanAccountFundingSourcesRequest = InvestorFund.array()

export type UpdateLoanAccountFundingSourcesRequest = z.infer<typeof UpdateLoanAccountFundingSourcesRequest>

export const UpdateLoanAccountFundingSourcesResponse = InvestorFund.array()

export type UpdateLoanAccountFundingSourcesResponse = z.infer<typeof UpdateLoanAccountFundingSourcesResponse>

export const UpdatePlannedFeesRequest = PlannedInstallmentFee.array()

export type UpdatePlannedFeesRequest = z.infer<typeof UpdatePlannedFeesRequest>

export const UpdatePlannedFeesResponse = PlannedInstallmentFee.array()

export type UpdatePlannedFeesResponse = z.infer<typeof UpdatePlannedFeesResponse>

export const UserRequest = z
    .object({
        access: UserAccess,
        assignedBranchKey: z.string().describe('The encoded key of the branch this user is assigned to.').optional(),
        email: z
            .string()
            .describe('The user email address. Used by Mambu for sending automated notifications or for getting passwords.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        firstName: z.string().describe('The first name of the user.'),
        homePhone: z.string().describe(`The user's home phone number, which can also contain characters.`).optional(),
        language: z
            .enum([
                'ENGLISH',
                'PORTUGESE',
                'SPANISH',
                'RUSSIAN',
                'FRENCH',
                'GEORGIAN',
                'CHINESE',
                'INDONESIAN',
                'ROMANIAN',
                'BURMESE',
                'GERMAN',
                'PORTUGUESE_BRAZIL',
                'VIETNAMESE',
                'ITALIAN',
                'THAI',
                'NORWEGIAN',
                'PHRASE',
            ])
            .describe(
                'The Mambu display language for the user. The Mambu UI will be displayed in the selected language. Please note: for portuguese, you must use the incorrect spelling `PORTUGESE`.',
            )
            .optional(),
        lastName: z.string().describe('The last name of the user.').optional(),
        mobilePhone: z.string().describe(`The user's mobile phone number, which can also contain characters.`).optional(),
        notes: z.string().describe('The additional information for the user.').optional(),
        password: z.string().describe('Password used by the user'),
        role: RoleIdentifier.optional(),
        title: z.string().describe('The user title.').optional(),
        transactionLimits: z.record(z.number().optional()).describe('The user transaction limits.').optional(),
        twoFactorAuthentication: z
            .boolean()
            .describe(
                '`TRUE` if the user has two-factor authentication setup, `FALSE` otherwise. If two-factor authentication is enabled, a user will be sent an SMS to their registered mobile number, which they will need to enter in the Mambu login screen, in addition to their password.',
            )
            .optional(),
        username: z.string().describe('The Mambu login user name.'),
    })
    .describe('Allows the creation of a user')

export type UserRequest = z.infer<typeof UserRequest>

export const WithdrawalRedrawTransactionInput = z
    .object({
        amount: z.number().describe('The amount to be withdrawn from redraw balance'),
        bookingDate: z
            .string()
            .datetime({ offset: true })
            .describe('The booking date of the withdrawal transaction (as Organization Time)')
            .optional(),
        externalId: z.string().describe('The external id of the withdrawal transaction, customizable, unique').optional(),
        notes: z
            .string()
            .describe('Extra notes about the withdrawal transaction. Notes can have at most 255 characters in length.')
            .optional(),
        originalCurrencyCode: z.string().describe('The currency code for the transaction').optional(),
        transactionDetails: LoanTransactionDetailsInput.optional(),
        valueDate: z
            .string()
            .datetime({ offset: true })
            .describe('The value date of the withdrawal transaction (as Organization Time)')
            .optional(),
    })
    .passthrough()
    .describe('Represents the request payload for creating a transaction of type WITHDRAWAL_REDRAW')

export type WithdrawalRedrawTransactionInput = z.infer<typeof WithdrawalRedrawTransactionInput>
