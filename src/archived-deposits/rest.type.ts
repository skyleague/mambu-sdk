/**
 * Generated by @skyleague/therefore@v1.0.0-local
 * Do not manually touch this
 */
/* eslint-disable */

import type { DefinedError, ValidateFunction } from 'ajv'

import { validate as AccountAuthorizationHoldValidator } from './schemas/account-authorization-hold.schema.js'
import { validate as AccountBalancesValidator } from './schemas/account-balances.schema.js'
import { validate as AccountingRateValidator } from './schemas/accounting-rate.schema.js'
import { validate as AccountingReportGenerationInputValidator } from './schemas/accounting-report-generation-input.schema.js'
import { validate as AccountingReportGenerationResponseValidator } from './schemas/accounting-report-generation-response.schema.js'
import { validate as AccountingReportValidator } from './schemas/accounting-report.schema.js'
import { validate as AddCreditArrangementAccountInputValidator } from './schemas/add-credit-arrangement-account-input.schema.js'
import { validate as ApiConsumerValidator } from './schemas/api-consumer.schema.js'
import { validate as ApiKeyInputValidator } from './schemas/api-key-input.schema.js'
import { validate as ApiKeyRotationResultValidator } from './schemas/api-key-rotation-result.schema.js'
import { validate as ApiKeyValidator } from './schemas/api-key.schema.js'
import { validate as ApplicationStatusValidator } from './schemas/application-status.schema.js'
import { validate as ApplyInterestInputValidator } from './schemas/apply-interest-input.schema.js'
import { validate as ApplyPlannedFeesResponseValidator } from './schemas/apply-planned-fees-response.schema.js'
import { validate as ArchivedDepositTransactionValidator } from './schemas/archived-deposit-transaction.schema.js'
import { validate as AuthorizationHoldAmountAdjustmentRequestValidator } from './schemas/authorization-hold-amount-adjustment-request.schema.js'
import { validate as AuthorizationHoldValidator } from './schemas/authorization-hold.schema.js'
import { validate as BackgroundProcessValidator } from './schemas/background-process.schema.js'
import { validate as BlockFundValidator } from './schemas/block-fund.schema.js'
import { validate as BranchValidator } from './schemas/branch.schema.js'
import { validate as BulkDepositTransactionsInputValidator } from './schemas/bulk-deposit-transactions-input.schema.js'
import { validate as BulkInterestAccountSettingsAvailabilityInputValidator } from './schemas/bulk-interest-account-settings-availability-input.schema.js'
import { validate as BulkProcessStatusValidator } from './schemas/bulk-process-status.schema.js'
import { validate as CardTransactionInputValidator } from './schemas/card-transaction-input.schema.js'
import { validate as CardTransactionOutputValidator } from './schemas/card-transaction-output.schema.js'
import { validate as CardTransactionReversalValidator } from './schemas/card-transaction-reversal.schema.js'
import { validate as CardValidator } from './schemas/card.schema.js'
import { validate as CentreValidator } from './schemas/centre.schema.js'
import { validate as ChangeArrearsSettingsInputValidator } from './schemas/change-arrears-settings-input.schema.js'
import { validate as ChangeDueDatesSettingsInputValidator } from './schemas/change-due-dates-settings-input.schema.js'
import { validate as ChangeInterestRateActionValidator } from './schemas/change-interest-rate-action.schema.js'
import { validate as ChangeInterestRateLoanAccountInputValidator } from './schemas/change-interest-rate-loan-account-input.schema.js'
import { validate as ChangePeriodicPaymentLoanAccountInputValidator } from './schemas/change-periodic-payment-loan-account-input.schema.js'
import { validate as ChangeRepaymentValueLoanAccountInputValidator } from './schemas/change-repayment-value-loan-account-input.schema.js'
import { validate as ChangeWithholdingTaxActionValidator } from './schemas/change-withholding-tax-action.schema.js'
import { validate as ClientRoleValidator } from './schemas/client-role.schema.js'
import { validate as ClientSearchCriteriaValidator } from './schemas/client-search-criteria.schema.js'
import { validate as ClientValidator } from './schemas/client.schema.js'
import { validate as CollateralAssetFilterValidator } from './schemas/collateral-asset-filter.schema.js'
import { validate as CollateralAssetsReevaluationResponseValidator } from './schemas/collateral-assets-reevaluation-response.schema.js'
import { validate as CommentValidator } from './schemas/comment.schema.js'
import { validate as CommunicationMessageActionValidator } from './schemas/communication-message-action.schema.js'
import { validate as CommunicationMessageEnqueueActionValidator } from './schemas/communication-message-enqueue-action.schema.js'
import { validate as CommunicationMessageValidator } from './schemas/communication-message.schema.js'
import { validate as CommunicationMessagesSearchSortCriteriaValidator } from './schemas/communication-messages-search-sort-criteria.schema.js'
import { validate as CreateDocumentRequestValidator } from './schemas/create-document-request.schema.js'
import { validate as CreateDocument1RequestValidator } from './schemas/create-document1-request.schema.js'
import { validate as CreateLoanAccountFundingSourcesRequestValidator } from './schemas/create-loan-account-funding-sources-request.schema.js'
import { validate as CreateLoanAccountFundingSourcesResponseValidator } from './schemas/create-loan-account-funding-sources-response.schema.js'
import { validate as CreatePlannedFeesRequestValidator } from './schemas/create-planned-fees-request.schema.js'
import { validate as CreatePlannedFeesResponseValidator } from './schemas/create-planned-fees-response.schema.js'
import { validate as Create9RequestValidator } from './schemas/create9-request.schema.js'
import { validate as Create9ResponseValidator } from './schemas/create9-response.schema.js'
import { validate as Create10ResponseValidator } from './schemas/create10-response.schema.js'
import { validate as Create19RequestValidator } from './schemas/create19-request.schema.js'
import { validate as Create19ResponseValidator } from './schemas/create19-response.schema.js'
import { validate as CreditArrangementAccountsValidator } from './schemas/credit-arrangement-accounts.schema.js'
import { validate as CreditArrangementActionValidator } from './schemas/credit-arrangement-action.schema.js'
import { validate as CreditArrangementScheduleValidator } from './schemas/credit-arrangement-schedule.schema.js'
import { validate as CreditArrangementSearchCriteriaValidator } from './schemas/credit-arrangement-search-criteria.schema.js'
import { validate as CreditArrangementValidator } from './schemas/credit-arrangement.schema.js'
import { validate as CurrencyDetailsValidator } from './schemas/currency-details.schema.js'
import { validate as CustomFieldMetaValidator } from './schemas/custom-field-meta.schema.js'
import { validate as DataImportActionValidator } from './schemas/data-import-action.schema.js'
import { validate as DataImportRequestValidator } from './schemas/data-import-request.schema.js'
import { validate as DataImportResponseValidator } from './schemas/data-import-response.schema.js'
import { validate as DataImportStatusValidator } from './schemas/data-import-status.schema.js'
import { validate as DepositAccountActionValidator } from './schemas/deposit-account-action.schema.js'
import { validate as DepositAccountSearchCriteriaValidator } from './schemas/deposit-account-search-criteria.schema.js'
import { validate as DepositAccountValidator } from './schemas/deposit-account.schema.js'
import { validate as DepositProductActionResponseValidator } from './schemas/deposit-product-action-response.schema.js'
import { validate as DepositProductActionValidator } from './schemas/deposit-product-action.schema.js'
import { validate as DepositProductValidator } from './schemas/deposit-product.schema.js'
import { validate as DepositTransactionAdjustmentDetailsValidator } from './schemas/deposit-transaction-adjustment-details.schema.js'
import { validate as DepositTransactionInputValidator } from './schemas/deposit-transaction-input.schema.js'
import { validate as DepositTransactionSearchCriteriaValidator } from './schemas/deposit-transaction-search-criteria.schema.js'
import { validate as DepositTransactionValidator } from './schemas/deposit-transaction.schema.js'
import { validate as DisbursementLoanTransactionInputValidator } from './schemas/disbursement-loan-transaction-input.schema.js'
import { validate as DocumentValidator } from './schemas/document.schema.js'
import { validate as EditScheduleRequestValidator } from './schemas/edit-schedule-request.schema.js'
import { validate as EditTranchesRequestValidator } from './schemas/edit-tranches-request.schema.js'
import { validate as EditTranchesResponseValidator } from './schemas/edit-tranches-response.schema.js'
import { validate as EditTransactionDetailsRequestValidator } from './schemas/edit-transaction-details-request.schema.js'
import { validate as ErrorResponseValidator } from './schemas/error-response.schema.js'
import { validate as ExchangeRateInputValidator } from './schemas/exchange-rate-input.schema.js'
import { validate as ExchangeRateValidator } from './schemas/exchange-rate.schema.js'
import { validate as FeeAppliedDepositTransactionInputValidator } from './schemas/fee-applied-deposit-transaction-input.schema.js'
import { validate as FeeLoanTransactionInputValidator } from './schemas/fee-loan-transaction-input.schema.js'
import { validate as FilterCriteriaValueDateBetweenDTOValidator } from './schemas/filter-criteria-value-date-between-dto.schema.js'
import { validate as GeneralSetupValidator } from './schemas/general-setup.schema.js'
import { validate as GetAllAuthorizationHoldsResponseValidator } from './schemas/get-all-authorization-holds-response.schema.js'
import { validate as GetAllAuthorizationHolds1ResponseValidator } from './schemas/get-all-authorization-holds1-response.schema.js'
import { validate as GetAllBlocksResponseValidator } from './schemas/get-all-blocks-response.schema.js'
import { validate as GetAllBySetIdResponseValidator } from './schemas/get-all-by-set-id-response.schema.js'
import { validate as GetAllCardsResponseValidator } from './schemas/get-all-cards-response.schema.js'
import { validate as GetAllCards1ResponseValidator } from './schemas/get-all-cards1-response.schema.js'
import { validate as GetAllIndexRateSourcesResponseValidator } from './schemas/get-all-index-rate-sources-response.schema.js'
import { validate as GetAllIndexRatesResponseValidator } from './schemas/get-all-index-rates-response.schema.js'
import { validate as GetAllPlannedFeesResponseValidator } from './schemas/get-all-planned-fees-response.schema.js'
import { validate as GetAllResponseValidator } from './schemas/get-all-response.schema.js'
import { validate as GetAll1ResponseValidator } from './schemas/get-all1-response.schema.js'
import { validate as GetAll2ResponseValidator } from './schemas/get-all2-response.schema.js'
import { validate as GetAll3ResponseValidator } from './schemas/get-all3-response.schema.js'
import { validate as GetAll4ResponseValidator } from './schemas/get-all4-response.schema.js'
import { validate as GetAll5ResponseValidator } from './schemas/get-all5-response.schema.js'
import { validate as GetAll6ResponseValidator } from './schemas/get-all6-response.schema.js'
import { validate as GetAll7ResponseValidator } from './schemas/get-all7-response.schema.js'
import { validate as GetAll8ResponseValidator } from './schemas/get-all8-response.schema.js'
import { validate as GetAll9ResponseValidator } from './schemas/get-all9-response.schema.js'
import { validate as GetAll10ResponseValidator } from './schemas/get-all10-response.schema.js'
import { validate as GetAll11ResponseValidator } from './schemas/get-all11-response.schema.js'
import { validate as GetAll12ResponseValidator } from './schemas/get-all12-response.schema.js'
import { validate as GetAll13ResponseValidator } from './schemas/get-all13-response.schema.js'
import { validate as GetAll14ResponseValidator } from './schemas/get-all14-response.schema.js'
import { validate as GetAll15ResponseValidator } from './schemas/get-all15-response.schema.js'
import { validate as GetAll16ResponseValidator } from './schemas/get-all16-response.schema.js'
import { validate as GetAll17ResponseValidator } from './schemas/get-all17-response.schema.js'
import { validate as GetAll18ResponseValidator } from './schemas/get-all18-response.schema.js'
import { validate as GetAll19ResponseValidator } from './schemas/get-all19-response.schema.js'
import { validate as GetAll20ResponseValidator } from './schemas/get-all20-response.schema.js'
import { validate as GetAll21ResponseValidator } from './schemas/get-all21-response.schema.js'
import { validate as GetAll22ResponseValidator } from './schemas/get-all22-response.schema.js'
import { validate as GetAll23ResponseValidator } from './schemas/get-all23-response.schema.js'
import { validate as GetAuthorizationHoldValidator } from './schemas/get-authorization-hold.schema.js'
import { validate as GetCardTransactionValidator } from './schemas/get-card-transaction.schema.js'
import { validate as GetCommentsResponseValidator } from './schemas/get-comments-response.schema.js'
import { validate as GetCreditArrangementsByClientIdOrKeyResponseValidator } from './schemas/get-credit-arrangements-by-client-id-or-key-response.schema.js'
import { validate as GetCreditArrangementsByGroupIdOrKeyResponseValidator } from './schemas/get-credit-arrangements-by-group-id-or-key-response.schema.js'
import { validate as GetDepositAccountDocumentResponseValidator } from './schemas/get-deposit-account-document-response.schema.js'
import { validate as GetDepositTransactionDocumentResponseValidator } from './schemas/get-deposit-transaction-document-response.schema.js'
import { validate as GetDocumentsByClientIdResponseValidator } from './schemas/get-documents-by-client-id-response.schema.js'
import { validate as GetDocumentsByEntityIdResponseValidator } from './schemas/get-documents-by-entity-id-response.schema.js'
import { validate as GetFundedLoansResponseValidator } from './schemas/get-funded-loans-response.schema.js'
import { validate as GetInterestAvailabilitiesListResponseValidator } from './schemas/get-interest-availabilities-list-response.schema.js'
import { validate as GetKeysByConsumerIdResponseValidator } from './schemas/get-keys-by-consumer-id-response.schema.js'
import { validate as GetLoanAccountDocumentResponseValidator } from './schemas/get-loan-account-document-response.schema.js'
import { validate as GetLoanAccountRsvResponseValidator } from './schemas/get-loan-account-rsv-response.schema.js'
import { validate as GetTranchesResponseValidator } from './schemas/get-tranches-response.schema.js'
import { validate as GetTransactionsForAllVersionsResponseValidator } from './schemas/get-transactions-for-all-versions-response.schema.js'
import { validate as GetVersionsByIdResponseValidator } from './schemas/get-versions-by-id-response.schema.js'
import { validate as GetWithholdingTaxHistoryResponseValidator } from './schemas/get-withholding-tax-history-response.schema.js'
import { validate as GLAccountValidator } from './schemas/gl-account.schema.js'
import { validate as GLJournalEntrySearchCriteriaValidator } from './schemas/gl-journal-entry-search-criteria.schema.js'
import { validate as GroupSearchCriteriaValidator } from './schemas/group-search-criteria.schema.js'
import { validate as GroupValidator } from './schemas/group.schema.js'
import { validate as HolidayValidator } from './schemas/holiday.schema.js'
import { validate as HolidaysValidator } from './schemas/holidays.schema.js'
import { validate as IndexRateSourceValidator } from './schemas/index-rate-source.schema.js'
import { validate as IndexRateValidator } from './schemas/index-rate.schema.js'
import { validate as InterestAccountSettingsAvailabilityResponseValidator } from './schemas/interest-account-settings-availability-response.schema.js'
import { validate as InterestAccountSettingsAvailabilityUpdateValidator } from './schemas/interest-account-settings-availability-update.schema.js'
import { validate as InterestAccountSettingsAvailabilityValidator } from './schemas/interest-account-settings-availability.schema.js'
import { validate as InterestAccrualSearchCriteriaValidator } from './schemas/interest-accrual-search-criteria.schema.js'
import { validate as LoanAccountActionValidator } from './schemas/loan-account-action.schema.js'
import { validate as LoanAccountPayOffInputValidator } from './schemas/loan-account-pay-off-input.schema.js'
import { validate as LoanAccountPreviewProcessPMTTransactionallyValidator } from './schemas/loan-account-preview-process-pmt-transactionally.schema.js'
import { validate as LoanAccountScheduleValidator } from './schemas/loan-account-schedule.schema.js'
import { validate as LoanAccountSearchCriteriaValidator } from './schemas/loan-account-search-criteria.schema.js'
import { validate as LoanAccountValidator } from './schemas/loan-account.schema.js'
import { validate as LoanActionDetailsValidator } from './schemas/loan-action-details.schema.js'
import { validate as LoanProductValidator } from './schemas/loan-product.schema.js'
import { validate as LoanTransactionAdjustmentDetailsValidator } from './schemas/loan-transaction-adjustment-details.schema.js'
import { validate as LoanTransactionSearchCriteriaValidator } from './schemas/loan-transaction-search-criteria.schema.js'
import { validate as LoanTransactionValidator } from './schemas/loan-transaction.schema.js'
import { validate as LockLoanAccountInputValidator } from './schemas/lock-loan-account-input.schema.js'
import { validate as LockLoanTransactionsWrapperValidator } from './schemas/lock-loan-transactions-wrapper.schema.js'
import { validate as MultipleAtomicGroupsInputValidator } from './schemas/multiple-atomic-groups-input.schema.js'
import { validate as MultipleAtomicGroupsResponseValidator } from './schemas/multiple-atomic-groups-response.schema.js'
import { validate as NonWorkingDaysValidator } from './schemas/non-working-days.schema.js'
import { validate as OrganizationSetupValidator } from './schemas/organization-setup.schema.js'
import { validate as PatchAuthorizationHoldRequestValidator } from './schemas/patch-authorization-hold-request.schema.js'
import { validate as PatchBlockFundRequestValidator } from './schemas/patch-block-fund-request.schema.js'
import { validate as PatchFundingSourceRequestValidator } from './schemas/patch-funding-source-request.schema.js'
import { validate as PatchRequestValidator } from './schemas/patch-request.schema.js'
import { validate as Patch1RequestValidator } from './schemas/patch1-request.schema.js'
import { validate as Patch2RequestValidator } from './schemas/patch2-request.schema.js'
import { validate as Patch3RequestValidator } from './schemas/patch3-request.schema.js'
import { validate as Patch4RequestValidator } from './schemas/patch4-request.schema.js'
import { validate as Patch5RequestValidator } from './schemas/patch5-request.schema.js'
import { validate as Patch6RequestValidator } from './schemas/patch6-request.schema.js'
import { validate as Patch7RequestValidator } from './schemas/patch7-request.schema.js'
import { validate as Patch8RequestValidator } from './schemas/patch8-request.schema.js'
import { validate as Patch9RequestValidator } from './schemas/patch9-request.schema.js'
import { validate as Patch10RequestValidator } from './schemas/patch10-request.schema.js'
import { validate as Patch11RequestValidator } from './schemas/patch11-request.schema.js'
import { validate as PaymentMadeTransactionInputValidator } from './schemas/payment-made-transaction-input.schema.js'
import { validate as PlannedFeeKeysValidator } from './schemas/planned-fee-keys.schema.js'
import { validate as PostAccountingRateDTOValidator } from './schemas/post-accounting-rate-dto.schema.js'
import { validate as PostGLJournalEntriesDTOValidator } from './schemas/post-gl-journal-entries-dto.schema.js'
import { validate as PreviewLoanAccountScheduleValidator } from './schemas/preview-loan-account-schedule.schema.js'
import { validate as PreviewPayOffDueAmountsInAFutureDateInputValidator } from './schemas/preview-pay-off-due-amounts-in-a-future-date-input.schema.js'
import { validate as PreviewPayOffDueAmountsInAFutureDateWrapperValidator } from './schemas/preview-pay-off-due-amounts-in-a-future-date-wrapper.schema.js'
import { validate as PreviewTranchesOnScheduleRequestValidator } from './schemas/preview-tranches-on-schedule-request.schema.js'
import { validate as RedrawRepaymentTransactionInputDTOValidator } from './schemas/redraw-repayment-transaction-input-dto.schema.js'
import { validate as RefinanceLoanAccountActionValidator } from './schemas/refinance-loan-account-action.schema.js'
import { validate as RefundLoanTransactionInputValidator } from './schemas/refund-loan-transaction-input.schema.js'
import { validate as RemoveCreditArrangementAccountInputValidator } from './schemas/remove-credit-arrangement-account-input.schema.js'
import { validate as ReopenDepositActionValidator } from './schemas/reopen-deposit-action.schema.js'
import { validate as RepaymentLoanTransactionInputValidator } from './schemas/repayment-loan-transaction-input.schema.js'
import { validate as RescheduleLoanAccountActionValidator } from './schemas/reschedule-loan-account-action.schema.js'
import { validate as RoleValidator } from './schemas/role.schema.js'
import { validate as SearchResponseValidator } from './schemas/search-response.schema.js'
import { validate as Search1ResponseValidator } from './schemas/search1-response.schema.js'
import { validate as Search2RequestValidator } from './schemas/search2-request.schema.js'
import { validate as Search2ResponseValidator } from './schemas/search2-response.schema.js'
import { validate as Search3ResponseValidator } from './schemas/search3-response.schema.js'
import { validate as Search4ResponseValidator } from './schemas/search4-response.schema.js'
import { validate as Search5ResponseValidator } from './schemas/search5-response.schema.js'
import { validate as Search6ResponseValidator } from './schemas/search6-response.schema.js'
import { validate as Search7ResponseValidator } from './schemas/search7-response.schema.js'
import { validate as Search8ResponseValidator } from './schemas/search8-response.schema.js'
import { validate as Search9ResponseValidator } from './schemas/search9-response.schema.js'
import { validate as Search10ResponseValidator } from './schemas/search10-response.schema.js'
import { validate as Search11ResponseValidator } from './schemas/search11-response.schema.js'
import { validate as SecretKeyValidator } from './schemas/secret-key.schema.js'
import { validate as SeizeBlockAmountValidator } from './schemas/seize-block-amount.schema.js'
import { validate as SellFundingSourceActionValidator } from './schemas/sell-funding-source-action.schema.js'
import { validate as SellResponseValidator } from './schemas/sell-response.schema.js'
import { validate as StartMaturityActionValidator } from './schemas/start-maturity-action.schema.js'
import { validate as TaskValidator } from './schemas/task.schema.js'
import { validate as TerminateLoanAccountInputValidator } from './schemas/terminate-loan-account-input.schema.js'
import { validate as TransactionChannelValidator } from './schemas/transaction-channel.schema.js'
import { validate as TransferDepositTransactionInputValidator } from './schemas/transfer-deposit-transaction-input.schema.js'
import { validate as TransferOwnershipActionValidator } from './schemas/transfer-ownership-action.schema.js'
import { validate as TriggerDatabaseBackupRequestValidator } from './schemas/trigger-database-backup-request.schema.js'
import { validate as TriggerDatabaseBackupResponseValidator } from './schemas/trigger-database-backup-response.schema.js'
import { validate as TriggerHourlyAndEndOfDayProcessingResponseValidator } from './schemas/trigger-hourly-and-end-of-day-processing-response.schema.js'
import { validate as UndoMaturityActionValidator } from './schemas/undo-maturity-action.schema.js'
import { validate as UnlockLoanAccountInputValidator } from './schemas/unlock-loan-account-input.schema.js'
import { validate as UpdateLoanAccountFundingSourcesRequestValidator } from './schemas/update-loan-account-funding-sources-request.schema.js'
import { validate as UpdateLoanAccountFundingSourcesResponseValidator } from './schemas/update-loan-account-funding-sources-response.schema.js'
import { validate as UpdatePlannedFeesRequestValidator } from './schemas/update-planned-fees-request.schema.js'
import { validate as UpdatePlannedFeesResponseValidator } from './schemas/update-planned-fees-response.schema.js'
import { validate as UserValidator } from './schemas/user.schema.js'
import { validate as UserRequestValidator } from './schemas/user_request.schema.js'
import { validate as WithdrawalDepositTransactionInputValidator } from './schemas/withdrawal-deposit-transaction-input.schema.js'
import { validate as WithdrawalRedrawTransactionInputValidator } from './schemas/withdrawal-redraw-transaction-input.schema.js'

/**
 * The account arrears settings, holds the required information for the arrears settings of an account.
 */
export interface AccountArrearsSettings {
    /**
     * The arrears date calculation method.
     */
    dateCalculationMethod?:
        | 'ACCOUNT_FIRST_WENT_TO_ARREARS'
        | 'LAST_LATE_REPAYMENT'
        | 'ACCOUNT_FIRST_BREACHED_MATERIALITY_THRESHOLD'
        | undefined
    /**
     * The encoded key of the arrears base settings, auto generated, unique.
     */
    encodedKey?: string | undefined
    /**
     * Defines monthly arrears tolerance day value.
     */
    monthlyToleranceDay?: number | undefined
    /**
     * Shows whether the non working days are taken in consideration or not when applying penaltees/late fees or when setting an account into arrears
     */
    nonWorkingDaysMethod?: 'INCLUDED' | 'EXCLUDED' | undefined
    /**
     * Defines the tolerance calculation method
     */
    toleranceCalculationMethod?: 'ARREARS_TOLERANCE_PERIOD' | 'MONTHLY_ARREARS_TOLERANCE_DAY' | undefined
    /**
     * The tolerance floor amount.
     */
    toleranceFloorAmount?: number | undefined
    /**
     * Defines the arrears tolerance amount.
     */
    tolerancePercentageOfOutstandingPrincipal?: number | undefined
    /**
     * Defines the arrears tolerance period value.
     */
    tolerancePeriod?: number | undefined
}

/**
 * The account authorization hold corresponding to a deposit account
 */
export interface AccountAuthorizationHold {
    /**
     * The key of the account linked with the authorization hold.
     */
    accountKey?: string | undefined
    /**
     * Whether the given request should be accepted without balance validations.
     */
    advice?: boolean | undefined
    /**
     * The amount of money to be held as a result of the authorization hold request.
     */
    amount: number
    cardAcceptor?: CardAcceptor | undefined
    /**
     * The reference token of the card.
     */
    cardToken?: string | undefined
    /**
     * The organization time when the authorization hold was created
     */
    creationDate?: string | undefined
    /**
     * Indicates whether the authorization hold amount is credited or debited. If not provided, the default value is DBIT.
     */
    creditDebitIndicator?: 'DBIT' | 'CRDT' | undefined
    /**
     * The ISO currency code in which the hold was created. The amounts are stored in the base currency, but the user could have enter it in a foreign currency.
     */
    currencyCode?: string | undefined
    /**
     * The exchange rate for the original currency.
     */
    exchangeRate?: number | undefined
    /**
     * The external reference ID to be used to reference the account hold in subsequent requests.
     */
    externalReferenceId: string
    /**
     * The original amount of money to be held as a result of the authorization hold request.
     */
    originalAmount?: number | undefined
    /**
     * The original currency in which the hold was created.
     */
    originalCurrency?: string | undefined
    /**
     * Indicates the source of the authorization hold.
     */
    source?: 'CARD' | 'ACCOUNT' | undefined
    /**
     * The authorization hold status.
     */
    status?: 'PENDING' | 'REVERSED' | 'SETTLED' | 'EXPIRED' | undefined
    /**
     * The formatted time at which the user made this authorization hold.
     */
    userTransactionTime?: string | undefined
}

export const AccountAuthorizationHold = {
    validate: AccountAuthorizationHoldValidator as ValidateFunction<AccountAuthorizationHold>,
    get schema() {
        return AccountAuthorizationHold.validate.schema
    },
    get errors() {
        return AccountAuthorizationHold.validate.errors ?? undefined
    },
    is: (o: unknown): o is AccountAuthorizationHold => AccountAuthorizationHold.validate(o) === true,
    parse: (o: unknown): { right: AccountAuthorizationHold } | { left: DefinedError[] } => {
        if (AccountAuthorizationHold.is(o)) {
            return { right: o }
        }
        return { left: (AccountAuthorizationHold.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Account balances presented to inquirer such as card processor
 */
export interface AccountBalances {
    /**
     * The unique account identifier
     */
    accountId?: string | undefined
    /**
     * The available balance of a deposit or credit account
     */
    availableBalance?: number | undefined
    /**
     * The card type either DEBIT or CREDIT
     */
    cardType?: 'DEBIT' | 'CREDIT' | undefined
    /**
     * The overdraft limit of a deposit account or the loan amount in case of a credit account
     */
    creditLimit?: number | undefined
    /**
     * Currency code used for the account
     */
    currencyCode?: string | undefined
    /**
     * The current balance of a deposit account or principal balance of a revolving credit
     */
    totalBalance?: number | undefined
}

export const AccountBalances = {
    validate: AccountBalancesValidator as ValidateFunction<AccountBalances>,
    get schema() {
        return AccountBalances.validate.schema
    },
    get errors() {
        return AccountBalances.validate.errors ?? undefined
    },
    is: (o: unknown): o is AccountBalances => AccountBalances.validate(o) === true,
    parse: (o: unknown): { right: AccountBalances } | { left: DefinedError[] } => {
        if (AccountBalances.is(o)) {
            return { right: o }
        }
        return { left: (AccountBalances.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The account currency and identification
 */
export interface AccountDetails {
    /**
     * The currency of the account
     */
    currency?: string | undefined
    identification?: AccountIdentification | undefined
}

/**
 * The account identification details
 */
export interface AccountIdentification {
    /**
     * The account unique identifier
     */
    iban?: string | undefined
    other?: OtherAccountIdentification | undefined
}

/**
 * Represents the conversion rate used in accounting to convert amounts from one currency to organisation currency
 */
export interface AccountingRate {
    /**
     * The encoded key of the accounting rate, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * Rate validity end date (as Organization Time)
     */
    endDate?: string | undefined
    /**
     * Organisation currency code
     */
    fromCurrencyCode?: string | undefined
    /**
     * Value of rate to be used for accounting conversions
     */
    rate?: number | undefined
    /**
     * Rate validity start date (as Organization Time)
     */
    startDate?: string | undefined
    /**
     * Foreign currency code
     */
    toCurrencyCode?: string | undefined
}

export const AccountingRate = {
    validate: AccountingRateValidator as ValidateFunction<AccountingRate>,
    get schema() {
        return AccountingRate.validate.schema
    },
    get errors() {
        return AccountingRate.validate.errors ?? undefined
    },
    is: (o: unknown): o is AccountingRate => AccountingRate.validate(o) === true,
    parse: (o: unknown): { right: AccountingRate } | { left: DefinedError[] } => {
        if (AccountingRate.is(o)) {
            return { right: o }
        }
        return { left: (AccountingRate.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents information about the accounting report.
 */
export interface AccountingReport {
    /**
     * The list of the accounting report items.
     */
    items?: AccountingReportItem[] | undefined
    /**
     * The encoded key of the generated accounting report.
     */
    reportKey?: string | undefined
    /**
     * The accounting report generation status.
     */
    status?:
        | 'QUEUED'
        | 'IN_PROGRESS'
        | 'COMPLETE'
        | 'NOT_FOUND'
        | 'CANCEL'
        | 'TO_BE_CANCELED'
        | 'TIMED_OUT'
        | 'ERROR'
        | 'TRANSIENT_ERROR'
        | 'OVERRIDDEN'
        | 'RECOVERABLE_ERROR'
        | undefined
}

export const AccountingReport = {
    validate: AccountingReportValidator as ValidateFunction<AccountingReport>,
    get schema() {
        return AccountingReport.validate.schema
    },
    get errors() {
        return AccountingReport.validate.errors ?? undefined
    },
    is: (o: unknown): o is AccountingReport => AccountingReport.validate(o) === true,
    parse: (o: unknown): { right: AccountingReport } | { left: DefinedError[] } => {
        if (AccountingReport.is(o)) {
            return { right: o }
        }
        return { left: (AccountingReport.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents information about the accounting report amounts.
 */
export interface AccountingReportAmounts {
    /**
     * The closing balance amount of the general ledger account.
     */
    closingBalance?: number | undefined
    /**
     * The credit amount of the general ledger account.
     */
    credits?: number | undefined
    /**
     * The debit amount of the general ledger account.
     */
    debits?: number | undefined
    /**
     * The net change amount of the general ledger account.
     */
    netChange?: number | undefined
    /**
     * The opening balance amount of the general ledger account.
     */
    openingBalance?: number | undefined
}

/**
 * Represents the input for the accounting report generation.
 */
export interface AccountingReportGenerationInput {
    /**
     * The balance types to include in the generated report.
     */
    balanceTypes?: ('OPENING_BALANCE' | 'NET_CHANGE' | 'CLOSING_BALANCE')[] | undefined
    /**
     * The branch ID  or encoded key to filter general ledger journal entries by.
     */
    branchId?: string | undefined
    /**
     * The ISO currency code to filter general ledger accounts by.
     */
    currencyCode?: string | undefined
    /**
     * The inclusive end date in the organization time format and timezone that the general ledger journal entries' entry date is filtered to.
     */
    endDate: string
    /**
     * The account types to filter general ledger accounts by. For header general ledger accounts the report will reflect the sum of the detail general ledger accounts that match the given filters used.
     */
    glTypes?: GlTypes[] | undefined
    /**
     * The inclusive start date in the organization time format and timezone that the general ledger journal entries' entry date is filtered from.
     */
    startDate: string
}

export const AccountingReportGenerationInput = {
    validate: AccountingReportGenerationInputValidator as ValidateFunction<AccountingReportGenerationInput>,
    get schema() {
        return AccountingReportGenerationInput.validate.schema
    },
    get errors() {
        return AccountingReportGenerationInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is AccountingReportGenerationInput => AccountingReportGenerationInput.validate(o) === true,
    parse: (o: unknown): { right: AccountingReportGenerationInput } | { left: DefinedError[] } => {
        if (AccountingReportGenerationInput.is(o)) {
            return { right: o }
        }
        return { left: (AccountingReportGenerationInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the information about the accounting report generation status.
 */
export interface AccountingReportGenerationResponse {
    /**
     * The encoded key of the generated report.
     */
    reportKey?: string | undefined
    /**
     * The accounting report generation status.
     */
    status?:
        | 'QUEUED'
        | 'IN_PROGRESS'
        | 'COMPLETE'
        | 'NOT_FOUND'
        | 'CANCEL'
        | 'TO_BE_CANCELED'
        | 'TIMED_OUT'
        | 'ERROR'
        | 'TRANSIENT_ERROR'
        | 'OVERRIDDEN'
        | 'RECOVERABLE_ERROR'
        | undefined
}

export const AccountingReportGenerationResponse = {
    validate: AccountingReportGenerationResponseValidator as ValidateFunction<AccountingReportGenerationResponse>,
    get schema() {
        return AccountingReportGenerationResponse.validate.schema
    },
    get errors() {
        return AccountingReportGenerationResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is AccountingReportGenerationResponse => AccountingReportGenerationResponse.validate(o) === true,
    parse: (o: unknown): { right: AccountingReportGenerationResponse } | { left: DefinedError[] } => {
        if (AccountingReportGenerationResponse.is(o)) {
            return { right: o }
        }
        return { left: (AccountingReportGenerationResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the accounting report information about general ledger accounts and their amounts in both the organization's currency and foreign currencies.
 */
export interface AccountingReportItem {
    amounts?: AccountingReportAmounts | undefined
    foreignAmounts?: AccountingReportAmounts | undefined
    glAccount?: GLAccount | undefined
}

/**
 * Accounting settings, defines the accounting settings for the product.
 */
export interface AccountingSettings {
    /**
     * The calculation method used for accounting.
     */
    accountingMethod: 'NONE' | 'CASH' | 'ACCRUAL'
    /**
     * A list of accounting rules for the product.
     */
    accountingRules?: GLAccountingRule[] | undefined
    /**
     * The accounting interest calculation option selected for the product.
     */
    interestAccrualCalculation?: 'NONE' | 'AGGREGATED_AMOUNT' | 'BREAKDOWN_PER_ACCOUNT' | undefined
    /**
     * The interval defined for a product when the interest accrues should be maintained.
     */
    interestAccruedAccountingMethod?: 'NONE' | 'DAILY' | 'END_OF_MONTH' | undefined
}

/**
 * Adjustable interest rates settings for loan account
 */
export interface AccountInterestRateSettings {
    /**
     * The encoded key of the interest rate settings, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * Index rate source key.
     */
    indexSourceKey?: string | undefined
    /**
     * Interest rate value.
     */
    interestRate?: number | undefined
    /**
     * Maximum value allowed for index based interest rate. Valid only for index interest rate.
     */
    interestRateCeilingValue?: number | undefined
    /**
     * Minimum value allowed for index based interest rate. Valid only for index interest rate.
     */
    interestRateFloorValue?: number | undefined
    /**
     * Interest rate review frequency unit count. Valid only for index interest rate.
     */
    interestRateReviewCount?: number | undefined
    /**
     * Interest rate review frequency measurement unit. Valid only for index interest rate.
     */
    interestRateReviewUnit?: 'DAYS' | 'WEEKS' | 'MONTHS' | undefined
    /**
     * Interest calculation method: fixed or indexed(interest spread + active organization index interest rate)
     */
    interestRateSource: 'FIXED_INTEREST_RATE' | 'INDEX_INTEREST_RATE'
    /**
     * Interest spread value.
     */
    interestSpread?: number | undefined
    /**
     * Date since an interest rate is valid
     */
    validFrom: string
}

/**
 * Defines the settings for account linking.
 */
export interface AccountLinkSettings {
    /**
     * Shows whether the loan accounts created using this product can be linked to a savings account.
     */
    enabled: boolean
    /**
     * Loan accounts created for this product can only be linked the the savings accounts that use the savings product with this key. If null, the loan accounts for this product can be linked to any savings account.
     */
    linkableDepositProductKey?: string | undefined
    /**
     * A set of linked account options.
     */
    linkedAccountOptions?: ('AUTO_LINK_ACCOUNTS' | 'AUTO_CREATE_LINKED_ACCOUNTS')[] | undefined
    /**
     * Set the option of automated transfer that should be made from linked deposit accounts into loan accounts create from this product.
     */
    settlementMethod?: 'FULL_DUE_AMOUNTS' | 'PARTIAL_DUE_AMOUNTS' | 'NO_AUTOMATED_TRANSFERS' | undefined
}

/**
 * The account tax corresponding for deposit account
 */
export interface AccountTax {
    /**
     * The date when the rate availability was created.
     */
    creationDate?: string | undefined
    /**
     * The date when the tax source starts to be used by the account.
     */
    fromDate?: string | undefined
    /**
     * The last date when the rate availability was modified.
     */
    lastModifiedDate?: string | undefined
    rateSourceEncodedKey?: string | undefined
    /**
     * The id of the source
     */
    rateSourceId?: string | undefined
    /**
     * The name of the source
     */
    rateSourceName?: string | undefined
    savingsAccountEncodedKey?: string | undefined
    /**
     * The ending date of the tax source used by the account
     */
    toDate?: string | undefined
}

/**
 * Represents the account to add to the credit arrangement.
 */
export interface AddCreditArrangementAccountInput {
    /**
     * The encoded key of the account.
     */
    accountId: string
    /**
     * The type of the account.
     */
    accountType: 'LOAN' | 'DEPOSIT'
}

export const AddCreditArrangementAccountInput = {
    validate: AddCreditArrangementAccountInputValidator as ValidateFunction<AddCreditArrangementAccountInput>,
    get schema() {
        return AddCreditArrangementAccountInput.validate.schema
    },
    get errors() {
        return AddCreditArrangementAccountInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is AddCreditArrangementAccountInput => AddCreditArrangementAccountInput.validate(o) === true,
    parse: (o: unknown): { right: AddCreditArrangementAccountInput } | { left: DefinedError[] } => {
        if (AddCreditArrangementAccountInput.is(o)) {
            return { right: o }
        }
        return { left: (AddCreditArrangementAccountInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents an address.
 */
export interface Address {
    /**
     * The city for the address.
     */
    city?: string | undefined
    /**
     * The country.
     */
    country?: string | undefined
    /**
     * The address encoded key, which is unique and generated.
     */
    encodedKey?: string | undefined
    /**
     * The index of this address in the list of addresses.
     */
    indexInList?: number | undefined
    /**
     * The GPS latitude of this address in signed degrees format (DDD.dddd) with 6 decimal positions, ranging from -90 to +90.
     */
    latitude?: number | undefined
    /**
     * The first line of the address.
     */
    line1?: string | undefined
    /**
     * The second line of the address.
     */
    line2?: string | undefined
    /**
     * The GPS longitude of this address in signed degrees format (DDD.dddd) with 6 decimal positions, ranging from -180 to +180.
     */
    longitude?: number | undefined
    /**
     * The address parent key indicating the object owning this address. For example: client, centre, or branch.
     */
    parentKey?: string | undefined
    /**
     * The post code.
     */
    postcode?: string | undefined
    /**
     * The region for the address.
     */
    region?: string | undefined
}

/**
 * Contains the details for the spread of the adjusted amount over the installments
 */
export interface AdjustTransactionInstallmentDetailsDTO {
    /**
     * The amount to be added on the fee/penalty due amounts (depending on transaction type), on the corresponding installment
     */
    amountToAdd?: number | undefined
    /**
     * The encoded key of the installment
     */
    installmentKey?: string | undefined
}

/**
 * The agent details for a party
 */
export interface Agent {
    financialInstitutionIdentification?: FinancialInstitutionIdentification | undefined
}

/**
 * Represents a simple installment amount structure.
 */
export interface Amount {
    /**
     * The due amount.
     */
    due?: number | undefined
    /**
     * The expected amount, which is sum of paid and due amounts.
     */
    expected?: number | undefined
    /**
     * The paid amount.
     */
    paid?: number | undefined
}

/**
 * Decimal constraints, like min/max/default.
 */
export interface AmountDecimalConstraints {
    /**
     * The default value, will be used in case no other value was filled in by the user.
     */
    defaultValue?: number | undefined
    /**
     * The encoded key of the decimal constraint, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * The maximum value.
     */
    maxValue?: number | undefined
    /**
     * The minimum value.
     */
    minValue?: number | undefined
}

/**
 * Decimal constraints, like min/max/default.
 */
export interface AmountDecimalInterval {
    /**
     * The default value, will be used in case no other value was filled in by the user.
     */
    defaultValue?: number | undefined
    /**
     * The maximum value.
     */
    maxValue?: number | undefined
    /**
     * The minimum value.
     */
    minValue?: number | undefined
}

/**
 * Represents a simple installment amount structure.
 */
export interface AmountWithReduced {
    /**
     * The due amount.
     */
    due?: number | undefined
    /**
     * The expected amount, which is sum of paid and due amounts.
     */
    expected?: number | undefined
    /**
     * The paid amount.
     */
    paid?: number | undefined
    /**
     * The reduced amount.
     */
    reduced?: number | undefined
}

/**
 * Represents an API consumer.
 */
export interface ApiConsumer {
    access?: ApiConsumerAccess | undefined
    /**
     * The encoded key of the branch this API consumer is assigned to.
     */
    assignedBranchKey?: string | undefined
    /**
     * The date when the API consumer was created in UTC.
     */
    creationDate?: string | undefined
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The ID of the API consumer.
     */
    id?: string | undefined
    /**
     * The last time the API consumer was modified in UTC.
     */
    lastModifiedDate?: string | undefined
    /**
     * The API consumer name.
     */
    name: string
    role?: RoleIdentifier | undefined
    /**
     * The API consumer transaction limits.
     */
    transactionLimits?:
        | {
              [k: string]: number | undefined
          }
        | undefined
}

export const ApiConsumer = {
    validate: ApiConsumerValidator as ValidateFunction<ApiConsumer>,
    get schema() {
        return ApiConsumer.validate.schema
    },
    get errors() {
        return ApiConsumer.validate.errors ?? undefined
    },
    is: (o: unknown): o is ApiConsumer => ApiConsumer.validate(o) === true,
    parse: (o: unknown): { right: ApiConsumer } | { left: DefinedError[] } => {
        if (ApiConsumer.is(o)) {
            return { right: o }
        }
        return { left: (ApiConsumer.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the API consumer permissions and access rights.
 */
export interface ApiConsumerAccess {
    /**
     * `TRUE` if the API consumer has the administrator user type, `FALSE` otherwise. Administrators (admins) have all permissions and can perform any action in Mambu.
     */
    administratorAccess?: boolean | undefined
    /**
     * `TRUE` if the API consumer can authenticate and interact with Mambu APIs, `FALSE` otherwise. The API consumer may still require additional permissions for specific API requests.
     */
    apiAccess?: boolean | undefined
    /**
     * `TRUE` if the API consumer permissions apply to all branches, `FALSE` if they only apply to specific branches.
     */
    canManageAllBranches?: boolean | undefined
    /**
     * `TRUE` if the API consumer (that has the credit officer access) can access entities (for example, clients or accounts) assigned to other credit officers, `FALSE` otherwise.
     */
    canManageEntitiesAssignedToOtherOfficers?: boolean | undefined
    /**
     * `TRUE` if the API consumer has the credit officer user type, `FALSE` otherwise. Credit officers have the option of having clients and groups assigned to them.
     */
    creditOfficerAccess?: boolean | undefined
    /**
     * The list of branches that can be managed by the API consumer. If the API consumer has the `canManageAllBranches` property set to `TRUE`, this list does not apply.
     */
    managedBranches?: UserManagedBranch[] | undefined
    /**
     * Permissions for the API consumer. The non-admin API consumers and users are authorized to do actions based a set of permissions in order to access Mambu features. Permissions may be relevant for the API and/or the Mambu UI.
     */
    permissions?: Permissions[] | undefined
}

/**
 * Represents an API key of an API consumer.
 */
export interface ApiKey {
    /**
     * A six character cleartext prefix of the API key. The prefix is not guaranteed to be unique. You must base any identification process on the API key ID, not the prefix.
     */
    apiKey?: string | undefined
    /**
     * The time to live (TTL) for the API key in seconds.
     */
    expirationTime?: number | undefined
    /**
     * The API key ID. You must base any identification process on the the API key ID as it is guaranteed to be unique.
     */
    id?: string | undefined
}

export const ApiKey = {
    validate: ApiKeyValidator as ValidateFunction<ApiKey>,
    get schema() {
        return ApiKey.validate.schema
    },
    get errors() {
        return ApiKey.validate.errors ?? undefined
    },
    is: (o: unknown): o is ApiKey => ApiKey.validate(o) === true,
    parse: (o: unknown): { right: ApiKey } | { left: DefinedError[] } => {
        if (ApiKey.is(o)) {
            return { right: o }
        }
        return { left: (ApiKey.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents an API key expiration time.
 */
export interface ApiKeyInput {
    /**
     * The time to live (TTL) for the API key in seconds.
     */
    expirationTime?: number | undefined
}

export const ApiKeyInput = {
    validate: ApiKeyInputValidator as ValidateFunction<ApiKeyInput>,
    get schema() {
        return ApiKeyInput.validate.schema
    },
    get errors() {
        return ApiKeyInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is ApiKeyInput => ApiKeyInput.validate(o) === true,
    parse: (o: unknown): { right: ApiKeyInput } | { left: DefinedError[] } => {
        if (ApiKeyInput.is(o)) {
            return { right: o }
        }
        return { left: (ApiKeyInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the result of an API key rotation.
 */
export interface ApiKeyRotationResult {
    /**
     * The new API key created after rotating an existing API key.
     */
    apiKey?: string | undefined
    /**
     * The API key ID. You must base any identification process on the the API key ID as it is guaranteed to be unique.
     */
    id?: string | undefined
    /**
     * The new secret key created after rotating an existing API key.
     */
    secretKey?: string | undefined
}

export const ApiKeyRotationResult = {
    validate: ApiKeyRotationResultValidator as ValidateFunction<ApiKeyRotationResult>,
    get schema() {
        return ApiKeyRotationResult.validate.schema
    },
    get errors() {
        return ApiKeyRotationResult.validate.errors ?? undefined
    },
    is: (o: unknown): o is ApiKeyRotationResult => ApiKeyRotationResult.validate(o) === true,
    parse: (o: unknown): { right: ApiKeyRotationResult } | { left: DefinedError[] } => {
        if (ApiKeyRotationResult.is(o)) {
            return { right: o }
        }
        return { left: (ApiKeyRotationResult.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Describes the application status regarding the data access
 */
export interface ApplicationStatus {
    /**
     * Data access state
     */
    dataAccessState?: 'READ_ONLY_STATE' | 'WRITE_READ_STATE' | undefined
}

export const ApplicationStatus = {
    validate: ApplicationStatusValidator as ValidateFunction<ApplicationStatus>,
    get schema() {
        return ApplicationStatus.validate.schema
    },
    get errors() {
        return ApplicationStatus.validate.errors ?? undefined
    },
    is: (o: unknown): o is ApplicationStatus => ApplicationStatus.validate(o) === true,
    parse: (o: unknown): { right: ApplicationStatus } | { left: DefinedError[] } => {
        if (ApplicationStatus.is(o)) {
            return { right: o }
        }
        return { left: (ApplicationStatus.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents a request for applying the accrued interest
 */
export interface ApplyInterestInput {
    /**
     * The date up to which interest is to be posted
     */
    interestApplicationDate: string
    /**
     * Whether the interest amount to apply should be the regular one or interest from arrears. If nothing specified it will be the regular one.
     */
    isInterestFromArrears?: boolean | undefined
    /**
     * Whether the interest amount to apply should be the regular one or the one accrued during the Payment Holidays. If nothing specified it will be the regular one.
     */
    isPaymentHolidaysInterest?: boolean | undefined
    /**
     * Additional information for this action
     */
    notes?: string | undefined
    /**
     * The amount of the Payment Holidays interest to apply
     */
    paymentHolidaysInterestAmount?: number | undefined
}

export const ApplyInterestInput = {
    validate: ApplyInterestInputValidator as ValidateFunction<ApplyInterestInput>,
    get schema() {
        return ApplyInterestInput.validate.schema
    },
    get errors() {
        return ApplyInterestInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is ApplyInterestInput => ApplyInterestInput.validate(o) === true,
    parse: (o: unknown): { right: ApplyInterestInput } | { left: DefinedError[] } => {
        if (ApplyInterestInput.is(o)) {
            return { right: o }
        }
        return { left: (ApplyInterestInput.errors ?? []) as DefinedError[] }
    },
} as const

export type ApplyPlannedFeesResponse = LoanTransaction[]

export const ApplyPlannedFeesResponse = {
    validate: ApplyPlannedFeesResponseValidator as ValidateFunction<ApplyPlannedFeesResponse>,
    get schema() {
        return ApplyPlannedFeesResponse.validate.schema
    },
    get errors() {
        return ApplyPlannedFeesResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is ApplyPlannedFeesResponse => ApplyPlannedFeesResponse.validate(o) === true,
    parse: (o: unknown): { right: ApplyPlannedFeesResponse } | { left: DefinedError[] } => {
        if (ApplyPlannedFeesResponse.is(o)) {
            return { right: o }
        }
        return { left: (ApplyPlannedFeesResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the archived custom field values of a deposit transaction.
 */
export interface ArchivedDepositTransaction {
    /**
     * The id of the archived deposit transaction, unique
     */
    transactionId: number
    /**
     * The date of entry created for the deposit transaction to be archived
     */
    valueDate?: string | undefined
}

export const ArchivedDepositTransaction = {
    validate: ArchivedDepositTransactionValidator as ValidateFunction<ArchivedDepositTransaction>,
    get schema() {
        return ArchivedDepositTransaction.validate.schema
    },
    get errors() {
        return ArchivedDepositTransaction.validate.errors ?? undefined
    },
    is: (o: unknown): o is ArchivedDepositTransaction => ArchivedDepositTransaction.validate(o) === true,
    parse: (o: unknown): { right: ArchivedDepositTransaction } | { left: DefinedError[] } => {
        if (ArchivedDepositTransaction.is(o)) {
            return { right: o }
        }
        return { left: (ArchivedDepositTransaction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Asset, holds information about a client asset entry.
 */
export interface Asset {
    /**
     * The amount used by the client for the guaranty
     */
    amount: number
    /**
     * The name of a value the client guarantees with (populated when the guaranty type is ASSET)
     */
    assetName: string
    /**
     * The key of the deposit account used by the guarantor (populated when the guaranty type is GUARANTOR). It can be null.
     */
    depositAccountKey?: string | undefined
    /**
     * The encoded key of the security, auto generated, unique.
     */
    encodedKey?: string | undefined
    /**
     * The key of the client/group used as the guarantor.
     */
    guarantorKey?: string | undefined
    /**
     * The type of the guarantor (client/group)
     */
    guarantorType?: 'CLIENT' | 'GROUP' | undefined
    /**
     * The original amount used by the client for a collateral asset
     */
    originalAmount?: number | undefined
    originalCurrency?: Currency | undefined
}

/**
 * Group of transactions to be executed atomically.
 */
export interface AtomicGroup {
    /**
     * The id of the atomic group, customizable, unique
     */
    atomicGroupId?: string | undefined
    /**
     * Transactions list
     */
    transactions?: DepositsTransaction[] | undefined
}

/**
 * The authorization hold corresponding to a card token
 */
export interface AuthorizationHold {
    /**
     * The key of the account linked with the authorization hold.
     */
    accountKey?: string | undefined
    /**
     * Whether the given request should be accepted without balance validations.
     */
    advice: boolean
    /**
     * The amount of money to be held as a result of the authorization hold request.
     */
    amount: number
    balances?: AccountBalances | undefined
    cardAcceptor?: CardAcceptor | undefined
    /**
     * The reference token of the card.
     */
    cardToken?: string | undefined
    /**
     * The organization time when the authorization hold was created
     */
    creationDate?: string | undefined
    /**
     * Indicates whether the authorization hold amount is credited or debited.If not provided, the default values is DBIT.
     */
    creditDebitIndicator?: 'DBIT' | 'CRDT' | undefined
    /**
     * The ISO currency code in which the hold was created. The amounts are stored in the base currency, but the user could have enter it in a foreign currency.
     */
    currencyCode?: string | undefined
    /**
     * The custom expiration period for the hold which overwrites mcc and default expiration periods
     */
    customExpirationPeriod?: number | undefined
    /**
     * The exchange rate for the original currency.
     */
    exchangeRate?: number | undefined
    /**
     * The external reference ID to be used to reference the account hold in subsequent requests.
     */
    externalReferenceId: string
    /**
     * The original amount of money to be held as a result of the authorization hold request.
     */
    originalAmount?: number | undefined
    /**
     * The original currency in which the hold was created.
     */
    originalCurrency?: string | undefined
    /**
     * Indicates whether the authorization is partial or not
     */
    partial?: boolean | undefined
    /**
     * The date to consider as start date when calculating the number of days passed until expiration
     */
    referenceDateForExpiration?: string | undefined
    /**
     * Indicates the source of the authorization hold, the default values is CARD.
     */
    source?: 'CARD' | 'ACCOUNT' | undefined
    /**
     * The authorization hold status.
     */
    status?: 'PENDING' | 'REVERSED' | 'SETTLED' | 'EXPIRED' | undefined
    /**
     * The formatted time at which the user made this authorization hold.
     */
    userTransactionTime?: string | undefined
}

export const AuthorizationHold = {
    validate: AuthorizationHoldValidator as ValidateFunction<AuthorizationHold>,
    get schema() {
        return AuthorizationHold.validate.schema
    },
    get errors() {
        return AuthorizationHold.validate.errors ?? undefined
    },
    is: (o: unknown): o is AuthorizationHold => AuthorizationHold.validate(o) === true,
    parse: (o: unknown): { right: AuthorizationHold } | { left: DefinedError[] } => {
        if (AuthorizationHold.is(o)) {
            return { right: o }
        }
        return { left: (AuthorizationHold.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * A request to decrease/increase the amount of an authorization hold.
 */
export interface AuthorizationHoldAmountAdjustmentRequest {
    /**
     * Whether the given request should be accepted without balance validations.
     */
    advice?: boolean | undefined
    /**
     * The amount of money to be subtracted/added to the authorization hold amount. For the decrease: if the amount is greater or equal to the authorization hold amount, then the authorization hold is reversed.
     */
    amount: number
    /**
     * The ISO currency code in which the hold was created.
     */
    currencyCode?: string | undefined
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The external reference ID of the decrease/increase request (not of the authorization hold).
     */
    externalReferenceId?: string | undefined
}

export const AuthorizationHoldAmountAdjustmentRequest = {
    validate: AuthorizationHoldAmountAdjustmentRequestValidator as ValidateFunction<AuthorizationHoldAmountAdjustmentRequest>,
    get schema() {
        return AuthorizationHoldAmountAdjustmentRequest.validate.schema
    },
    get errors() {
        return AuthorizationHoldAmountAdjustmentRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is AuthorizationHoldAmountAdjustmentRequest =>
        AuthorizationHoldAmountAdjustmentRequest.validate(o) === true,
    parse: (o: unknown): { right: AuthorizationHoldAmountAdjustmentRequest } | { left: DefinedError[] } => {
        if (AuthorizationHoldAmountAdjustmentRequest.is(o)) {
            return { right: o }
        }
        return { left: (AuthorizationHoldAmountAdjustmentRequest.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents details of the Background Process
 */
export interface BackgroundProcess {
    /**
     * When this process was created. Stored as Organization Time
     */
    creationDate?: string | undefined
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * When this process was ended. Stored as Organization Time
     */
    endDate?: string | undefined
    /**
     * When this process was started. Stored as Organization Time
     */
    startDate?: string | undefined
    /**
     * The current status of this process
     */
    state?:
        | 'QUEUED'
        | 'IN_PROGRESS'
        | 'COMPLETE'
        | 'NOT_FOUND'
        | 'CANCEL'
        | 'TO_BE_CANCELED'
        | 'TIMED_OUT'
        | 'ERROR'
        | 'TRANSIENT_ERROR'
        | 'OVERRIDDEN'
        | 'RECOVERABLE_ERROR'
        | undefined
    /**
     * The type of the background process
     */
    type?: 'CRON_JOBS' | 'MANUAL_CRON_JOBS_TRIGGER' | undefined
}

export const BackgroundProcess = {
    validate: BackgroundProcessValidator as ValidateFunction<BackgroundProcess>,
    get schema() {
        return BackgroundProcess.validate.schema
    },
    get errors() {
        return BackgroundProcess.validate.errors ?? undefined
    },
    is: (o: unknown): o is BackgroundProcess => BackgroundProcess.validate(o) === true,
    parse: (o: unknown): { right: BackgroundProcess } | { left: DefinedError[] } => {
        if (BackgroundProcess.is(o)) {
            return { right: o }
        }
        return { left: (BackgroundProcess.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The loan account balance details.
 */
export interface Balances {
    /**
     * The fees balance. Represents the total fees expected to be paid on this account at a given moment.
     */
    feesBalance?: number | undefined
    /**
     * The fees due. Representing the total fees due for the account.
     */
    feesDue?: number | undefined
    /**
     * The fees paid. Represents the total fees paid for the account.
     */
    feesPaid?: number | undefined
    /**
     * The sum of all the authorization hold amounts on this account.
     */
    holdBalance?: number | undefined
    /**
     * Represents the total interest owed by the client (total interest applied for account minus interest paid).
     */
    interestBalance?: number | undefined
    /**
     * The interest due. Indicates how much interest it's due for the account at this moment.
     */
    interestDue?: number | undefined
    /**
     * The interest from arrears balance. Indicates interest from arrears owned by the client, from now on. (total interest from arrears accrued for account - interest from arrears paid).
     */
    interestFromArrearsBalance?: number | undefined
    /**
     * The interest from arrears due. Indicates how much interest from arrears it's due for the account at this moment.
     */
    interestFromArrearsDue?: number | undefined
    /**
     * The interest from arrears paid, indicates total interest from arrears paid into the account.
     */
    interestFromArrearsPaid?: number | undefined
    /**
     * The interest paid, indicates total interest paid into the account.
     */
    interestPaid?: number | undefined
    /**
     * The penalty balance. Represents the total penalty expected to be paid on this account at a given moment.
     */
    penaltyBalance?: number | undefined
    /**
     * The penalty due. Represents the total penalty amount due for the account.
     */
    penaltyDue?: number | undefined
    /**
     * The Penalty paid. Represents the total penalty amount paid for the account.
     */
    penaltyPaid?: number | undefined
    /**
     * The total principal owned by the client, from now on (principal disbursed - principal paid).
     */
    principalBalance?: number | undefined
    /**
     * The principal due, indicates how much principal it's due at this moment.
     */
    principalDue?: number | undefined
    /**
     * The principal paid, holds the value of the total paid into the account.
     */
    principalPaid?: number | undefined
    /**
     * The total redraw amount owned by the client, from now on.
     */
    redrawBalance?: number | undefined
}

/**
 * Represents the user permissions and access rights.
 */
export interface BaseUserAccess {
    /**
     * `TRUE` if the user has the administrator user type, `FALSE` otherwise. Administrators (admins) have all permissions and can perform any action in Mambu.
     */
    administratorAccess?: boolean | undefined
    /**
     * `TRUE` if the user can authenticate and interact with Mambu APIs, `FALSE` otherwise. The user may still require additional permissions for specific API requests.
     */
    apiAccess?: boolean | undefined
    /**
     * `TRUE` if the user has the credit officer user type, `FALSE` otherwise. Credit officers have the option of having clients and groups assigned to them.
     */
    creditOfficerAccess?: boolean | undefined
    /**
     * `TRUE` if the user is part of the Mambu delivery team, `FALSE` otherwise.
     */
    deliveryAccess?: boolean | undefined
    /**
     * TRUE` if the user can log in to the Mambu UI using their login credentials, `FALSE` otherwise.
     */
    mambuAccess?: boolean | undefined
    /**
     * Permissions for the user. The non-admin users are authorized to do actions based a set of permissions in order to access Mambu features. Permissions may be relevant for the API and/or the Mambu UI.
     */
    permissions?: Permissions3[] | undefined
    /**
     * `TRUE` if the user can provide Mambu technical support, `FALSE` otherwise.
     */
    supportAccess?: boolean | undefined
    /**
     * `TRUE` if the user has the teller user type, `FALSE` otherwise. Tellers have access to the teller module and specific tellering permissions, which allow them to take actions such as opening or closing tills, posting transactions on a till, and adding and removing cash from a till.
     */
    tellerAccess?: boolean | undefined
}

/**
 * Defines the billing cycles settings for a loan account
 */
export interface BillingCycleDays {
    /**
     * The billing cycle start days in case it is enabled
     */
    days?: number[] | undefined
}

/**
 * Defines the billing cycles settings for revolving credit products
 */
export interface BillingCyclesProductSettings {
    /**
     * The billing cycle status if it is enabled or disabled
     */
    enabled?: boolean | undefined
    /**
     * The billing cycle start days in case it is enabled
     */
    startDays?: number[] | undefined
}

/**
 * Represents the block fund amount that can be later seized on the account
 */
export interface BlockFund {
    /**
     * The key of the account which block fund belongs to
     */
    accountKey?: string | undefined
    /**
     * The amount to be blocked
     */
    amount: number
    /**
     * The date at which the block fund was created
     */
    creationDate?: string | undefined
    /**
     * The external reference ID to be used to reference the block fund in subsequent requests
     */
    externalReferenceId: string
    /**
     * The date at which the block fund was created
     */
    lastModifiedDate?: string | undefined
    /**
     * Notes about this block fund
     */
    notes?: string | undefined
    /**
     * The amount that has been seized
     */
    seizedAmount?: number | undefined
    /**
     * The state of the block fund
     */
    state?: 'PENDING' | 'SEIZED' | 'REMOVED' | 'PARTIALLY_SEIZED' | undefined
}

export const BlockFund = {
    validate: BlockFundValidator as ValidateFunction<BlockFund>,
    get schema() {
        return BlockFund.validate.schema
    },
    get errors() {
        return BlockFund.validate.errors ?? undefined
    },
    is: (o: unknown): o is BlockFund => BlockFund.validate(o) === true,
    parse: (o: unknown): { right: BlockFund } | { left: DefinedError[] } => {
        if (BlockFund.is(o)) {
            return { right: o }
        }
        return { left: (BlockFund.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents a branch.
 */
export interface Branch {
    /**
     * The list of branch addresses.
     */
    addresses?: Address[] | undefined
    /**
     * The list of branch holidays.
     */
    branchHolidays?: Holiday[] | undefined
    /**
     * The creation date of the branch.
     */
    creationDate?: string | undefined
    /**
     * The branch email address.
     */
    emailAddress?: string | undefined
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The branch ID, which must be unique.
     */
    id: string
    /**
     * The last date when the branch was modified.
     */
    lastModifiedDate?: string | undefined
    /**
     * The branch name.
     */
    name: string
    /**
     * The notes or description attached to this object.
     */
    notes?: string | undefined
    /**
     * The branch phone number.
     */
    phoneNumber?: string | undefined
    /**
     * The branch state.
     */
    state?: 'ACTIVE' | 'INACTIVE' | undefined
}

export const Branch = {
    validate: BranchValidator as ValidateFunction<Branch>,
    get schema() {
        return Branch.validate.schema
    },
    get errors() {
        return Branch.validate.errors ?? undefined
    },
    is: (o: unknown): o is Branch => Branch.validate(o) === true,
    parse: (o: unknown): { right: Branch } | { left: DefinedError[] } => {
        if (Branch.is(o)) {
            return { right: o }
        }
        return { left: (Branch.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Holds information about branch availability for the product.
 */
export interface BranchSettings {
    /**
     * Holds the encoded keys of the branches this product should be available for.
     */
    availableProductBranches?: string[] | undefined
    /**
     * Indicates if this product should be available for all branches
     */
    forAllBranches?: boolean | undefined
}

/**
 * Represents the request payload for creating a bulk deposit transactions.
 */
export interface BulkDepositTransactionsInput {
    /**
     * The list of transactions
     */
    transactions?: DepositTransactionBulkableInputDTO[] | undefined
}

export const BulkDepositTransactionsInput = {
    validate: BulkDepositTransactionsInputValidator as ValidateFunction<BulkDepositTransactionsInput>,
    get schema() {
        return BulkDepositTransactionsInput.validate.schema
    },
    get errors() {
        return BulkDepositTransactionsInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is BulkDepositTransactionsInput => BulkDepositTransactionsInput.validate(o) === true,
    parse: (o: unknown): { right: BulkDepositTransactionsInput } | { left: DefinedError[] } => {
        if (BulkDepositTransactionsInput.is(o)) {
            return { right: o }
        }
        return { left: (BulkDepositTransactionsInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the filter to be used for selecting the accounts to which new interest availability settings will be pushed. One of the 2 fields: productId or ids should be supplied
 */
export interface BulkInterestAccountSettingsAvailabilityFilter {
    /**
     * Ids of accounts that should be processed
     */
    ids?: string[] | undefined
    /**
     * Product id to be used for selecting all accounts that should be processed
     */
    productId?: string | undefined
}

/**
 * Represents the bulk payload for storing interest availabilities to a group of accounts
 */
export interface BulkInterestAccountSettingsAvailabilityInput {
    accountFilter: BulkInterestAccountSettingsAvailabilityFilter
    interestAvailability: InterestAccountSettingsAvailability
}

export const BulkInterestAccountSettingsAvailabilityInput = {
    validate:
        BulkInterestAccountSettingsAvailabilityInputValidator as ValidateFunction<BulkInterestAccountSettingsAvailabilityInput>,
    get schema() {
        return BulkInterestAccountSettingsAvailabilityInput.validate.schema
    },
    get errors() {
        return BulkInterestAccountSettingsAvailabilityInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is BulkInterestAccountSettingsAvailabilityInput =>
        BulkInterestAccountSettingsAvailabilityInput.validate(o) === true,
    parse: (o: unknown): { right: BulkInterestAccountSettingsAvailabilityInput } | { left: DefinedError[] } => {
        if (BulkInterestAccountSettingsAvailabilityInput.is(o)) {
            return { right: o }
        }
        return { left: (BulkInterestAccountSettingsAvailabilityInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Holds information about the error encountered processing an item in bulk
 */
export interface BulkProcessingError {
    /**
     * Numeric value associated to the error reason
     */
    errorCode?: number | undefined
    /**
     * Error reason
     */
    errorReason?: string | undefined
    /**
     * Details about the error
     */
    errorSource?: string | undefined
    /**
     * Optional field populated only when request payload contains an externalId
     */
    externalId?: string | undefined
    /**
     * The index of the entity/item from bulk request that failed on processing
     */
    indexInRequest?: number | undefined
}

/**
 * Holds details about successful processed item
 */
export interface BulkProcessingSuccess {
    /**
     * Optional field populated only when request payload contains an externalId
     */
    externalId?: string | undefined
    /**
     * Unique identifier for the newly created resource
     */
    id?: string | undefined
    /**
     * The index of the entity/item from bulk request that failed on processing
     */
    indexInRequest?: number | undefined
}

/**
 * Holds information about the status of a bulk process
 */
export interface BulkProcessStatus {
    /**
     * List of errors
     */
    errors?: BulkProcessingError[] | undefined
    /**
     * List of successful processed items
     */
    processedItems?: BulkProcessingSuccess[] | undefined
    /**
     * Bulk process status
     */
    status?:
        | 'QUEUED'
        | 'IN_PROGRESS'
        | 'COMPLETE'
        | 'NOT_FOUND'
        | 'CANCEL'
        | 'TO_BE_CANCELED'
        | 'TIMED_OUT'
        | 'ERROR'
        | 'TRANSIENT_ERROR'
        | 'OVERRIDDEN'
        | 'RECOVERABLE_ERROR'
        | undefined
}

export const BulkProcessStatus = {
    validate: BulkProcessStatusValidator as ValidateFunction<BulkProcessStatus>,
    get schema() {
        return BulkProcessStatus.validate.schema
    },
    get errors() {
        return BulkProcessStatus.validate.errors ?? undefined
    },
    is: (o: unknown): o is BulkProcessStatus => BulkProcessStatus.validate(o) === true,
    parse: (o: unknown): { right: BulkProcessStatus } | { left: DefinedError[] } => {
        if (BulkProcessStatus.is(o)) {
            return { right: o }
        }
        return { left: (BulkProcessStatus.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Returns a card that can be associated to a deposit or loan  account. Cards consist only of card reference tokens and the card details are not stored in Mambu.
 */
export interface Card {
    /**
     * The card's reference token.
     */
    referenceToken: string
}

export const Card = {
    validate: CardValidator as ValidateFunction<Card>,
    get schema() {
        return Card.validate.schema
    },
    get errors() {
        return Card.validate.errors ?? undefined
    },
    is: (o: unknown): o is Card => Card.validate(o) === true,
    parse: (o: unknown): { right: Card } | { left: DefinedError[] } => {
        if (Card.is(o)) {
            return { right: o }
        }
        return { left: (Card.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The details of the card acceptor (merchant) in a transaction hold.
 */
export interface CardAcceptor {
    /**
     * The city in which the card acceptor has the business.
     */
    city?: string | undefined
    /**
     * The country in which the card acceptor has the business.
     */
    country?: string | undefined
    /**
     * The Merchant Category Code of the card acceptor.
     */
    mcc?: number | undefined
    /**
     * The name of the card acceptor.
     */
    name?: string | undefined
    /**
     * The state in which the card acceptor has the business.
     */
    state?: string | undefined
    /**
     * The street in which the card acceptor has the business.
     */
    street?: string | undefined
    /**
     * The ZIP code of the location in which the card acceptor has the business.
     */
    zip?: string | undefined
}

/**
 * A card transaction entry which will have a corresponding a financial transaction performed.
 */
export interface CardTransaction {
    /**
     * Whether the given request should be accepted without balance validations.
     */
    advice: boolean
    /**
     * The amount of money to be withdrawn in the financial transaction.
     */
    amount: number
    cardAcceptor?: CardAcceptor | undefined
    /**
     * The reference token of the card.
     */
    cardToken?: string | undefined
    /**
     * The ISO currency code in which the card reversal transaction is posted. The amounts are stored in the base currency, but the transaction can be created with a foreign currency.
     */
    currencyCode?: string | undefined
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The external authorization hold reference ID, which relates this card transaction to a previous authorization hold.
     */
    externalAuthorizationReferenceId?: string | undefined
    /**
     * The external reference ID to be used to reference the card transaction in subsequent requests.
     */
    externalReferenceId: string
    /**
     * The formatted time at which the user made this card transaction.
     */
    userTransactionTime?: string | undefined
}

/**
 * A card transaction entry which will have a corresponding a financial transaction performed.
 */
export interface CardTransactionInput {
    /**
     * Whether the given request should be accepted without balance validations.
     */
    advice: boolean
    /**
     * The amount of money to be withdrawn in the financial transaction.
     */
    amount: number
    cardAcceptor?: CardAcceptor | undefined
    /**
     * The reference token of the card.
     */
    cardToken?: string | undefined
    /**
     * If present, indicates that the card transaction is a refund, and whether is credited or debited
     */
    creditDebitIndicator?: 'DBIT' | 'CRDT' | undefined
    /**
     * The ISO currency code in which the card reversal transaction is posted. The amounts are stored in the base currency, but the transaction can be created with a foreign currency.
     */
    currencyCode?: string | undefined
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The external authorization hold reference ID, which relates this card transaction to a previous authorization hold.
     */
    externalAuthorizationReferenceId?: string | undefined
    /**
     * The external reference ID to be used to reference the card transaction in subsequent requests.
     */
    externalReferenceId: string
    /**
     * The date of the first repayment for the loan account (as Organization Time)
     */
    firstRepaymentDate?: string | undefined
    /**
     * Increase available amount if needed
     */
    increaseAmountIfNeeded?: boolean | undefined
    /**
     * Whether the given request should be a partial clearing or not.
     */
    partial?: boolean | undefined
    /**
     * The ID of the channel through which the payment is done.
     */
    transactionChannelId: string
    /**
     * The formatted time at which the user made this card transaction.
     */
    userTransactionTime?: string | undefined
}

export const CardTransactionInput = {
    validate: CardTransactionInputValidator as ValidateFunction<CardTransactionInput>,
    get schema() {
        return CardTransactionInput.validate.schema
    },
    get errors() {
        return CardTransactionInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is CardTransactionInput => CardTransactionInput.validate(o) === true,
    parse: (o: unknown): { right: CardTransactionInput } | { left: DefinedError[] } => {
        if (CardTransactionInput.is(o)) {
            return { right: o }
        }
        return { left: (CardTransactionInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * A card transaction output after a financial transaction was performed.
 */
export interface CardTransactionOutput {
    /**
     * Whether the given request should be accepted without balance validations.
     */
    advice: boolean
    /**
     * The amount of money to be withdrawn in the financial transaction.
     */
    amount: number
    balances?: AccountBalances | undefined
    cardAcceptor?: CardAcceptor | undefined
    /**
     * The reference token of the card.
     */
    cardToken?: string | undefined
    /**
     * If present, indicates that the card transaction is a refund, and whether is credited or debited
     */
    creditDebitIndicator?: 'DBIT' | 'CRDT' | undefined
    /**
     * The ISO currency code in which the card reversal transaction is posted. The amounts are stored in the base currency, but the transaction can be created with a foreign currency.
     */
    currencyCode?: string | undefined
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The external authorization hold reference ID, which relates this card transaction to a previous authorization hold.
     */
    externalAuthorizationReferenceId?: string | undefined
    /**
     * The external reference ID to be used to reference the card transaction in subsequent requests.
     */
    externalReferenceId: string
    /**
     * The date of the first repayment for the loan account (as Organization Time)
     */
    firstRepaymentDate?: string | undefined
    /**
     * Increase available amount if needed
     */
    increaseAmountIfNeeded?: boolean | undefined
    linkedTransaction?: LinkedTransaction | undefined
    /**
     * Whether the given request should be a partial clearing or not.
     */
    partial?: boolean | undefined
    /**
     * The ID of the channel through which the payment is done.
     */
    transactionChannelId: string
    /**
     * The formatted time at which the user made this card transaction.
     */
    userTransactionTime?: string | undefined
}

export const CardTransactionOutput = {
    validate: CardTransactionOutputValidator as ValidateFunction<CardTransactionOutput>,
    get schema() {
        return CardTransactionOutput.validate.schema
    },
    get errors() {
        return CardTransactionOutput.validate.errors ?? undefined
    },
    is: (o: unknown): o is CardTransactionOutput => CardTransactionOutput.validate(o) === true,
    parse: (o: unknown): { right: CardTransactionOutput } | { left: DefinedError[] } => {
        if (CardTransactionOutput.is(o)) {
            return { right: o }
        }
        return { left: (CardTransactionOutput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * A full or partial reversal of a card transaction.
 */
export interface CardTransactionReversal {
    /**
     * The amount of money to be credited in the client's account from the original card transaction.
     */
    amount: number
    /**
     * The ISO currency code in which the card reversal transaction is posted. The amounts are stored in the base currency, but the transaction can be created with a foreign currency.
     */
    currencyCode?: string | undefined
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The external reference ID to be used to reference the card reversal transaction in subsequent requests.
     */
    externalReferenceId: string
    /**
     * The id of the Deposit Transaction
     */
    id?: number | undefined
    /**
     * The ID of the channel through which the payment is done. If the value is not present, the value from the source card transaction is copied.
     */
    transactionChannelId?: string | undefined
}

export const CardTransactionReversal = {
    validate: CardTransactionReversalValidator as ValidateFunction<CardTransactionReversal>,
    get schema() {
        return CardTransactionReversal.validate.schema
    },
    get errors() {
        return CardTransactionReversal.validate.errors ?? undefined
    },
    is: (o: unknown): o is CardTransactionReversal => CardTransactionReversal.validate(o) === true,
    parse: (o: unknown): { right: CardTransactionReversal } | { left: DefinedError[] } => {
        if (CardTransactionReversal.is(o)) {
            return { right: o }
        }
        return { left: (CardTransactionReversal.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents a centre. A centre is a common meeting area that credit officers and the individual and group clients go to. Each centre is assigned to a branch (a branch can have multiple centres) and might have a specific meeting day and location.
 */
export interface Centre {
    /**
     * The addresses of this centre.
     */
    addresses?: Address[] | undefined
    /**
     * The encoded key of the branch this centre is assigned to.
     */
    assignedBranchKey?: string | undefined
    /**
     * The date the centre was created.
     */
    creationDate?: string | undefined
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The ID of the centre, which must be unique, and can be generated and customized.
     */
    id?: string | undefined
    /**
     * The last time the centre was modified.
     */
    lastModifiedDate?: string | undefined
    /**
     * The day of the week when repayments are collected. This influences the repayments schedule, upon update all repayments are updated to this day of the week.
     */
    meetingDay?: string | undefined
    /**
     * The name of the centre.
     */
    name?: string | undefined
    /**
     * The notes or description attached to this object.
     */
    notes?: string | undefined
    /**
     * The state of the centre.
     */
    state?: 'ACTIVE' | 'INACTIVE' | undefined
}

export const Centre = {
    validate: CentreValidator as ValidateFunction<Centre>,
    get schema() {
        return Centre.validate.schema
    },
    get errors() {
        return Centre.validate.errors ?? undefined
    },
    is: (o: unknown): o is Centre => Centre.validate(o) === true,
    parse: (o: unknown): { right: Centre } | { left: DefinedError[] } => {
        if (Centre.is(o)) {
            return { right: o }
        }
        return { left: (Centre.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the request payload for performing an arrears settings change action
 */
export interface ChangeArrearsSettingsInput {
    /**
     * The new arrears tolerance period to be available on the account
     */
    arrearsTolerancePeriod: number
    /**
     * The date when to change the arrears settings
     */
    entryDate: string
    /**
     * The notes for the change arrears settings action performed on the loan account
     */
    notes?: string | undefined
}

export const ChangeArrearsSettingsInput = {
    validate: ChangeArrearsSettingsInputValidator as ValidateFunction<ChangeArrearsSettingsInput>,
    get schema() {
        return ChangeArrearsSettingsInput.validate.schema
    },
    get errors() {
        return ChangeArrearsSettingsInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is ChangeArrearsSettingsInput => ChangeArrearsSettingsInput.validate(o) === true,
    parse: (o: unknown): { right: ChangeArrearsSettingsInput } | { left: DefinedError[] } => {
        if (ChangeArrearsSettingsInput.is(o)) {
            return { right: o }
        }
        return { left: (ChangeArrearsSettingsInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the request payload for performing change due dates settings action
 */
export interface ChangeDueDatesSettingsInput {
    /**
     * The date when to change the due dates settings - deprecated, use valueDate instead
     */
    entryDate?: string | undefined
    /**
     * The new fixed days of month to be used on the account
     */
    fixedDaysOfMonth: number[]
    /**
     * The notes for the change due dates settings action performed on the loan account
     */
    notes?: string | undefined
    /**
     * The date when to change the due dates settings
     */
    valueDate?: string | undefined
}

export const ChangeDueDatesSettingsInput = {
    validate: ChangeDueDatesSettingsInputValidator as ValidateFunction<ChangeDueDatesSettingsInput>,
    get schema() {
        return ChangeDueDatesSettingsInput.validate.schema
    },
    get errors() {
        return ChangeDueDatesSettingsInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is ChangeDueDatesSettingsInput => ChangeDueDatesSettingsInput.validate(o) === true,
    parse: (o: unknown): { right: ChangeDueDatesSettingsInput } | { left: DefinedError[] } => {
        if (ChangeDueDatesSettingsInput.is(o)) {
            return { right: o }
        }
        return { left: (ChangeDueDatesSettingsInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Change deposit account interest rate
 */
export interface ChangeInterestRateAction {
    /**
     * The new interest rate to set on the account.
     */
    interestRate: number
    /**
     * The notes or description attached to this object.
     */
    notes?: string | undefined
    /**
     * The date when the interest rate is changed.
     */
    valueDate: string
}

export const ChangeInterestRateAction = {
    validate: ChangeInterestRateActionValidator as ValidateFunction<ChangeInterestRateAction>,
    get schema() {
        return ChangeInterestRateAction.validate.schema
    },
    get errors() {
        return ChangeInterestRateAction.validate.errors ?? undefined
    },
    is: (o: unknown): o is ChangeInterestRateAction => ChangeInterestRateAction.validate(o) === true,
    parse: (o: unknown): { right: ChangeInterestRateAction } | { left: DefinedError[] } => {
        if (ChangeInterestRateAction.is(o)) {
            return { right: o }
        }
        return { left: (ChangeInterestRateAction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the request payload for performing an PMT Adjustment action
 */
export interface ChangeInterestRateLoanAccountInput {
    /**
     * The new interest rate to be available on the account
     */
    interestRate?: number | undefined
    /**
     * The new interest spread to be available on the account
     */
    interestSpread?: number | undefined
    /**
     * The notes for the change interest rate action performed on the loan account
     */
    notes?: string | undefined
    /**
     * The date when to change the interest rate (as Organization Time)
     */
    valueDate: string
}

export const ChangeInterestRateLoanAccountInput = {
    validate: ChangeInterestRateLoanAccountInputValidator as ValidateFunction<ChangeInterestRateLoanAccountInput>,
    get schema() {
        return ChangeInterestRateLoanAccountInput.validate.schema
    },
    get errors() {
        return ChangeInterestRateLoanAccountInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is ChangeInterestRateLoanAccountInput => ChangeInterestRateLoanAccountInput.validate(o) === true,
    parse: (o: unknown): { right: ChangeInterestRateLoanAccountInput } | { left: DefinedError[] } => {
        if (ChangeInterestRateLoanAccountInput.is(o)) {
            return { right: o }
        }
        return { left: (ChangeInterestRateLoanAccountInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the request payload for performing a periodic payment change action
 */
export interface ChangePeriodicPaymentLoanAccountInput {
    /**
     * The notes for the change periodic payment action performed on the loan account
     */
    notes?: string | undefined
    /**
     * The new periodic payment to be available on the account
     */
    periodicPayment: number
    /**
     * The date when to change the periodic payment (as Organization Time)
     */
    valueDate: string
}

export const ChangePeriodicPaymentLoanAccountInput = {
    validate: ChangePeriodicPaymentLoanAccountInputValidator as ValidateFunction<ChangePeriodicPaymentLoanAccountInput>,
    get schema() {
        return ChangePeriodicPaymentLoanAccountInput.validate.schema
    },
    get errors() {
        return ChangePeriodicPaymentLoanAccountInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is ChangePeriodicPaymentLoanAccountInput => ChangePeriodicPaymentLoanAccountInput.validate(o) === true,
    parse: (o: unknown): { right: ChangePeriodicPaymentLoanAccountInput } | { left: DefinedError[] } => {
        if (ChangePeriodicPaymentLoanAccountInput.is(o)) {
            return { right: o }
        }
        return { left: (ChangePeriodicPaymentLoanAccountInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the request payload for performing a repayment value change action
 */
export interface ChangeRepaymentValueLoanAccountInput {
    /**
     * Fixed amount for being used for the repayments principal due
     */
    amount?: number | undefined
    /**
     * Notes for the repayment value change action performed on the loan account
     */
    notes?: string | undefined
    /**
     * Percentage of principal amount used for the repayments principal due
     */
    percentage?: number | undefined
    /**
     * Date when to change the repayment value (as Organization Time)
     */
    valueDate: string
}

export const ChangeRepaymentValueLoanAccountInput = {
    validate: ChangeRepaymentValueLoanAccountInputValidator as ValidateFunction<ChangeRepaymentValueLoanAccountInput>,
    get schema() {
        return ChangeRepaymentValueLoanAccountInput.validate.schema
    },
    get errors() {
        return ChangeRepaymentValueLoanAccountInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is ChangeRepaymentValueLoanAccountInput => ChangeRepaymentValueLoanAccountInput.validate(o) === true,
    parse: (o: unknown): { right: ChangeRepaymentValueLoanAccountInput } | { left: DefinedError[] } => {
        if (ChangeRepaymentValueLoanAccountInput.is(o)) {
            return { right: o }
        }
        return { left: (ChangeRepaymentValueLoanAccountInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Change deposit account withholding tax rate
 */
export interface ChangeWithholdingTaxAction {
    /**
     * The ID or encoded key of the new withholding tax to use for the account.
     */
    withholdingTaxSourceKey: string
}

export const ChangeWithholdingTaxAction = {
    validate: ChangeWithholdingTaxActionValidator as ValidateFunction<ChangeWithholdingTaxAction>,
    get schema() {
        return ChangeWithholdingTaxAction.validate.schema
    },
    get errors() {
        return ChangeWithholdingTaxAction.validate.errors ?? undefined
    },
    is: (o: unknown): o is ChangeWithholdingTaxAction => ChangeWithholdingTaxAction.validate(o) === true,
    parse: (o: unknown): { right: ChangeWithholdingTaxAction } | { left: DefinedError[] } => {
        if (ChangeWithholdingTaxAction.is(o)) {
            return { right: o }
        }
        return { left: (ChangeWithholdingTaxAction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents a client.
 */
export interface Client {
    /**
     * The date when a client was set as active for the first time.
     */
    activationDate?: string | undefined
    /**
     * The addresses associated with this client.
     */
    addresses?: Address[] | undefined
    /**
     * The date when a client was approved.
     */
    approvedDate?: string | undefined
    /**
     * The encoded key of the branch a client is assigned to.
     */
    assignedBranchKey?: string | undefined
    /**
     * The encoded key of the centre a client is assigned to.
     */
    assignedCentreKey?: string | undefined
    /**
     * The encoded key of the user a client is assigned to.
     */
    assignedUserKey?: string | undefined
    /**
     * The client's date of birth.
     */
    birthDate?: string | undefined
    /**
     * A role which describes the intended use of a client in the system.
     */
    clientRoleKey?: string | undefined
    /**
     * The date when the client state was changed to closed.
     */
    closedDate?: string | undefined
    /**
     * The date a client was created.
     */
    creationDate?: string | undefined
    /**
     * The client's email address.
     */
    emailAddress?: string | undefined
    /**
     * The encoded key of the client, which is unique and generated.
     */
    encodedKey?: string | undefined
    /**
     * The first name, personal name, given name, or forename of the client.
     */
    firstName: string
    /**
     * The client's gender, the options are male or female.
     */
    gender?: 'MALE' | 'FEMALE' | undefined
    /**
     * The groups to which this client belongs.
     */
    groupKeys?: string[] | undefined
    /**
     * Number of paid and closed (with 'obligations met') accounts for a client's group; when the closing operation is reverted, this is reduced.
     */
    groupLoanCycle?: number | undefined
    /**
     * The client's home phone number.
     */
    homePhone?: string | undefined
    /**
     * The ID of the client, which can be generated and customized - but must be unique.
     */
    id?: string | undefined
    /**
     * The identification documents for this client.
     */
    idDocuments?: IdentificationDocument[] | undefined
    /**
     * The last date a client was modified.
     */
    lastModifiedDate?: string | undefined
    /**
     * The last name, surname, or family name of the client.
     */
    lastName: string
    /**
     * Number of paid and closed (with 'obligations met') accounts for a client; when the closing operation is reverted, this is reduced.
     */
    loanCycle?: number | undefined
    /**
     * The middle name of the client.
     */
    middleName?: string | undefined
    /**
     * The migration event encoded key associated with a client.
     */
    migrationEventKey?: string | undefined
    /**
     * The client's mobile phone number.
     */
    mobilePhone?: string | undefined
    /**
     * The client's second mobile phone number.
     */
    mobilePhone2?: string | undefined
    /**
     * The additional notes about a client.
     */
    notes?: string | undefined
    portalSettings?: PortalSettings | undefined
    /**
     * The client's preferred language. This will determine the language for the reports, schedules, and account statements you generate for the client.
     */
    preferredLanguage?:
        | 'ENGLISH'
        | 'PORTUGESE'
        | 'SPANISH'
        | 'RUSSIAN'
        | 'FRENCH'
        | 'GEORGIAN'
        | 'CHINESE'
        | 'INDONESIAN'
        | 'ROMANIAN'
        | 'BURMESE'
        | 'GERMAN'
        | 'PORTUGUESE_BRAZIL'
        | 'VIETNAMESE'
        | 'ITALIAN'
        | 'THAI'
        | 'NORWEGIAN'
        | 'PHRASE'
        | undefined
    /**
     * The encoded key of a client's profile picture.
     */
    profilePictureKey?: string | undefined
    /**
     * The encoded key of the client's profile signature.
     */
    profileSignatureKey?: string | undefined
    /**
     * The state of a client. It shows where the client is in the client life cycle.
     */
    state?: 'PENDING_APPROVAL' | 'INACTIVE' | 'ACTIVE' | 'EXITED' | 'BLACKLISTED' | 'REJECTED' | undefined
}

export const Client = {
    validate: ClientValidator as ValidateFunction<Client>,
    get schema() {
        return Client.validate.schema
    },
    get errors() {
        return Client.validate.errors ?? undefined
    },
    is: (o: unknown): o is Client => Client.validate(o) === true,
    parse: (o: unknown): { right: Client } | { left: DefinedError[] } => {
        if (Client.is(o)) {
            return { right: o }
        }
        return { left: (Client.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The unit that composes the list used for Clients searching
 */
export interface ClientFilterCriteria {
    field:
        | 'encodedKey'
        | 'creditOfficerKey'
        | 'clientRoleKey'
        | 'branchKey'
        | 'centreKey'
        | 'groupKey'
        | 'fullName'
        | 'firstName'
        | 'middleName'
        | 'lastName'
        | 'creationDate'
        | 'lastModifiedDate'
        | 'id'
        | 'depositsBalance'
        | 'loansBalance'
        | 'pendingLoanAmount'
        | 'approvedLoanAmount'
        | 'totalBalance'
        | 'totalDue'
        | 'homePhoneNumber'
        | 'mobilePhoneNumber'
        | 'mobilePhoneNumber2'
        | 'emailAddress'
        | 'clientAddress'
        | 'birthdate'
        | 'gender'
        | 'loanCycle'
        | 'groupLoanCycle'
        | 'clientState'
        | 'portalState'
        | 'preferredLanguage'
        | 'groupId'
        | string
    /**
     * | **Operator**                | **Affected values**  | **Available for**                                                    |
     * |---------------               |----------------------|----------------------------------------------------------------------|
     * | EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |
     * | EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |
     * | MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |
     * | ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | STARTS_WITH                  | ONE_VALUE            | STRING                                                               |
     * | STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |
     * | IN                           | LIST                 | ENUM,KEY                                                             |
     * | TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |
     * | EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     * | NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     */
    operator:
        | 'EQUALS'
        | 'EQUALS_CASE_SENSITIVE'
        | 'DIFFERENT_THAN'
        | 'MORE_THAN'
        | 'LESS_THAN'
        | 'BETWEEN'
        | 'ON'
        | 'AFTER'
        | 'AFTER_INCLUSIVE'
        | 'BEFORE'
        | 'BEFORE_INCLUSIVE'
        | 'STARTS_WITH'
        | 'STARTS_WITH_CASE_SENSITIVE'
        | 'IN'
        | 'TODAY'
        | 'THIS_WEEK'
        | 'THIS_MONTH'
        | 'THIS_YEAR'
        | 'LAST_DAYS'
        | 'EMPTY'
        | 'NOT_EMPTY'
    /**
     * The second value to match the searching criteria, when the `BETWEEN` operator is used.
     */
    secondValue?: string | undefined
    /**
     * The value to match the searching criteria.
     */
    value?: string | undefined
    /**
     * List of values when the `IN` operator is used.
     */
    values?: string[] | undefined
}

/**
 * Represents a client or group role.
 */
export interface ClientRole {
    /**
     * `TRUE` if clients with this client role can be used as guarantors, `FALSE` otherwise.
     */
    canGuarantee?: boolean | undefined
    /**
     * `TRUE` if new accounts for this client type can be created, `FALSE` otherwise.
     */
    canOpenAccounts?: boolean | undefined
    /**
     * The type of the client for which this role was created.
     */
    clientType?: 'CLIENT' | 'GROUP' | undefined
    /**
     * The creation date of the client role.
     */
    creationDate?: string | undefined
    /**
     * The text description for this client role.
     */
    description?: string | undefined
    /**
     * The encoded key of the client, which is unique and generated.
     */
    encodedKey?: string | undefined
    /**
     * The ID of the client role, which can be generated and customized - but must be unique.
     */
    id?: string | undefined
    /**
     * The pattern used in generating the client ID.
     */
    idPattern?: string | undefined
    /**
     * The name of the client role.
     */
    name?: string | undefined
    /**
     * `TRUE` if identification documents must be provided for the client to be created, `FALSE` otherwise. Does not apply for groups.
     */
    requireID?: boolean | undefined
    /**
     * `TRUE` if the Mambu default address section is available, `FALSE` otherwise.
     */
    useDefaultAddress?: boolean | undefined
}

export const ClientRole = {
    validate: ClientRoleValidator as ValidateFunction<ClientRole>,
    get schema() {
        return ClientRole.validate.schema
    },
    get errors() {
        return ClientRole.validate.errors ?? undefined
    },
    is: (o: unknown): o is ClientRole => ClientRole.validate(o) === true,
    parse: (o: unknown): { right: ClientRole } | { left: DefinedError[] } => {
        if (ClientRole.is(o)) {
            return { right: o }
        }
        return { left: (ClientRole.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Wrapper that holds a list of filtering criteria and a sorting criteria for clients
 */
export interface ClientSearchCriteria {
    /**
     * The list of filtering criteria
     */
    filterCriteria: ClientFilterCriteria[]
    sortingCriteria?: ClientSortingCriteria | undefined
}

export const ClientSearchCriteria = {
    validate: ClientSearchCriteriaValidator as ValidateFunction<ClientSearchCriteria>,
    get schema() {
        return ClientSearchCriteria.validate.schema
    },
    get errors() {
        return ClientSearchCriteria.validate.errors ?? undefined
    },
    is: (o: unknown): o is ClientSearchCriteria => ClientSearchCriteria.validate(o) === true,
    parse: (o: unknown): { right: ClientSearchCriteria } | { left: DefinedError[] } => {
        if (ClientSearchCriteria.is(o)) {
            return { right: o }
        }
        return { left: (ClientSearchCriteria.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The sorting criteria used for Clients
 */
export interface ClientSortingCriteria {
    /**
     * The field to sort by. It can be native (one from the provided list) or otherwise can specify a custom field definition using the format [customFieldSetId].[customFieldId].
     */
    field:
        | 'encodedKey'
        | 'id'
        | 'fullName'
        | 'firstName'
        | 'middleName'
        | 'lastName'
        | 'creationDate'
        | 'lastModifiedDate'
        | 'depositsBalance'
        | 'loansBalance'
        | 'pendingLoanAmount'
        | 'approvedLoanAmount'
        | 'totalBalance'
        | 'totalDue'
        | 'homePhoneNumber'
        | 'mobilePhoneNumber'
        | 'mobilePhoneNumber2'
        | 'emailAddress'
        | 'birthdate'
        | 'loanCycle'
        | 'groupLoanCycle'
        | 'portalState'
    /**
     * The sorting order: `ASC` or `DESC`. The default order is `DESC`.
     */
    order?: 'ASC' | 'DESC' | undefined
}

/**
 * Represents the input for the collateral assets reevaluation background task.
 */
export interface CollateralAssetFilter {
    /**
     * Assets of the loan accounts that will be filtered by the branch keys in the background process
     */
    branchKeys?: string[] | undefined
    /**
     * Assets of the loan accounts that will be filtered by the currency codes in the background process
     */
    currencies?: string[] | undefined
    /**
     * Assets of the loan accounts that will be filtered by the product keys in the background process
     */
    productKeys?: string[] | undefined
}

export const CollateralAssetFilter = {
    validate: CollateralAssetFilterValidator as ValidateFunction<CollateralAssetFilter>,
    get schema() {
        return CollateralAssetFilter.validate.schema
    },
    get errors() {
        return CollateralAssetFilter.validate.errors ?? undefined
    },
    is: (o: unknown): o is CollateralAssetFilter => CollateralAssetFilter.validate(o) === true,
    parse: (o: unknown): { right: CollateralAssetFilter } | { left: DefinedError[] } => {
        if (CollateralAssetFilter.is(o)) {
            return { right: o }
        }
        return { left: (CollateralAssetFilter.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Holds the information about collateral assets reevaluation status.
 */
export interface CollateralAssetsReevaluationResponse {
    /**
     * The encoded key of the collateral assets reevaluation task
     */
    bulkProcessKey?: string | undefined
    /**
     * The collateral assets reevaluation status
     */
    status?:
        | 'QUEUED'
        | 'IN_PROGRESS'
        | 'COMPLETE'
        | 'NOT_FOUND'
        | 'CANCEL'
        | 'TO_BE_CANCELED'
        | 'TIMED_OUT'
        | 'ERROR'
        | 'TRANSIENT_ERROR'
        | 'OVERRIDDEN'
        | 'RECOVERABLE_ERROR'
        | undefined
}

export const CollateralAssetsReevaluationResponse = {
    validate: CollateralAssetsReevaluationResponseValidator as ValidateFunction<CollateralAssetsReevaluationResponse>,
    get schema() {
        return CollateralAssetsReevaluationResponse.validate.schema
    },
    get errors() {
        return CollateralAssetsReevaluationResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is CollateralAssetsReevaluationResponse => CollateralAssetsReevaluationResponse.validate(o) === true,
    parse: (o: unknown): { right: CollateralAssetsReevaluationResponse } | { left: DefinedError[] } => {
        if (CollateralAssetsReevaluationResponse.is(o)) {
            return { right: o }
        }
        return { left: (CollateralAssetsReevaluationResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents information about the comment data transfer object.
 */
export interface Comment {
    /**
     * The creation date of the comment.
     */
    creationDate?: string | undefined
    /**
     * The comments's encoded key, which is auto-generated and unique.
     */
    encodedKey?: string | undefined
    /**
     * The last date when this comment was modified.
     */
    lastModifiedDate?: string | undefined
    /**
     * The encoded key of the entity that owns this comment.
     */
    ownerKey?: string | undefined
    /**
     * The type of the entity that owns this comment.
     */
    ownerType?:
        | 'CLIENT'
        | 'GROUP'
        | 'LOAN_PRODUCT'
        | 'SAVINGS_PRODUCT'
        | 'CENTRE'
        | 'BRANCH'
        | 'USER'
        | 'LOAN_ACCOUNT'
        | 'DEPOSIT_ACCOUNT'
        | 'ID_DOCUMENT'
        | 'LINE_OF_CREDIT'
        | 'GL_JOURNAL_ENTRY'
        | undefined
    /**
     * The message in the comment.
     */
    text?: string | undefined
    /**
     * The user's key.
     */
    userKey?: string | undefined
}

export const Comment = {
    validate: CommentValidator as ValidateFunction<Comment>,
    get schema() {
        return Comment.validate.schema
    },
    get errors() {
        return Comment.validate.errors ?? undefined
    },
    is: (o: unknown): o is Comment => Comment.validate(o) === true,
    parse: (o: unknown): { right: Comment } | { left: DefinedError[] } => {
        if (Comment.is(o)) {
            return { right: o }
        }
        return { left: (Comment.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents a communication message.
 */
export interface CommunicationMessage {
    /**
     * The contents of the message.
     */
    body?: string | undefined
    /**
     * The client the message was sent to.
     */
    clientKey?: string | undefined
    /**
     * The date the communication message was created in UTC.
     */
    creationDate?: string | undefined
    /**
     * The deposit account that triggered this message.
     */
    depositAccountKey?: string | undefined
    /**
     * The destination (phone number or email address) this message was sent to.
     */
    destination?: string | undefined
    /**
     * The encoded key of the communication message, which is generated automatically, and must be unique.
     */
    encodedKey?: string | undefined
    /**
     * The event that triggered this message.
     */
    event?:
        | 'MANUAL'
        | 'DO_NOTHING'
        | 'CLIENT_CREATED'
        | 'CLIENT_APPROVED'
        | 'GROUP_ACTIVITY'
        | 'GROUP_CREATED'
        | 'LOAN_CREATED'
        | 'INTEREST_RATE_CHANGED'
        | 'CLIENT_REJECTED'
        | 'CLIENT_ACTIVITY'
        | 'LOAN_REPAYMENT'
        | 'LOAN_REPAYMENT_REVERSAL'
        | 'FEE_APPLIED'
        | 'FEE_ADJUSTED'
        | 'FEE_CHARGED'
        | 'PENALTY_APPLIED'
        | 'PENALTY_ADJUSTMENT'
        | 'FEES_DUE_REDUCED'
        | 'FEE_REDUCTION_ADJUSTMENT'
        | 'LOAN_APPROVAL'
        | 'LOAN_ACCOUNT_CLOSURE'
        | 'LOAN_ACCOUNT_WRITE_OFF'
        | 'LOAN_ACCOUNT_REJECTION'
        | 'LOAN_ACCOUNT_RESCHEDULED'
        | 'LOAN_ACCOUNT_REFINANCED'
        | 'REPAYMENT_REMINDER'
        | 'ACCOUNT_IN_ARREARS'
        | 'LOAN_DISBURSEMENT'
        | 'LOAN_DISBURSEMENT_REVERSAL'
        | 'LOAN_ACCOUNT_ACTIVITY'
        | 'LOAN_ANTICIPATED_DISBURSEMENT'
        | 'SAVINGS_CREATED'
        | 'SAVINGS_DEPOSIT'
        | 'SAVINGS_DEPOSIT_REVERSAL'
        | 'REAPPLIED_SAVINGS_DEPOSIT'
        | 'SAVINGS_APPROVAL'
        | 'SAVINGS_ACCOUNT_ACTIVATED'
        | 'SAVINGS_ACCOUNT_CLOSURE'
        | 'SAVINGS_ACCOUNT_REJECTION'
        | 'SAVINGS_WITHDRAWAL'
        | 'SAVINGS_WITHDRAWAL_REVERSAL'
        | 'REAPPLIED_SAVINGS_WITHDRAWAL'
        | 'SAVINGS_ACCOUNT_ACTIVITY'
        | 'DEPOSIT_INTEREST_APPLIED'
        | 'DEPOSIT_INTEREST_APPLIED_ADJUSTMENT'
        | 'ACCOUNT_AUTHORISATION_HOLD_CREATED'
        | 'ACCOUNT_AUTHORISATION_HOLD_REVERSED'
        | 'ACCOUNT_AUTHORISATION_HOLD_SETTLED'
        | 'CARDS_AUTHORISATION_HOLD_CREATED'
        | 'CARDS_AUTHORISATION_HOLD_SETTLED'
        | 'CARDS_AUTHORISATION_HOLD_AMOUNT_DECREASED'
        | 'CARDS_AUTHORISATION_HOLD_AMOUNT_INCREASED'
        | 'CARDS_AUTHORISATION_HOLD_EXPIRED'
        | 'CARDS_AUTHORISATION_HOLD_REVERSED'
        | 'PORTAL_ACTIVATED'
        | 'PORTAL_PASSWORD_RESET'
        | 'END_OF_DAY_PROCESSING_COMPLETED'
        | 'DATA_ACCESS_STATE_CHANGED'
        | 'CREDIT_ARRANGEMENT_CREATED'
        | 'CREDIT_ARRANGEMENT_CLOSED'
        | 'CREDIT_ARRANGEMENT_APPROVED'
        | 'CREDIT_ARRANGEMENT_REJECTED'
        | 'CREDIT_ARRANGEMENT_WITHDRAWN'
        | 'CREDIT_ARRANGEMENT_DELETED'
        | 'CREDIT_ARRANGEMENT_ACCOUNT_ADDED'
        | 'CREDIT_ARRANGEMENT_ACCOUNT_REMOVED'
        | 'CREDIT_ARRANGEMENT_EDITED'
        | 'PAYMENT_ORDER_ACTIVITY'
        | 'COLLECTION_ORDER_ACTIVITY'
        | 'JOURNAL_ENTRY_ADDED'
        | 'JOURNAL_ENTRY_ADJUSTED'
        | 'SAVINGS_TRANSACTION_EDITED'
        | 'CARD_WITHDRAWAL_REVERSAL'
        | 'CARD_DEPOSIT_REVERSAL'
        | undefined
    /**
     * The failure code if the message failed to send.
     */
    failureCause?: string | undefined
    /**
     * The reason for the communication message failure.
     */
    failureReason?:
        | 'MESSAGING_EXCEPTION'
        | 'INVALID_SMTP_CREDENTIALS'
        | 'UNSUPPORTED_ENCODING_EXCEPTION'
        | 'EMAIL_SERVICE_NOT_ENABLED'
        | 'SMS_TOO_LONG'
        | 'SMS_SERVICE_NOT_ENABLED'
        | 'SMS_NOT_SENT'
        | 'SMS_SERVICE_ERROR'
        | 'SMS_CONNECTION_EXCEPTION'
        | 'WEBHOOK_NOTIFICATIONS_DISABLED'
        | 'INVALID_HTTP_RESPONSE'
        | 'HTTP_ERROR_WHILE_SENDING'
        | 'INVALID_JSON_BODY_SYNTAX'
        | 'MISSING_TEMPLATE_KEY'
        | 'MAX_MESSAGE_SIZE_LIMIT_EXCEEDED'
        | 'UNDEFINED_DESTINATION'
        | 'INVALID_HTTP_PROTOCOL'
        | 'BLACKLISTED_URL'
        | 'INVALID_SMS_GATEWAY_CREDENTIALS'
        | 'MISSING_SMS_RECIPIENT'
        | 'SMS_GATEWAY_ERROR'
        | 'MISSING_EMAIL_RECIPIENT_ADDRESS'
        | 'OTHER'
        | undefined
    /**
     * The group the message was sent to.
     */
    groupKey?: string | undefined
    /**
     * The loan account that triggered this message.
     */
    loanAccountKey?: string | undefined
    /**
     * The number of retries to send the message.
     */
    numRetries?: number | undefined
    /**
     * The reference ID of the communication message, generated by the SMS dispatcher.
     */
    referenceId?: string | undefined
    /**
     * The repayment that triggered this message.
     */
    repaymentKey?: string | undefined
    /**
     * The date the communication message was sent in UTC.
     */
    sendDate?: string | undefined
    /**
     * The encoded key of the sender. If specified, it should be the encoded key of the current user.
     */
    senderKey?: string | undefined
    /**
     * The state of the message.
     */
    state?: 'SENT' | 'QUEUED' | 'QUEUED_FOR_STREAM' | 'WAITING' | 'SENDING_ASYNC' | 'FAILED' | undefined
    /**
     * The subject of the message.
     */
    subject?: string | undefined
    /**
     * The communication message template key.
     */
    templateKey?: string | undefined
    /**
     * The type of communication message.
     */
    type?: 'EMAIL' | 'SMS' | 'WEB_HOOK' | 'EVENT_STREAM' | 'TASK' | undefined
    /**
     * The user the message was sent to.
     */
    userKey?: string | undefined
}

export const CommunicationMessage = {
    validate: CommunicationMessageValidator as ValidateFunction<CommunicationMessage>,
    get schema() {
        return CommunicationMessage.validate.schema
    },
    get errors() {
        return CommunicationMessage.validate.errors ?? undefined
    },
    is: (o: unknown): o is CommunicationMessage => CommunicationMessage.validate(o) === true,
    parse: (o: unknown): { right: CommunicationMessage } | { left: DefinedError[] } => {
        if (CommunicationMessage.is(o)) {
            return { right: o }
        }
        return { left: (CommunicationMessage.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents a list of failed communication messages to resend.
 */
export interface CommunicationMessageAction {
    /**
     * The list of failed communication messages to resend.
     */
    messages: string[]
}

export const CommunicationMessageAction = {
    validate: CommunicationMessageActionValidator as ValidateFunction<CommunicationMessageAction>,
    get schema() {
        return CommunicationMessageAction.validate.schema
    },
    get errors() {
        return CommunicationMessageAction.validate.errors ?? undefined
    },
    is: (o: unknown): o is CommunicationMessageAction => CommunicationMessageAction.validate(o) === true,
    parse: (o: unknown): { right: CommunicationMessageAction } | { left: DefinedError[] } => {
        if (CommunicationMessageAction.is(o)) {
            return { right: o }
        }
        return { left: (CommunicationMessageAction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the time interval to resend messages.
 */
export interface CommunicationMessageEnqueueAction {
    /**
     * The upper limit until which created messages will be enqueued.
     */
    endDate: string
    /**
     * The lower limit from which created messages will be enqueued.
     */
    startDate: string
    /**
     * The list of template message types to enqueue.
     */
    templateTypes?: TemplateTypes[] | undefined
}

export const CommunicationMessageEnqueueAction = {
    validate: CommunicationMessageEnqueueActionValidator as ValidateFunction<CommunicationMessageEnqueueAction>,
    get schema() {
        return CommunicationMessageEnqueueAction.validate.schema
    },
    get errors() {
        return CommunicationMessageEnqueueAction.validate.errors ?? undefined
    },
    is: (o: unknown): o is CommunicationMessageEnqueueAction => CommunicationMessageEnqueueAction.validate(o) === true,
    parse: (o: unknown): { right: CommunicationMessageEnqueueAction } | { left: DefinedError[] } => {
        if (CommunicationMessageEnqueueAction.is(o)) {
            return { right: o }
        }
        return { left: (CommunicationMessageEnqueueAction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The unit that composes the list used for communication messages client directed searching
 */
export interface CommunicationMessageFilterCriteria {
    field:
        | 'encodedKey'
        | 'creationDate'
        | 'sendDate'
        | 'senderKey'
        | 'clientKey'
        | 'groupKey'
        | 'userKey'
        | 'state'
        | 'failureReason'
        | 'failureCause'
        | 'destination'
        | 'type'
        | 'event'
        | string
    /**
     * | **Operator**                | **Affected values**  | **Available for**                                                    |
     * |---------------               |----------------------|----------------------------------------------------------------------|
     * | EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |
     * | EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |
     * | MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |
     * | ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | STARTS_WITH                  | ONE_VALUE            | STRING                                                               |
     * | STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |
     * | IN                           | LIST                 | ENUM,KEY                                                             |
     * | TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |
     * | EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     * | NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     */
    operator:
        | 'EQUALS'
        | 'EQUALS_CASE_SENSITIVE'
        | 'DIFFERENT_THAN'
        | 'MORE_THAN'
        | 'LESS_THAN'
        | 'BETWEEN'
        | 'ON'
        | 'AFTER'
        | 'AFTER_INCLUSIVE'
        | 'BEFORE'
        | 'BEFORE_INCLUSIVE'
        | 'STARTS_WITH'
        | 'STARTS_WITH_CASE_SENSITIVE'
        | 'IN'
        | 'TODAY'
        | 'THIS_WEEK'
        | 'THIS_MONTH'
        | 'THIS_YEAR'
        | 'LAST_DAYS'
        | 'EMPTY'
        | 'NOT_EMPTY'
    /**
     * The second value to match the searching criteria, when the `BETWEEN` operator is used.
     */
    secondValue?: string | undefined
    /**
     * The value to match the searching criteria.
     */
    value?: string | undefined
    /**
     * List of values when the `IN` operator is used.
     */
    values?: string[] | undefined
}

/**
 * The sorting criteria used for Messages search.
 */
export interface CommunicationMessageSearchSortingCriteria {
    /**
     * Sort Messages By
     */
    field: 'encodedKey' | 'creationDate' | 'sendDate' | 'senderKey' | 'clientKey' | 'groupKey' | 'userKey' | 'type'
    /**
     * The sorting order: `ASC` or `DESC`. The default order is `DESC`.
     */
    order?: 'ASC' | 'DESC' | undefined
}

/**
 * The unit that composes the body used used for communication messages client directed searching.
 */
export interface CommunicationMessagesSearchSortCriteria {
    /**
     * The list of filtering criteria.
     */
    filterCriteria: CommunicationMessageFilterCriteria[]
    sortingCriteria: CommunicationMessageSearchSortingCriteria
}

export const CommunicationMessagesSearchSortCriteria = {
    validate: CommunicationMessagesSearchSortCriteriaValidator as ValidateFunction<CommunicationMessagesSearchSortCriteria>,
    get schema() {
        return CommunicationMessagesSearchSortCriteria.validate.schema
    },
    get errors() {
        return CommunicationMessagesSearchSortCriteria.validate.errors ?? undefined
    },
    is: (o: unknown): o is CommunicationMessagesSearchSortCriteria =>
        CommunicationMessagesSearchSortCriteria.validate(o) === true,
    parse: (o: unknown): { right: CommunicationMessagesSearchSortCriteria } | { left: DefinedError[] } => {
        if (CommunicationMessagesSearchSortCriteria.is(o)) {
            return { right: o }
        }
        return { left: (CommunicationMessagesSearchSortCriteria.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The constraints applied to the transaction channel
 */
export interface Constraint {
    /**
     * Holds the custom constraints, only for the limited usage case. For the unconstrainedcase, no constraints are applied
     */
    constraints?: TransactionChannelConstraint[] | undefined
    /**
     * Holds the match filter option for the constraints. It can be ALL so all the constraints must match, or ANY so at least one must match
     */
    matchFiltersOption?: 'ALL' | 'ANY' | undefined
    /**
     * States the limited/unconstrained usage of the transaction channel
     */
    usage?: 'UNCONSTRAINED' | 'LIMITED' | undefined
}

export type Create10Response = GLJournalEntry[]

export const Create10Response = {
    validate: Create10ResponseValidator as ValidateFunction<Create10Response>,
    get schema() {
        return Create10Response.validate.schema
    },
    get errors() {
        return Create10Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is Create10Response => Create10Response.validate(o) === true,
    parse: (o: unknown): { right: Create10Response } | { left: DefinedError[] } => {
        if (Create10Response.is(o)) {
            return { right: o }
        }
        return { left: (Create10Response.errors ?? []) as DefinedError[] }
    },
} as const

export type Create19Request = Holiday[]

export const Create19Request = {
    validate: Create19RequestValidator as ValidateFunction<Create19Request>,
    get schema() {
        return Create19Request.validate.schema
    },
    get errors() {
        return Create19Request.validate.errors ?? undefined
    },
    is: (o: unknown): o is Create19Request => Create19Request.validate(o) === true,
    parse: (o: unknown): { right: Create19Request } | { left: DefinedError[] } => {
        if (Create19Request.is(o)) {
            return { right: o }
        }
        return { left: (Create19Request.errors ?? []) as DefinedError[] }
    },
} as const

export type Create19Response = Holiday[]

export const Create19Response = {
    validate: Create19ResponseValidator as ValidateFunction<Create19Response>,
    get schema() {
        return Create19Response.validate.schema
    },
    get errors() {
        return Create19Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is Create19Response => Create19Response.validate(o) === true,
    parse: (o: unknown): { right: Create19Response } | { left: DefinedError[] } => {
        if (Create19Response.is(o)) {
            return { right: o }
        }
        return { left: (Create19Response.errors ?? []) as DefinedError[] }
    },
} as const

export type Create9Request = GLAccountInput[]

export const Create9Request = {
    validate: Create9RequestValidator as ValidateFunction<Create9Request>,
    get schema() {
        return Create9Request.validate.schema
    },
    get errors() {
        return Create9Request.validate.errors ?? undefined
    },
    is: (o: unknown): o is Create9Request => Create9Request.validate(o) === true,
    parse: (o: unknown): { right: Create9Request } | { left: DefinedError[] } => {
        if (Create9Request.is(o)) {
            return { right: o }
        }
        return { left: (Create9Request.errors ?? []) as DefinedError[] }
    },
} as const

export type Create9Response = GLAccount[]

export const Create9Response = {
    validate: Create9ResponseValidator as ValidateFunction<Create9Response>,
    get schema() {
        return Create9Response.validate.schema
    },
    get errors() {
        return Create9Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is Create9Response => Create9Response.validate(o) === true,
    parse: (o: unknown): { right: Create9Response } | { left: DefinedError[] } => {
        if (Create9Response.is(o)) {
            return { right: o }
        }
        return { left: (Create9Response.errors ?? []) as DefinedError[] }
    },
} as const

export interface CreateDocument1Request {
    /**
     * The file to be attached for an entity.
     */
    file: string
    /**
     * The ID or encoded key of the entity that owns the document. The ID or encoded key must belong to the entity indicated by the `entity` parameter. Possible entity types are :`CLIENT`, `GROUP`, `LOAN_PRODUCT`, `SAVINGS_PRODUCT`, `CENTRE`, `BRANCH`, `USER`, `LOAN_ACCOUNT`, `DEPOSIT_ACCOUNT`, `ID_DOCUMENT`, `LINE_OF_CREDIT`, `GL_JOURNAL_ENTRY`. If the entity is `GL_JOURNAL_ENTRY`, the value can also represent the Journal Entry Transaction ID.
     */
    id?: string | undefined
    /**
     * The name (title) of the attached file.
     */
    name?: string | undefined
    /**
     * The description of the attached file.
     */
    notes?: string | undefined
    /**
     * The type of the owner of the document.
     */
    ownerType?:
        | 'CLIENT'
        | 'GROUP'
        | 'LOAN_PRODUCT'
        | 'SAVINGS_PRODUCT'
        | 'CENTRE'
        | 'BRANCH'
        | 'USER'
        | 'LOAN_ACCOUNT'
        | 'DEPOSIT_ACCOUNT'
        | 'ID_DOCUMENT'
        | 'LINE_OF_CREDIT'
        | 'GL_JOURNAL_ENTRY'
        | undefined
}

export const CreateDocument1Request = {
    validate: CreateDocument1RequestValidator as ValidateFunction<CreateDocument1Request>,
    get schema() {
        return CreateDocument1Request.validate.schema
    },
    get errors() {
        return CreateDocument1Request.validate.errors ?? undefined
    },
    is: (o: unknown): o is CreateDocument1Request => CreateDocument1Request.validate(o) === true,
    parse: (o: unknown): { right: CreateDocument1Request } | { left: DefinedError[] } => {
        if (CreateDocument1Request.is(o)) {
            return { right: o }
        }
        return { left: (CreateDocument1Request.errors ?? []) as DefinedError[] }
    },
} as const

export interface CreateDocumentRequest {
    /**
     * The file to be attached for a client.
     */
    file: string
    /**
     * The name (title) of the attached file.
     */
    name?: string | undefined
    /**
     * The description of the attached file.
     */
    notes?: string | undefined
}

export const CreateDocumentRequest = {
    validate: CreateDocumentRequestValidator as ValidateFunction<CreateDocumentRequest>,
    get schema() {
        return CreateDocumentRequest.validate.schema
    },
    get errors() {
        return CreateDocumentRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is CreateDocumentRequest => CreateDocumentRequest.validate(o) === true,
    parse: (o: unknown): { right: CreateDocumentRequest } | { left: DefinedError[] } => {
        if (CreateDocumentRequest.is(o)) {
            return { right: o }
        }
        return { left: (CreateDocumentRequest.errors ?? []) as DefinedError[] }
    },
} as const

export type CreateLoanAccountFundingSourcesRequest = InvestorFund[]

export const CreateLoanAccountFundingSourcesRequest = {
    validate: CreateLoanAccountFundingSourcesRequestValidator as ValidateFunction<CreateLoanAccountFundingSourcesRequest>,
    get schema() {
        return CreateLoanAccountFundingSourcesRequest.validate.schema
    },
    get errors() {
        return CreateLoanAccountFundingSourcesRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is CreateLoanAccountFundingSourcesRequest => CreateLoanAccountFundingSourcesRequest.validate(o) === true,
    parse: (o: unknown): { right: CreateLoanAccountFundingSourcesRequest } | { left: DefinedError[] } => {
        if (CreateLoanAccountFundingSourcesRequest.is(o)) {
            return { right: o }
        }
        return { left: (CreateLoanAccountFundingSourcesRequest.errors ?? []) as DefinedError[] }
    },
} as const

export type CreateLoanAccountFundingSourcesResponse = InvestorFund[]

export const CreateLoanAccountFundingSourcesResponse = {
    validate: CreateLoanAccountFundingSourcesResponseValidator as ValidateFunction<CreateLoanAccountFundingSourcesResponse>,
    get schema() {
        return CreateLoanAccountFundingSourcesResponse.validate.schema
    },
    get errors() {
        return CreateLoanAccountFundingSourcesResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is CreateLoanAccountFundingSourcesResponse =>
        CreateLoanAccountFundingSourcesResponse.validate(o) === true,
    parse: (o: unknown): { right: CreateLoanAccountFundingSourcesResponse } | { left: DefinedError[] } => {
        if (CreateLoanAccountFundingSourcesResponse.is(o)) {
            return { right: o }
        }
        return { left: (CreateLoanAccountFundingSourcesResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type CreatePlannedFeesRequest = PlannedInstallmentFee[]

export const CreatePlannedFeesRequest = {
    validate: CreatePlannedFeesRequestValidator as ValidateFunction<CreatePlannedFeesRequest>,
    get schema() {
        return CreatePlannedFeesRequest.validate.schema
    },
    get errors() {
        return CreatePlannedFeesRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is CreatePlannedFeesRequest => CreatePlannedFeesRequest.validate(o) === true,
    parse: (o: unknown): { right: CreatePlannedFeesRequest } | { left: DefinedError[] } => {
        if (CreatePlannedFeesRequest.is(o)) {
            return { right: o }
        }
        return { left: (CreatePlannedFeesRequest.errors ?? []) as DefinedError[] }
    },
} as const

export type CreatePlannedFeesResponse = PlannedInstallmentFee[]

export const CreatePlannedFeesResponse = {
    validate: CreatePlannedFeesResponseValidator as ValidateFunction<CreatePlannedFeesResponse>,
    get schema() {
        return CreatePlannedFeesResponse.validate.schema
    },
    get errors() {
        return CreatePlannedFeesResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is CreatePlannedFeesResponse => CreatePlannedFeesResponse.validate(o) === true,
    parse: (o: unknown): { right: CreatePlannedFeesResponse } | { left: DefinedError[] } => {
        if (CreatePlannedFeesResponse.is(o)) {
            return { right: o }
        }
        return { left: (CreatePlannedFeesResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents a credit arrangement.
 */
export interface CreditArrangement {
    /**
     * The maximum credit amount the client can be exposed to.
     */
    amount: number
    /**
     * The date when the credit arrangement was approved.
     */
    approvedDate?: string | undefined
    /**
     * The available amount of the credit arrangement.
     */
    availableCreditAmount?: number | undefined
    /**
     * The date when the credit arrangement was closed.
     */
    closedDate?: string | undefined
    /**
     * The consumed amount of the credit arrangement, which is calculated as the difference between the amount and available amount.
     */
    consumedCreditAmount?: number | undefined
    /**
     * The date when the credit arrangement was created.
     */
    creationDate?: string | undefined
    currency?: Currency | undefined
    /**
     * The encoded key of the credit arrangement, it is auto generated, and unique.
     */
    encodedKey?: string | undefined
    /**
     * The date when the credit arrangement expires.
     */
    expireDate: string
    /**
     * The type of exposure limit calculation method used for the credit arrangement.
     */
    exposureLimitType?: 'APPROVED_AMOUNT' | 'OUTSTANDING_AMOUNT' | undefined
    /**
     * The encoded key of the credit arrangement holder (individual client or group).
     */
    holderKey?: string | undefined
    /**
     * The type of the credit arrangement holder (individual client or group).
     */
    holderType: 'CLIENT' | 'GROUP'
    /**
     * The ID of credit arrangement, can be generated and customized, and must be unique.
     */
    id?: string | undefined
    /**
     * The last date when the credit arrangement was modified.
     */
    lastModifiedDate?: string | undefined
    /**
     * The notes or description of the credit arrangement.
     */
    notes?: string | undefined
    /**
     * The start date from which the credit arrangement became active.
     */
    startDate: string
    /**
     * The state of the credit arrangement.
     */
    state?: 'PENDING_APPROVAL' | 'APPROVED' | 'ACTIVE' | 'CLOSED' | 'WITHDRAWN' | 'REJECTED' | undefined
    /**
     * The substate of credit arrangement.
     */
    subState?: 'PENDING_APPROVAL' | 'APPROVED' | 'ACTIVE' | 'CLOSED' | 'WITHDRAWN' | 'REJECTED' | undefined
}

export const CreditArrangement = {
    validate: CreditArrangementValidator as ValidateFunction<CreditArrangement>,
    get schema() {
        return CreditArrangement.validate.schema
    },
    get errors() {
        return CreditArrangement.validate.errors ?? undefined
    },
    is: (o: unknown): o is CreditArrangement => CreditArrangement.validate(o) === true,
    parse: (o: unknown): { right: CreditArrangement } | { left: DefinedError[] } => {
        if (CreditArrangement.is(o)) {
            return { right: o }
        }
        return { left: (CreditArrangement.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents loan and deposit accounts linked to a credit arrangement.
 */
export interface CreditArrangementAccounts {
    /**
     * List of the deposit accounts linked to the credit arrangement.
     */
    depositAccounts?: DepositAccount[] | undefined
    /**
     * List of loan accounts linked to the credit arrangement.
     */
    loanAccounts?: LoanAccount[] | undefined
}

export const CreditArrangementAccounts = {
    validate: CreditArrangementAccountsValidator as ValidateFunction<CreditArrangementAccounts>,
    get schema() {
        return CreditArrangementAccounts.validate.schema
    },
    get errors() {
        return CreditArrangementAccounts.validate.errors ?? undefined
    },
    is: (o: unknown): o is CreditArrangementAccounts => CreditArrangementAccounts.validate(o) === true,
    parse: (o: unknown): { right: CreditArrangementAccounts } | { left: DefinedError[] } => {
        if (CreditArrangementAccounts.is(o)) {
            return { right: o }
        }
        return { left: (CreditArrangementAccounts.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The state change to perform on the credit arrangement.
 */
export interface CreditArrangementAction {
    /**
     * The action type to be applied.
     */
    action: 'APPROVE' | 'UNDO_APPROVE' | 'REJECT' | 'UNDO_REJECT' | 'WITHDRAW' | 'UNDO_WITHDRAW' | 'CLOSE' | 'UNDO_CLOSE'
    /**
     * The notes related to the action performed.
     */
    notes?: string | undefined
}

export const CreditArrangementAction = {
    validate: CreditArrangementActionValidator as ValidateFunction<CreditArrangementAction>,
    get schema() {
        return CreditArrangementAction.validate.schema
    },
    get errors() {
        return CreditArrangementAction.validate.errors ?? undefined
    },
    is: (o: unknown): o is CreditArrangementAction => CreditArrangementAction.validate(o) === true,
    parse: (o: unknown): { right: CreditArrangementAction } | { left: DefinedError[] } => {
        if (CreditArrangementAction.is(o)) {
            return { right: o }
        }
        return { left: (CreditArrangementAction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents credit arrangment filter and search criteria.
 */
export interface CreditArrangementFilterCriteria {
    field: 'id' | 'startDate' | 'expireDate' | 'approvedDate' | 'state' | 'subState' | 'exposureLimitType' | string
    /**
     * | **Operator**                | **Affected values**  | **Available for**                                                    |
     * |---------------               |----------------------|----------------------------------------------------------------------|
     * | EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |
     * | EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |
     * | MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |
     * | ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | STARTS_WITH                  | ONE_VALUE            | STRING                                                               |
     * | STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |
     * | IN                           | LIST                 | ENUM,KEY                                                             |
     * | TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |
     * | EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     * | NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     */
    operator:
        | 'EQUALS'
        | 'EQUALS_CASE_SENSITIVE'
        | 'DIFFERENT_THAN'
        | 'MORE_THAN'
        | 'LESS_THAN'
        | 'BETWEEN'
        | 'ON'
        | 'AFTER'
        | 'AFTER_INCLUSIVE'
        | 'BEFORE'
        | 'BEFORE_INCLUSIVE'
        | 'STARTS_WITH'
        | 'STARTS_WITH_CASE_SENSITIVE'
        | 'IN'
        | 'TODAY'
        | 'THIS_WEEK'
        | 'THIS_MONTH'
        | 'THIS_YEAR'
        | 'LAST_DAYS'
        | 'EMPTY'
        | 'NOT_EMPTY'
    /**
     * The second value to match the searching criteria, when the `BETWEEN` operator is used.
     */
    secondValue?: string | undefined
    /**
     * The value to match the searching criteria.
     */
    value?: string | undefined
    /**
     * List of values when the `IN` operator is used.
     */
    values?: string[] | undefined
}

/**
 * Represents the credit arrangement schedule.
 */
export interface CreditArrangementSchedule {
    /**
     * The list of installments for the credit arrangement.
     */
    installments?: Installment[] | undefined
}

export const CreditArrangementSchedule = {
    validate: CreditArrangementScheduleValidator as ValidateFunction<CreditArrangementSchedule>,
    get schema() {
        return CreditArrangementSchedule.validate.schema
    },
    get errors() {
        return CreditArrangementSchedule.validate.errors ?? undefined
    },
    is: (o: unknown): o is CreditArrangementSchedule => CreditArrangementSchedule.validate(o) === true,
    parse: (o: unknown): { right: CreditArrangementSchedule } | { left: DefinedError[] } => {
        if (CreditArrangementSchedule.is(o)) {
            return { right: o }
        }
        return { left: (CreditArrangementSchedule.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the filtering and sorting criteria when searching credit arrangements.
 */
export interface CreditArrangementSearchCriteria {
    /**
     * The list of filtering criteria.
     */
    filterCriteria?: CreditArrangementFilterCriteria[] | undefined
    sortingCriteria?: CreditArrangementSortingCriteria | undefined
}

export const CreditArrangementSearchCriteria = {
    validate: CreditArrangementSearchCriteriaValidator as ValidateFunction<CreditArrangementSearchCriteria>,
    get schema() {
        return CreditArrangementSearchCriteria.validate.schema
    },
    get errors() {
        return CreditArrangementSearchCriteria.validate.errors ?? undefined
    },
    is: (o: unknown): o is CreditArrangementSearchCriteria => CreditArrangementSearchCriteria.validate(o) === true,
    parse: (o: unknown): { right: CreditArrangementSearchCriteria } | { left: DefinedError[] } => {
        if (CreditArrangementSearchCriteria.is(o)) {
            return { right: o }
        }
        return { left: (CreditArrangementSearchCriteria.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The funding settings, holds the settings regarding the funding for the loan product.
 */
export interface CreditArrangementSettings {
    /**
     * Shows whether accounts created after this product can/should be part of a line of credit.
     */
    creditArrangementRequirement?: 'OPTIONAL' | 'REQUIRED' | 'NOT_REQUIRED' | undefined
}

/**
 * The sorting criteria used for credit arrangement client directed query
 */
export interface CreditArrangementSortingCriteria {
    /**
     * Contains the actual sorting fields
     */
    field: 'creationDate' | 'startDate' | 'expireDate' | 'amount'
    /**
     * The sorting order: `ASC` or `DESC`. The default order is `DESC`.
     */
    order?: 'ASC' | 'DESC' | undefined
}

/**
 * Represents the reference to the underlying documents of the payment.
 */
export interface CreditorReferenceInformation {
    /**
     * The reference information of the creditor's underlying documents
     */
    reference?: string | undefined
    /**
     * The entity that assigns the reference type
     */
    referenceIssuer?: string | undefined
    /**
     * The type of creditor reference
     */
    referenceType?: string | undefined
}

/**
 * Represents a currency eg. USD, EUR.
 */
export interface Currency {
    /**
     * Fiat(ISO-4217) currency code or NON_FIAT for non fiat currencies.
     */
    code?:
        | 'AED'
        | 'AFN'
        | 'ALL'
        | 'AMD'
        | 'ANG'
        | 'AOA'
        | 'ARS'
        | 'AUD'
        | 'AWG'
        | 'AZN'
        | 'BAM'
        | 'BBD'
        | 'BDT'
        | 'BGN'
        | 'BHD'
        | 'BIF'
        | 'BMD'
        | 'BND'
        | 'BOB'
        | 'BOV'
        | 'BRL'
        | 'BSD'
        | 'BTN'
        | 'BWP'
        | 'BYR'
        | 'BYN'
        | 'BZD'
        | 'CAD'
        | 'CDF'
        | 'CHE'
        | 'CHF'
        | 'CHW'
        | 'CLF'
        | 'CLP'
        | 'CNY'
        | 'COP'
        | 'COU'
        | 'CRC'
        | 'CUC'
        | 'CUP'
        | 'CVE'
        | 'CZK'
        | 'DJF'
        | 'DKK'
        | 'DOP'
        | 'DZD'
        | 'EGP'
        | 'ERN'
        | 'ETB'
        | 'EUR'
        | 'FJD'
        | 'FKP'
        | 'GBP'
        | 'GEL'
        | 'GHS'
        | 'GIP'
        | 'GMD'
        | 'GNF'
        | 'GTQ'
        | 'GYD'
        | 'HKD'
        | 'HNL'
        | 'HRK'
        | 'HTG'
        | 'HUF'
        | 'IDR'
        | 'ILS'
        | 'INR'
        | 'IQD'
        | 'IRR'
        | 'ISK'
        | 'JMD'
        | 'JOD'
        | 'JPY'
        | 'KES'
        | 'KGS'
        | 'KHR'
        | 'KMF'
        | 'KPW'
        | 'KRW'
        | 'KWD'
        | 'KYD'
        | 'KZT'
        | 'LAK'
        | 'LBP'
        | 'LKR'
        | 'LRD'
        | 'LSL'
        | 'LTL'
        | 'LVL'
        | 'LYD'
        | 'MAD'
        | 'MDL'
        | 'MGA'
        | 'MKD'
        | 'MMK'
        | 'MNT'
        | 'MOP'
        | 'MRO'
        | 'MRU'
        | 'MUR'
        | 'MVR'
        | 'MWK'
        | 'MXN'
        | 'MXV'
        | 'MYR'
        | 'MZN'
        | 'NAD'
        | 'NGN'
        | 'NIO'
        | 'NOK'
        | 'NPR'
        | 'NZD'
        | 'OMR'
        | 'PAB'
        | 'PEN'
        | 'PGK'
        | 'PHP'
        | 'PKR'
        | 'PLN'
        | 'PYG'
        | 'QAR'
        | 'RON'
        | 'RSD'
        | 'RUB'
        | 'RWF'
        | 'SAR'
        | 'SBD'
        | 'SCR'
        | 'SDG'
        | 'SEK'
        | 'SGD'
        | 'SHP'
        | 'SLL'
        | 'SOS'
        | 'SRD'
        | 'STD'
        | 'STN'
        | 'SVC'
        | 'SYP'
        | 'SZL'
        | 'THB'
        | 'TJS'
        | 'TMT'
        | 'TND'
        | 'TOP'
        | 'TRY'
        | 'TTD'
        | 'TWD'
        | 'TZS'
        | 'UAH'
        | 'UGX'
        | 'USD'
        | 'USN'
        | 'UYI'
        | 'UYU'
        | 'UYW'
        | 'UZS'
        | 'VED'
        | 'VEF'
        | 'VES'
        | 'VND'
        | 'VUV'
        | 'WST'
        | 'XAG'
        | 'XAU'
        | 'XAF'
        | 'XBA'
        | 'XBB'
        | 'XBC'
        | 'XBD'
        | 'XCD'
        | 'XDR'
        | 'XOF'
        | 'XPD'
        | 'XPF'
        | 'XPT'
        | 'XSU'
        | 'XTS'
        | 'XUA'
        | 'XXX'
        | 'YER'
        | 'ZAR'
        | 'ZIG'
        | 'ZMK'
        | 'ZWL'
        | 'ZMW'
        | 'SSP'
        | 'NON_FIAT'
        | undefined
    /**
     * Currency code for NON_FIAT currency.
     */
    currencyCode?: string | undefined
}

/**
 * Represents a currency.
 */
export interface CurrencyDetails {
    /**
     * `TRUE` if the currency is the base currency, `FALSE` otherwise. It cannot be changed and it's a read-only field not required for update operations.
     */
    baseCurrency: boolean
    /**
     * The currency code, which cannot be changed once the currency is created.
     */
    code: string
    /**
     * The date this currency was created. It cannot be changed and it's a read-only field not required for update operations.
     */
    creationDate?: string | undefined
    /**
     * The list of holidays for this currency.
     */
    currencyHolidays?: Holiday[] | undefined
    /**
     * The currency symbol position.
     */
    currencySymbolPosition: 'BEFORE_NUMBER' | 'AFTER_NUMBER'
    /**
     * The number of digits that are supported for a given currency.
     */
    digitsAfterDecimal?: number | undefined
    /**
     * The last date this currency was modified. It's updated automatically and it's a read-only field not required for update operations.
     */
    lastModifiedDate?: string | undefined
    /**
     * The name of the currency.
     */
    name: string
    /**
     * The currency numeric code.
     */
    numericCode?: string | undefined
    /**
     * The currency symbol.
     */
    symbol: string
    /**
     * The type of the currency.
     */
    type: 'FIAT_CURRENCY' | 'CRYPTOCURRENCY' | 'NON_TRADITIONAL_CURRENCY'
}

export const CurrencyDetails = {
    validate: CurrencyDetailsValidator as ValidateFunction<CurrencyDetails>,
    get schema() {
        return CurrencyDetails.validate.schema
    },
    get errors() {
        return CurrencyDetails.validate.errors ?? undefined
    },
    is: (o: unknown): o is CurrencyDetails => CurrencyDetails.validate(o) === true,
    parse: (o: unknown): { right: CurrencyDetails } | { left: DefinedError[] } => {
        if (CurrencyDetails.is(o)) {
            return { right: o }
        }
        return { left: (CurrencyDetails.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents one option of a selection custom field definition.
 */
export interface CustomFieldAvailableOption {
    /**
     * The score of the option.
     */
    score?: number | undefined
    /**
     * The system-generated ID of the option.
     */
    selectionKey?: string | undefined
    /**
     * The name of the option.
     */
    value?: string | undefined
}

/**
 * Represents the display settings of a custom field definition.
 */
export interface CustomFieldDisplaySettings {
    /**
     * The original ID of the built-in custom field definition.
     */
    builtInId?:
        | 'FIRST_NAME'
        | 'MIDDLE_NAME'
        | 'LAST_NAME'
        | 'BIRTHDATE'
        | 'GENDER'
        | 'MOBILE_PHONE'
        | 'MOBILE_PHONE_2'
        | 'HOME_PHONE'
        | 'EMAIL_ADDRESS'
        | undefined
    /**
     * The user-provided description of the custom field definition.
     */
    description?: string | undefined
    /**
     * The user-provided name of the custom field definition.
     */
    displayName?: string | undefined
    /**
     * The custom field value display size in the UI.
     */
    fieldSize?: 'SHORT' | 'LONG' | undefined
    /**
     * The custom field definition position in the custom field set.
     */
    position?: number | undefined
}

/**
 * Represents the edit rights for custom field values for a particular custom field definition.
 */
export interface CustomFieldEditRights {
    /**
     * `TRUE` if custom field values of a custom field definition can be edited by all users, `FALSE` if custom field values of a custom field definition can only be edited by users with the specified roles.
     */
    allUsers?: boolean | undefined
    /**
     * The list of IDs of the roles that have edit rights for the custom field values of a custom field definition if it is not accessible by all users.
     */
    roles?: string[] | undefined
}

/**
 * A simple representation, holds only the information that identifies the custom field
 */
export interface CustomFieldIdentity {
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * User-provided ID of the custom field
     */
    id?: string | undefined
}

/**
 * Represents a custom field definition.
 */
export interface CustomFieldMeta {
    /**
     * The entity type the custom field definition is associated with.
     */
    availableFor?:
        | 'CLIENT'
        | 'GROUP'
        | 'CREDIT_ARRANGEMENT'
        | 'LOAN_ACCOUNT'
        | 'GUARANTOR'
        | 'ASSET'
        | 'DEPOSIT_ACCOUNT'
        | 'DEPOSIT_PRODUCT'
        | 'TRANSACTION_CHANNEL'
        | 'TRANSACTION_TYPE'
        | 'BRANCH'
        | 'CENTRE'
        | 'USER'
        | undefined
    /**
     * The date the custom field definition was created.
     */
    creationDate?: string | undefined
    /**
     * Can be defined only for selection custom field definitions. Indicates the parent custom field definition on which the dependency is based upon.
     */
    dependentFieldKey?: string | undefined
    displaySettings?: CustomFieldDisplaySettings | undefined
    editRights?: CustomFieldEditRights | undefined
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The user-defined ID, which is globally unique.
     */
    id?: string | undefined
    /**
     * The date the latest update was performed for this custom field definition.
     */
    lastModifiedDate?: string | undefined
    /**
     * Can be defined only for selection custom field definitions. Indicates that the field has predefined selections and only those can be used to populate it.
     */
    selectionOptions?: CustomFieldSelectionOption[] | undefined
    /**
     * Indicates whether the custom field definition is active or inactive.
     */
    state?: 'ACTIVE' | 'INACTIVE' | undefined
    /**
     * The type of custom field definition.
     */
    type?:
        | 'FREE_TEXT'
        | 'SELECTION'
        | 'NUMBER'
        | 'CHECKBOX'
        | 'DATE'
        | 'DATE_TIME'
        | 'CLIENT_LINK'
        | 'GROUP_LINK'
        | 'USER_LINK'
        | undefined
    /**
     * Represents the usage settings of a custom field definition.
     */
    usage?: CustomFieldUsage[] | undefined
    valueValidationSettings?: CustomFieldValueValidationSettings | undefined
    viewRights?: CustomFieldViewRights | undefined
}

export const CustomFieldMeta = {
    validate: CustomFieldMetaValidator as ValidateFunction<CustomFieldMeta>,
    get schema() {
        return CustomFieldMeta.validate.schema
    },
    get errors() {
        return CustomFieldMeta.validate.errors ?? undefined
    },
    is: (o: unknown): o is CustomFieldMeta => CustomFieldMeta.validate(o) === true,
    parse: (o: unknown): { right: CustomFieldMeta } | { left: DefinedError[] } => {
        if (CustomFieldMeta.is(o)) {
            return { right: o }
        }
        return { left: (CustomFieldMeta.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the information related to the options of a selection custom field definition.
 */
export interface CustomFieldSelectionOption {
    /**
     * The list of options that that are available for the dependent selection custom field value based on the selected parent custom field value.
     */
    availableOptions?: CustomFieldAvailableOption[] | undefined
    /**
     * The key for the parent selection custom field value.
     */
    forSelectionKey?: string | undefined
    /**
     * The parent selection custom field value.
     */
    forValue?: string | undefined
}

/**
 * Wrapper holds the display properties of a Custom Field Set
 */
export interface CustomFieldSetDisplaySettings {
    /**
     * This is used only for builtIn custom field sets and can have two possible values:
     * True - when this is a "mambu" field set,
     * False - when this is a tenant-defined field set
     */
    builtIn?: boolean | undefined
    /**
     * User-provided name of the custom field set
     */
    displayName?: string | undefined
    /**
     * Represents the order of the custom field set (starts from 0)
     */
    position?: number | undefined
}

/**
 * Model representation of a Custom Field Set
 */
export interface CustomFieldSetMeta {
    /**
     * Indicates the entity that the custom field set is associated with (eg. clients or any entity that allows CF definition)
     */
    availableFor?:
        | 'CLIENT'
        | 'GROUP'
        | 'CREDIT_ARRANGEMENT'
        | 'LOAN_ACCOUNT'
        | 'GUARANTOR'
        | 'ASSET'
        | 'DEPOSIT_ACCOUNT'
        | 'DEPOSIT_PRODUCT'
        | 'TRANSACTION_CHANNEL'
        | 'TRANSACTION_TYPE'
        | 'BRANCH'
        | 'CENTRE'
        | 'USER'
        | undefined
    /**
     * Date at which the custom field set was created
     */
    creationDate?: string | undefined
    /**
     * This section lists all the custom fields associated with this set
     */
    customFields?: CustomFieldIdentity[] | undefined
    /**
     * Free text field to store eventual notes with regard to custom field group purpose/details
     */
    description?: string | undefined
    displaySettings?: CustomFieldSetDisplaySettings | undefined
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The usage decides how the custom field set will be used in the UI and how the custom field values will be stored. For STANDARD set type the custom field set can be used only once (i.e Personal Information). For GROUPED set type the custom field set can be used multiple times (i.e Addresses). For further details please see [here](https://support.mambu.com/customer/en/portal/articles/1986000-custom-fields?b_id=873#2)
     */
    fieldSetType?: 'STANDARD' | 'GROUPED' | undefined
    /**
     * User-defined ID, gobally unique
     */
    id?: string | undefined
}

/**
 * Represents the usage settings of the custom field definition.
 */
export interface CustomFieldUsage {
    /**
     * `TRUE` if the field is displayed by default on create or edit pages for this record type, `FALSE` otherwise.
     */
    default?: boolean | undefined
    /**
     * The key of the record type.
     */
    objectKey?: string | undefined
    /**
     * `TRUE` if the field is required for this record type, `FALSE` otherwise.
     */
    required?: boolean | undefined
}

/**
 * Represents the settings for field input validation.
 */
export interface CustomFieldValueValidationSettings {
    /**
     * `TRUE` if this field does not allow duplicate values, `FALSE` otherwise.
     */
    unique?: boolean | undefined
    /**
     * The expected format for the input.
     */
    validationPattern?: string | undefined
}

/**
 * Represents the view rights for custom field values for a particular custom field definition.
 */
export interface CustomFieldViewRights {
    /**
     * `TRUE` if custom field values of a custom field definition can be viewed by all users, `FALSE` if custom field values of a custom field definition can only be viewed by users with the specified roles.
     */
    allUsers?: boolean | undefined
    /**
     * Lists the IDs of the roles that have view rights for the custom field values of a custom field definition if it is not accessible by all users.
     */
    roles?: string[] | undefined
}

/**
 * Custom payment amount for a specific element type
 */
export interface CustomPaymentAmount {
    /**
     * The amount of the payment paid in the transaction for the given type.
     */
    amount: number
    /**
     * The type of the custom payment
     */
    customPaymentAmountType:
        | 'PRINCIPAL'
        | 'INTEREST'
        | 'MANUAL_FEE'
        | 'UPFRONT_DISBURSEMENT_FEE'
        | 'LATE_REPAYMENT_FEE'
        | 'PAYMENT_DUE_FEE'
        | 'PENALTY'
        | 'INTEREST_FROM_ARREARS'
    /**
     * The encodedKey of the predefined fee to be paid.
     */
    predefinedFeeKey?: string | undefined
    /**
     * The amount of the taxes paid in the transaction for the given type.
     */
    taxOnAmount?: number | undefined
}

/**
 * The custom predefined fees, they may be used as the expected predefined fees that will be applied on the disbursement.
 */
export interface CustomPredefinedFee {
    /**
     * The amount of the custom fee.
     */
    amount?: number | undefined
    /**
     * The encoded key of the custom predefined fee, auto generated, unique.
     */
    encodedKey?: string | undefined
    /**
     * The percentage of the custom fee.
     */
    percentage?: number | undefined
    /**
     * The encoded key of the predefined fee
     */
    predefinedFeeEncodedKey?: string | undefined
}

/**
 * Response representation of the dashboard configuration
 */
export interface DashboardConfiguration {
    /**
     * The date dashboard configuration was created
     */
    creationDate?: string | undefined
    /**
     * The encoded key of the dashboard configuration, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * The Dashboard option name
     */
    name?:
        | 'LATEST_ACTIVITY'
        | 'TASKS'
        | 'FAVOURITE_VIEWS'
        | 'INDICATORS'
        | 'CURRENT_TILLS'
        | 'CLIENTS'
        | 'UPCOMING_REPAYMENTS'
        | 'NONE'
        | undefined
}

/**
 * Holds information about the data import action
 */
export interface DataImportAction {
    /**
     * Type of the data import action
     */
    type: 'APPROVE' | 'REJECT'
}

export const DataImportAction = {
    validate: DataImportActionValidator as ValidateFunction<DataImportAction>,
    get schema() {
        return DataImportAction.validate.schema
    },
    get errors() {
        return DataImportAction.validate.errors ?? undefined
    },
    is: (o: unknown): o is DataImportAction => DataImportAction.validate(o) === true,
    parse: (o: unknown): { right: DataImportAction } | { left: DefinedError[] } => {
        if (DataImportAction.is(o)) {
            return { right: o }
        }
        return { left: (DataImportAction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Holds information about the data import error
 */
export interface DataImportError {
    column?: DataImportErrorColumn | undefined
    /**
     * Error message
     */
    errorMessage?: string | undefined
    /**
     * Row index
     */
    row?: number | undefined
    /**
     * Sheet name
     */
    sheet?: string | undefined
}

/**
 * Holds basic information for an error column: the index and the corresponding name
 */
export interface DataImportErrorColumn {
    /**
     * Column index
     */
    index?: number | undefined
    /**
     * Column name
     */
    name?: string | undefined
}

export interface DataImportRequest {
    /**
     * The file to import
     */
    file: string
}

export const DataImportRequest = {
    validate: DataImportRequestValidator as ValidateFunction<DataImportRequest>,
    get schema() {
        return DataImportRequest.validate.schema
    },
    get errors() {
        return DataImportRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is DataImportRequest => DataImportRequest.validate(o) === true,
    parse: (o: unknown): { right: DataImportRequest } | { left: DefinedError[] } => {
        if (DataImportRequest.is(o)) {
            return { right: o }
        }
        return { left: (DataImportRequest.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Holds information about the response of the data import action
 */
export interface DataImportResponse {
    /**
     * Import key
     */
    importKey?: string | undefined
    /**
     * Background process state
     */
    state?:
        | 'QUEUED'
        | 'IN_PROGRESS'
        | 'COMPLETE'
        | 'NOT_FOUND'
        | 'CANCEL'
        | 'TO_BE_CANCELED'
        | 'TIMED_OUT'
        | 'ERROR'
        | 'TRANSIENT_ERROR'
        | 'OVERRIDDEN'
        | 'RECOVERABLE_ERROR'
        | undefined
}

export const DataImportResponse = {
    validate: DataImportResponseValidator as ValidateFunction<DataImportResponse>,
    get schema() {
        return DataImportResponse.validate.schema
    },
    get errors() {
        return DataImportResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is DataImportResponse => DataImportResponse.validate(o) === true,
    parse: (o: unknown): { right: DataImportResponse } | { left: DefinedError[] } => {
        if (DataImportResponse.is(o)) {
            return { right: o }
        }
        return { left: (DataImportResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Holds information about the data import status
 */
export interface DataImportStatus {
    /**
     * List of errors
     */
    errors?: DataImportError[] | undefined
    /**
     * Event key
     */
    eventKey?: string | undefined
    /**
     * Background process state
     */
    state?:
        | 'QUEUED'
        | 'IN_PROGRESS'
        | 'COMPLETE'
        | 'NOT_FOUND'
        | 'CANCEL'
        | 'TO_BE_CANCELED'
        | 'TIMED_OUT'
        | 'ERROR'
        | 'TRANSIENT_ERROR'
        | 'OVERRIDDEN'
        | 'RECOVERABLE_ERROR'
        | undefined
}

export const DataImportStatus = {
    validate: DataImportStatusValidator as ValidateFunction<DataImportStatus>,
    get schema() {
        return DataImportStatus.validate.schema
    },
    get errors() {
        return DataImportStatus.validate.errors ?? undefined
    },
    is: (o: unknown): o is DataImportStatus => DataImportStatus.validate(o) === true,
    parse: (o: unknown): { right: DataImportStatus } | { left: DefinedError[] } => {
        if (DataImportStatus.is(o)) {
            return { right: o }
        }
        return { left: (DataImportStatus.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Enumeration for days of month and method of handling shorter months.
 */
export interface DaysInMonth {
    /**
     * Specifies the day(s) of the month when the interest application dates should be. Only available if the Interest Application Method is InterestApplicationMethodDTO#FIXED_DAYS_OF_MONTH. Currently only 1 value can be specified.
     */
    daysInMonth?: number[] | undefined
    /**
     * Determines how to handle the short months, if they select a fixed day of month > 28. Will be null if no such date is selected. Only available if the Interest Application Method is InterestApplicationMethodDTO#FIXED_DAYS_OF_MONTH.
     */
    shortMonthHandlingMethod?: 'LAST_DAY_IN_MONTH' | 'FIRST_DAY_OF_NEXT_MONTH' | undefined
}

/**
 * Decimal constraints, like min/max/default.
 */
export interface DecimalConstraints {
    /**
     * The default value, will be used in case no other value was filled in by the user.
     */
    defaultValue?: number | undefined
    /**
     * The encoded key of the decimal constraint, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * The maximum value.
     */
    maxValue?: number | undefined
    /**
     * The minimum value.
     */
    minValue?: number | undefined
}

/**
 * Decimal constraints, like min/max/default.
 */
export interface DecimalInterval {
    /**
     * The default value, will be used in case no other value was filled in by the user.
     */
    defaultValue?: number | undefined
    /**
     * The maximum value.
     */
    maxValue?: number | undefined
    /**
     * The minimum value.
     */
    minValue?: number | undefined
}

/**
 * Represents information about a deposit account.
 */
export interface DepositAccount {
    /**
     * The encoded key of the account holder, which is an individual client or group.
     */
    accountHolderKey: string
    /**
     * The account holder type.
     */
    accountHolderType: 'CLIENT' | 'GROUP'
    /**
     * The state of the deposit account.
     */
    accountState?:
        | 'PENDING_APPROVAL'
        | 'APPROVED'
        | 'ACTIVE'
        | 'ACTIVE_IN_ARREARS'
        | 'MATURED'
        | 'LOCKED'
        | 'DORMANT'
        | 'CLOSED'
        | 'CLOSED_WRITTEN_OFF'
        | 'WITHDRAWN'
        | 'CLOSED_REJECTED'
        | undefined
    /**
     * The deposit account type and the product that it belongs to.
     */
    accountType?: 'CURRENT_ACCOUNT' | 'REGULAR_SAVINGS' | 'FIXED_DEPOSIT' | 'SAVINGS_PLAN' | 'INVESTOR_ACCOUNT' | undefined
    accruedAmounts?: DepositAccountAccruedAmounts | undefined
    /**
     * The date when the deposit account was activated, in the organization's timezone and time format.
     */
    activationDate?: string | undefined
    /**
     * The date when the deposit account was approved, in the organization's timezone and time format.
     */
    approvedDate?: string | undefined
    /**
     * The key of the branch that this deposit account is assigned to.
     */
    assignedBranchKey?: string | undefined
    /**
     * The key of the centre that this account is assigned to.
     */
    assignedCentreKey?: string | undefined
    /**
     * The key of the user that this deposit is assigned to.
     */
    assignedUserKey?: string | undefined
    balances?: DepositAccountBalances | undefined
    /**
     * The date when the deposit account was closed, in UTC.
     */
    closedDate?: string | undefined
    /**
     * The date this deposit account was created, in UTC.
     */
    creationDate?: string | undefined
    /**
     * The key to the credit arrangement where this account is registered.
     */
    creditArrangementKey?: string | undefined
    /**
     * The currency code.
     */
    currencyCode?: string | undefined
    /**
     * The encoded key of the deposit account, which is auto-generated and unique.
     */
    encodedKey?: string | undefined
    /**
     * The ID of the deposit account, which can be generated and customized - but must be unique.
     */
    id?: string | undefined
    interestSettings?: DepositAccountInterestSettings | undefined
    internalControls?: DepositAccountInternalControls | undefined
    /**
     * The date when the account was last evaluated for interest calculations and maturity, in the organization's timezone and time format.
     */
    lastAccountAppraisalDate?: string | undefined
    /**
     * The date when interest was last calculated for the account, in the organization's timezone and time format.
     */
    lastInterestCalculationDate?: string | undefined
    /**
     * The date when regular interest was last reviewed, in the organization's timezone and time format.
     */
    lastInterestReviewDate?: string | undefined
    /**
     * The date when interest was last applied on the account, in the organization's timezone and time format.
     */
    lastInterestStoredDate?: string | undefined
    /**
     * The last update date for the deposit account, in UTC.
     */
    lastModifiedDate?: string | undefined
    /**
     * The date when the overdraft interest was last reviewed, in the organization's timezone and time format.
     */
    lastOverdraftInterestReviewDate?: string | undefined
    /**
     * The date when the deposit account was set to In Arrears, or null if the account is not In Arrears. The date is in the organization's timezone and time format.
     */
    lastSetToArrearsDate?: string | undefined
    /**
     * Lists all loan account keys on which the deposit account is used as the settlement account.
     */
    linkedSettlementAccountKeys?: string[] | undefined
    /**
     * The date when the deposit account was locked, in the organization's timezone and time format.
     */
    lockedDate?: string | undefined
    /**
     * The date when the account matures, for fixed or compulsory savings plans, in the organization's timezone and time format.
     */
    maturityDate?: string | undefined
    /**
     * The migration event encoded key associated with this deposit account. If this account was imported, you can track which migration event it came from.
     */
    migrationEventKey?: string | undefined
    /**
     * The deposit account name.
     */
    name: string
    /**
     * The notes or description attached to this object.
     */
    notes?: string | undefined
    overdraftInterestSettings?: DepositAccountOverdraftInterestSettings | undefined
    overdraftSettings?: DepositAccountOverdraftSettings | undefined
    /**
     * The history of deposit account ownership
     */
    ownershipHistory?: DepositAccountOwnershipHistory[] | undefined
    /**
     * The key to the product type that this account is based on.
     */
    productTypeKey: string
    /**
     * The tax source where the account withholding taxes will be updated.
     */
    withholdingTaxSourceKey?: string | undefined
}

export const DepositAccount = {
    validate: DepositAccountValidator as ValidateFunction<DepositAccount>,
    get schema() {
        return DepositAccount.validate.schema
    },
    get errors() {
        return DepositAccount.validate.errors ?? undefined
    },
    is: (o: unknown): o is DepositAccount => DepositAccount.validate(o) === true,
    parse: (o: unknown): { right: DepositAccount } | { left: DefinedError[] } => {
        if (DepositAccount.is(o)) {
            return { right: o }
        }
        return { left: (DepositAccount.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents information about the accrued amounts of deposit accounts.
 */
export interface DepositAccountAccruedAmounts {
    /**
     * The amount of positive interest that has been accrued in the account.
     */
    interestAccrued?: number | undefined
    /**
     * The amount of negative interest that has been accrued in the account.
     */
    negativeInterestAccrued?: number | undefined
    /**
     * The amount of overdraft interest that has been accrued in the account.
     */
    overdraftInterestAccrued?: number | undefined
    /**
     * The amount of technical overdraft interest that has been accrued in the account.
     */
    technicalOverdraftInterestAccrued?: number | undefined
}

/**
 * Represents the action details for a deposit account.
 */
export interface DepositAccountAction {
    /**
     * The action type to be applied.
     */
    action: 'APPROVE' | 'UNDO_APPROVE' | 'LOCK' | 'UNLOCK' | 'CLOSE' | 'CLOSE_WITHDRAW' | 'CLOSE_REJECT' | 'CLOSE_WRITE_OFF'
    /**
     * The notes related to the action performed.
     */
    notes?: string | undefined
}

export const DepositAccountAction = {
    validate: DepositAccountActionValidator as ValidateFunction<DepositAccountAction>,
    get schema() {
        return DepositAccountAction.validate.schema
    },
    get errors() {
        return DepositAccountAction.validate.errors ?? undefined
    },
    is: (o: unknown): o is DepositAccountAction => DepositAccountAction.validate(o) === true,
    parse: (o: unknown): { right: DepositAccountAction } | { left: DefinedError[] } => {
        if (DepositAccountAction.is(o)) {
            return { right: o }
        }
        return { left: (DepositAccountAction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents information about the balances of a deposit account.
 */
export interface DepositAccountBalances {
    /**
     * The current available balance for deposit transactions.
     */
    availableBalance?: number | undefined
    /**
     * The sum of all the blocked amounts on an account.
     */
    blockedBalance?: number | undefined
    /**
     * The amount of fees due to be paid on this account.
     */
    feesDue?: number | undefined
    /**
     * The sum of all the authorization hold amounts that have `CRDT` as the `creditDebitIndicator` for an account.
     */
    forwardAvailableBalance?: number | undefined
    /**
     * The sum of all the authorization hold amounts that have `DBIT` as the `creditDebitIndicator` for an account.
     */
    holdBalance?: number | undefined
    /**
     * The locked amount that is not available for withdrawal in the account. For more information, see [Deposit Account Overview Details](https://support.mambu.com/docs/deposit-account-overview-details).
     */
    lockedBalance?: number | undefined
    /**
     * The overdraft amount that has been taken out in the account. For more information, see [Overdraft Products](https://support.mambu.com/docs/en/overdraft-products).
     */
    overdraftAmount?: number | undefined
    /**
     * The amount of interest due to be paid on an account as a result of an authorized overdraft.
     */
    overdraftInterestDue?: number | undefined
    /**
     * The technical overdraft amount that has been taken out in the account. For more information, see [Technical Overdraft](https://support.mambu.com/docs/en/overdraft-products#technical-overdraft).
     */
    technicalOverdraftAmount?: number | undefined
    /**
     * The amount of interest due to be paid on an account as a result of a technical overdraft.
     */
    technicalOverdraftInterestDue?: number | undefined
    /**
     * The current balance of the account.
     */
    totalBalance?: number | undefined
}

/**
 * Represents the filter list used for searching deposit accounts.
 */
export interface DepositAccountFilterCriteria {
    field:
        | 'encodedKey'
        | 'id'
        | 'name'
        | 'accountHolderKey'
        | 'clientId'
        | 'groupId'
        | 'accountHolderName'
        | 'accountState'
        | 'accountType'
        | 'creationDate'
        | 'activationDate'
        | 'approvedDate'
        | 'lastModifiedDate'
        | 'maturityDate'
        | 'lastSetToArrearsDate'
        | 'closedDate'
        | 'accruedAmounts.interestAccrued'
        | 'accruedAmounts.overdraftInterestAccrued'
        | 'accruedAmounts.technicalOverdraftInterestAccrued'
        | 'maxBalance'
        | 'balances.availableBalance'
        | 'balances.blockedBalance'
        | 'balances.feesDue'
        | 'balances.lockedBalance'
        | 'balances.overdraftAmount'
        | 'balances.overdraftInterestDue'
        | 'balances.technicalOverdraftAmount'
        | 'balances.totalBalance'
        | 'balances.holdBalance'
        | 'assignedBranchKey'
        | 'assignedCentreKey'
        | 'assignedUserKey'
        | 'currencyCode'
        | 'interestSettings.interestRate'
        | 'currentInterestTier.endingBalance'
        | 'currentInterestTier.index'
        | 'currentInterestTier.interestRate'
        | 'currentInterestTier.startingBalance'
        | 'internalControls.maxWithdrawalAmount'
        | 'internalControls.recommendedDepositAmount'
        | 'internalControls.targetAmount'
        | 'lengthInDays'
        | 'overdraftRiskLevelKey'
        | 'overdraftAvailableLimit'
        | 'overdraftDaysInArrears'
        | 'overdraftInArrears'
        | 'overdraftInterestSettings.interestRateSettings.interestRate'
        | 'overdraftInterestSettings.interestRateSettings.interestSpread'
        | 'currentOverdraftInterestTier.endingBalance'
        | 'currentOverdraftInterestTier.index'
        | 'currentOverdraftInterestTier.interestRate'
        | 'currentOverdraftInterestTier.startingBalance'
        | 'overdraftSettings.overdraftExpiryDate'
        | 'overdraftSettings.overdraftLimit'
        | 'overdraftSettings.allowOverdraft'
        | 'productTypeKey'
        | 'productCategory'
        | 'taxApplied'
        | 'withholdingTaxSourceKey'
        | 'taxRate'
        | string
    /**
     * | **Operator**                | **Affected values**  | **Available for**                                                    |
     * |---------------               |----------------------|----------------------------------------------------------------------|
     * | EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |
     * | EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |
     * | MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |
     * | ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | STARTS_WITH                  | ONE_VALUE            | STRING                                                               |
     * | STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |
     * | IN                           | LIST                 | ENUM,KEY                                                             |
     * | TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |
     * | EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     * | NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     */
    operator:
        | 'EQUALS'
        | 'EQUALS_CASE_SENSITIVE'
        | 'DIFFERENT_THAN'
        | 'MORE_THAN'
        | 'LESS_THAN'
        | 'BETWEEN'
        | 'ON'
        | 'AFTER'
        | 'AFTER_INCLUSIVE'
        | 'BEFORE'
        | 'BEFORE_INCLUSIVE'
        | 'STARTS_WITH'
        | 'STARTS_WITH_CASE_SENSITIVE'
        | 'IN'
        | 'TODAY'
        | 'THIS_WEEK'
        | 'THIS_MONTH'
        | 'THIS_YEAR'
        | 'LAST_DAYS'
        | 'EMPTY'
        | 'NOT_EMPTY'
    /**
     * The second value to match the searching criteria, when the `BETWEEN` operator is used.
     */
    secondValue?: string | undefined
    /**
     * The value to match the searching criteria.
     */
    value?: string | undefined
    /**
     * List of values when the `IN` operator is used.
     */
    values?: string[] | undefined
}

/**
 * Interest Rate Settings for Deposit Account Interest Availability
 */
export interface DepositAccountInterestAvailabilitySettings {
    /**
     * The interest rate for the deposit account
     */
    interestRate?: number | undefined
    /**
     * The list of interest rate tiers. An interest rate tier holds the values to define how the interest is computed
     */
    interestRateTiers?: DepositAccountInterestRateTier[] | undefined
    /**
     * The rate based on which the interest is accrued and applied for accounts with InterestRateSource#INDEX_INTEREST_RATE
     */
    interestSpread?: number | undefined
}

/**
 * Represents information about the interest payment settings.
 */
export interface DepositAccountInterestPaymentSettings {
    /**
     * The list of all dates when the interest is paid into the deposit account.
     */
    interestPaymentDates?: MonthAndDay[] | undefined
    /**
     * The interest payment point, which specifies when the interest should be paid to the account.
     */
    interestPaymentPoint?:
        | 'FIRST_DAY_OF_MONTH'
        | 'EVERY_WEEK'
        | 'EVERY_OTHER_WEEK'
        | 'EVERY_MONTH'
        | 'EVERY_3_MONTHS'
        | 'ON_FIXED_DATES'
        | 'DAILY'
        | 'ANNUALLY'
        | 'BI_ANNUALLY'
        | 'ON_ACCOUNT_MATURITY'
        | undefined
}

/**
 * Represents information about the interest rate settings for deposit accounts.
 */
export interface DepositAccountInterestRateSettings {
    /**
     * The encoded key for the set of interest settings, which is auto-generated and unique.
     */
    encodedKey?: string | undefined
    /**
     * The interest charge frequency, which shows how often interest is charged on loan or deposit accounts.
     */
    interestChargeFrequency?:
        | 'ANNUALIZED'
        | 'EVERY_MONTH'
        | 'EVERY_FOUR_WEEKS'
        | 'EVERY_WEEK'
        | 'EVERY_DAY'
        | 'EVERY_X_DAYS'
        | undefined
    /**
     * The number of times to apply interest in a time period.
     */
    interestChargeFrequencyCount?: number | undefined
    /**
     * The interest rate for the deposit account.
     */
    interestRate?: number | undefined
    /**
     * The number of times to review the interest rate in a time period.
     */
    interestRateReviewCount?: number | undefined
    /**
     * The time unit to use to determine the frequency of interest rate reviews.
     */
    interestRateReviewUnit?: 'DAYS' | 'WEEKS' | 'MONTHS' | undefined
    /**
     * The interest calculation method used.
     */
    interestRateSource?: 'FIXED_INTEREST_RATE' | 'INDEX_INTEREST_RATE' | undefined
    /**
     * The terms for how interest rate is determined when accruing for an account.
     */
    interestRateTerms?: 'FIXED' | 'TIERED' | 'TIERED_PERIOD' | 'TIERED_BAND' | undefined
    /**
     * The list of interest rate tiers, which hold the values to define how interest is calculated.
     */
    interestRateTiers?: DepositAccountInterestRateTier[] | undefined
    /**
     * The index interest rate that is used to calculate the interest rate that is applied to accounts.
     */
    interestSpread?: number | undefined
}

/**
 * Represents information about how interest rate is calculated.
 */
export interface DepositAccountInterestRateTier {
    /**
     * The encoded key of the interest rate tier, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * The top-limit value for the account balance in order to determine if this tier is used or not
     */
    endingBalance?: number | undefined
    /**
     * The end date for the account period. Used to determine if this interest rate tier is used or not.
     */
    endingDay?: number | undefined
    /**
     * The rate used for computing the interest for an account which has the balance less than the ending balance
     */
    interestRate: number
}

/**
 * Represents information about the deposit account's interest settings.
 */
export interface DepositAccountInterestSettings {
    interestPaymentSettings?: DepositAccountInterestPaymentSettings | undefined
    interestRateSettings?: DepositAccountInterestRateSettings | undefined
}

/**
 * Represents information about internal controls.
 */
export interface DepositAccountInternalControls {
    /**
     * The maximum deposit balance of the account.
     */
    maxDepositBalance?: number | undefined
    /**
     * The maximum amount allowed for a withdrawal.
     */
    maxWithdrawalAmount?: number | undefined
    /**
     * The recommended amount for a deposit.
     */
    recommendedDepositAmount?: number | undefined
    /**
     * The target amount for a deposit made towards a savings goal.
     */
    targetAmount?: number | undefined
}

/**
 * Represents information about overdraft interest rate settings for deposit accounts.
 */
export interface DepositAccountOverdraftInterestRateSettings {
    /**
     * The encoded key for the set of interest settings, which is auto-generated and unique.
     */
    encodedKey?: string | undefined
    /**
     * The interest charge frequency, which shows how often interest is charged on loan or deposit accounts.
     */
    interestChargeFrequency?:
        | 'ANNUALIZED'
        | 'EVERY_MONTH'
        | 'EVERY_FOUR_WEEKS'
        | 'EVERY_WEEK'
        | 'EVERY_DAY'
        | 'EVERY_X_DAYS'
        | undefined
    /**
     * The number of times to apply interest in a time period.
     */
    interestChargeFrequencyCount?: number | undefined
    /**
     * The interest rate for the deposit account.
     */
    interestRate?: number | undefined
    /**
     * The number of times to review the interest rate in a time period.
     */
    interestRateReviewCount?: number | undefined
    /**
     * The time unit to use to determine the frequency of interest rate reviews.
     */
    interestRateReviewUnit?: 'DAYS' | 'WEEKS' | 'MONTHS' | undefined
    /**
     * The interest calculation method used.
     */
    interestRateSource?: 'FIXED_INTEREST_RATE' | 'INDEX_INTEREST_RATE' | undefined
    /**
     * The terms for how interest rate is determined when accruing for an account.
     */
    interestRateTerms?: 'FIXED' | 'TIERED' | 'TIERED_PERIOD' | 'TIERED_BAND' | undefined
    /**
     * The list of interest rate tiers, which hold the values to define how interest is calculated.
     */
    interestRateTiers?: DepositAccountInterestRateTier[] | undefined
    /**
     * The index interest rate that is used to calculate the interest rate that is applied to accounts.
     */
    interestSpread?: number | undefined
}

/**
 * Represents information about a deposit account's overdraft interest settings.
 */
export interface DepositAccountOverdraftInterestSettings {
    interestRateSettings?: DepositAccountOverdraftInterestRateSettings | undefined
}

/**
 * Represents information about a deposit account's overdraft settings.
 */
export interface DepositAccountOverdraftSettings {
    /**
     * `TRUE` if this account supports overdraft, `FALSE` otherwise.
     */
    allowOverdraft?: boolean | undefined
    /**
     * The expiration date of an overdraft.
     */
    overdraftExpiryDate?: string | undefined
    /**
     * The limit amount that may be taken out as overdraft, where null means 0.
     */
    overdraftLimit?: number | undefined
}

/**
 * The history of deposit account ownership
 */
export interface DepositAccountOwnershipHistory {
    /**
     * They key of the previous account holder
     */
    previousOwnerKey?: string | undefined
    /**
     * The transfer date of the account ownership
     */
    transferDate?: string | undefined
}

/**
 * Represents the filtering criteria list and the sorting criteria for searching deposit accounts.
 */
export interface DepositAccountSearchCriteria {
    /**
     * The list of filtering criteria.
     */
    filterCriteria?: DepositAccountFilterCriteria[] | undefined
    sortingCriteria?: DepositAccountSortingCriteria | undefined
}

export const DepositAccountSearchCriteria = {
    validate: DepositAccountSearchCriteriaValidator as ValidateFunction<DepositAccountSearchCriteria>,
    get schema() {
        return DepositAccountSearchCriteria.validate.schema
    },
    get errors() {
        return DepositAccountSearchCriteria.validate.errors ?? undefined
    },
    is: (o: unknown): o is DepositAccountSearchCriteria => DepositAccountSearchCriteria.validate(o) === true,
    parse: (o: unknown): { right: DepositAccountSearchCriteria } | { left: DefinedError[] } => {
        if (DepositAccountSearchCriteria.is(o)) {
            return { right: o }
        }
        return { left: (DepositAccountSearchCriteria.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The sorting criteria used for searching deposit accounts.
 */
export interface DepositAccountSortingCriteria {
    /**
     * The field to use to sort the selection. This can be an enumerated value or a custom field using the format [customFieldSetId].[customFieldId].
     */
    field:
        | 'encodedKey'
        | 'id'
        | 'name'
        | 'creationDate'
        | 'activationDate'
        | 'approvedDate'
        | 'lastModifiedDate'
        | 'maturityDate'
        | 'lastSetToArrearsDate'
        | 'closedDate'
        | 'accountHolderName'
        | 'accruedAmounts.interestAccrued'
        | 'accruedAmounts.overdraftInterestAccrued'
        | 'accruedAmounts.technicalOverdraftInterestAccrued'
        | 'maxBalance'
        | 'balances.availableBalance'
        | 'balances.blockedBalance'
        | 'balances.feesDue'
        | 'balances.lockedBalance'
        | 'balances.overdraftAmount'
        | 'balances.technicalOverdraftAmount'
        | 'balances.totalBalance'
        | 'balances.holdBalance'
        | 'balances.overdraftInterestDue'
        | 'assignedBranchKey'
        | 'assignedCentreKey'
        | 'assignedUserKey'
        | 'interestSettings.interestRate'
        | 'currentInterestTier.startingBalance'
        | 'currentInterestTier.endingBalance'
        | 'currentInterestTier.index'
        | 'currentInterestTier.interestRate'
        | 'currentOverdraftInterestTier.startingBalance'
        | 'currentOverdraftInterestTier.endingBalance'
        | 'currentOverdraftInterestTier.index'
        | 'currentOverdraftInterestTier.interestRate'
        | 'internalControls.maxWithdrawalAmount'
        | 'internalControls.recommendedDepositAmount'
        | 'internalControls.targetAmount'
        | 'notes'
        | 'taxApplied'
        | 'taxRate'
        | 'withholdingTaxSourceKey'
        | 'lengthInDays'
        | 'productCategory'
        | 'overdraftInterestSettings.interestRateSettings.interestSpread'
        | 'overdraftInterestSettings.interestRateSettings.interestRate'
        | 'overdraftSettings.allowOverdraft'
        | 'overdraftSettings.overdraftExpiryDate'
        | 'overdraftSettings.overdraftLimit'
        | 'overdraftDaysInArrears'
        | 'overdraftInArrears'
        | 'overdraftAvailableLimit'
    /**
     * The sorting order: `ASC` or `DESC`. The default order is `DESC`.
     */
    order?: 'ASC' | 'DESC' | undefined
}

/**
 * The amounts affected after completing the deposit transaction
 */
export interface DepositAffectedAmounts {
    /**
     * Amount of fees involved in a transaction that affects an account with positive balance
     */
    feesAmount?: number | undefined
    /**
     * In the case of an LOAN_FRACTION_BOUGHT this represent the fraction amount which was bought from another investor
     */
    fractionAmount?: number | undefined
    /**
     * Balance change amount involved in a transaction that affects an account with positive balance
     */
    fundsAmount?: number | undefined
    /**
     * Amount of interest involved in a transaction that affects an account with positive balance
     */
    interestAmount?: number | undefined
    /**
     * The amount of money that was added/subtracted from the account by this transaction as overdraft
     */
    overdraftAmount?: number | undefined
    /**
     * Fees amount involved in a transaction that affects an overdraft
     */
    overdraftFeesAmount?: number | undefined
    /**
     * Interest amount involved in a transaction that affects an overdraft
     */
    overdraftInterestAmount?: number | undefined
    /**
     * The amount of money that was added/subtracted from the account by this transaction as technical overdraft
     */
    technicalOverdraftAmount?: number | undefined
    /**
     * The amount of money that was added/subtracted from the account by this transaction as technical overdraft interest
     */
    technicalOverdraftInterestAmount?: number | undefined
}

/**
 * An amount of predefined fee that was applied or paid on an account.
 */
export interface DepositFee {
    /**
     * The amount of the fee that was applied/paid in the transaction for the given predefined fee.
     */
    amount?: number | undefined
    /**
     * The name of the predefined fee
     */
    name?: string | undefined
    /**
     * The encoded key of the predefined fee, auto generated, unique
     */
    predefinedFeeKey: string
    /**
     * The amount of the taxes on fee that was applied/paid in the transaction.
     */
    taxAmount?: number | undefined
    /**
     * Shows the event that will trigger a fee
     */
    trigger?: 'MANUAL' | 'MONTHLY_FEE' | 'ARBITRARY' | undefined
}

/**
 * The GL accounting rule, it maps a financial resource with a GL account for a specific product (i.e loan or saving).
 */
export interface DepositGLAccountingRule {
    /**
     * The encoded key of the accounting rule, auto generated, unique.
     */
    encodedKey?: string | undefined
    /**
     * General Ledger Financial Resources used to setup the product accounting rules and determine the credit and debit accounts when logging journal entries
     */
    financialResource:
        | 'PORTFOLIO_CONTROL'
        | 'FUND_SOURCE'
        | 'WRITE_OFF_EXPENSE'
        | 'INTEREST_INCOME'
        | 'PAYMENT_HOLIDAY_INTEREST_INCOME'
        | 'TAXES_PAYABLE'
        | 'FEE_INCOME'
        | 'PENALTY_INCOME'
        | 'NEGATIVE_INTEREST_PAYABLE_RECEIVABLE'
        | 'NEGATIVE_INTEREST_PAYABLE'
        | 'INTEREST_RECEIVABLE'
        | 'PAYMENT_HOLIDAY_INTEREST_RECEIVABLE'
        | 'FEE_RECEIVABLE'
        | 'PENALTY_RECEIVABLE'
        | 'TAXES_RECEIVABLE'
        | 'DEFERRED_INTERESTS_INCOME'
        | 'DEFERRED_FEE_INCOME'
        | 'DEFERRED_TAXES'
        | 'DEPOSIT_REFERENCE'
        | 'SAVINGS_CONTROL'
        | 'INTEREST_EXPENSE'
        | 'INTEREST_PAYABLE'
        | 'NEGATIVE_INTEREST_INCOME'
        | 'NEGATIVE_INTEREST_RECEIVABLE'
        | 'OVERDRAFT_PORTFOLIO_CONTROL'
        | 'OVERDRAFT_INTEREST_INCOME'
        | 'OVERDRAFT_WRITE_OFF_EXPENSE'
        | 'OVERDRAFT_INTEREST_RECEIVABLE'
        | 'INTER_BRANCH_TRANSFER'
        | 'INTEREST_FROM_ARREARS_INCOME'
        | 'INTEREST_FROM_ARREARS_RECEIVABLE'
        | 'INTEREST_FROM_ARREARS_WRITE_OFF_EXPENSE'
    /**
     * The encoded key of the account that is mapped to the financialResource
     */
    glAccountKey: string
}

/**
 * Represents the accrued interest amounts for an Interest Applied deposit transaction.
 */
export interface DepositInterestAccruedAmounts {
    /**
     * The amount of positive interest accrued since last interest application/activation date and applied within Interest Applied transaction
     */
    interestAccrued?: number | undefined
    /**
     * The amount of negative interest accrued since last interest application/activation date and applied within Interest Applied transaction
     */
    negativeInterestAccrued?: number | undefined
    /**
     * The amount of overdraft interest accrued since last interest application/activation date and applied within Interest Applied transaction
     */
    overdraftInterestAccrued?: number | undefined
    /**
     * The amount of technical overdraft interest accrued since last interest application/activation date and applied within Interest Applied transaction
     */
    technicalOverdraftInterestAccrued?: number | undefined
}

/**
 * The maturity settings for the product.
 */
export interface DepositMaturitySettings {
    maturityPeriod?: IntegerInterval | undefined
    /**
     * maturity period measurement unit
     */
    maturityPeriodUnit?: 'DAYS' | 'WEEKS' | 'MONTHS' | undefined
}

/**
 * New Account settings for deposit accounts
 */
export interface DepositNewAccountSettings {
    /**
     * The type of generator used for IDs creation.
     */
    idGeneratorType: 'INCREMENTAL_NUMBER' | 'RANDOM_PATTERN'
    /**
     * The pattern that will be used for ID validation (as referred to as an input mask).
     */
    idPattern: string
}

/**
 * Holds the deposit overdraft interest settings
 */
export interface DepositOverdraftInterestSettings {
    /**
     * The value of the index interest rate set or changed in this transaction
     */
    indexInterestRate?: number | undefined
    /**
     * The interest rate that was set or changed in this transaction. Used on product interest rate changes or interest tier switches
     */
    interestRate?: number | undefined
}

/**
 * Holds the deposit overdraft settings for a transaction
 */
export interface DepositOverdraftSettings {
    /**
     * The overdraft limit that was set or changed in this transaction
     */
    overdraftLimit?: number | undefined
}

/**
 * A deposit product defines the terms and constraints on deposit accounts
 */
export interface DepositProduct {
    accountingSettings: DepositProductAccountingSettings
    availabilitySettings?: DepositProductAvailabilitySettings | undefined
    /**
     * Indicates the category that the product belongs to
     */
    category?:
        | 'PERSONAL_DEPOSIT'
        | 'BUSINESS_DEPOSIT'
        | 'DAILY_BANKING_ACCOUNTS'
        | 'BUSINESS_BANKING_ACCOUNTS'
        | 'STORED_VALUE_ACCOUNTS'
        | 'UNCATEGORIZED'
        | undefined
    /**
     * The date this product was created
     */
    creationDate?: string | undefined
    creditArrangementSettings?: CreditArrangementSettings | undefined
    currencySettings?: DepositProductCurrencySettings | undefined
    /**
     * The encoded key of the deposit product, auto generated, unique
     */
    encodedKey?: string | undefined
    feesSettings?: DepositProductFeeSettings | undefined
    /**
     * The id of the product, can be generated and customized, unique
     */
    id: string
    interestSettings?: DepositProductInterestSettings | undefined
    internalControls?: DepositProductInternalControls | undefined
    /**
     * The last date the product was updated
     */
    lastModifiedDate?: string | undefined
    maturitySettings?: DepositMaturitySettings | undefined
    /**
     * The name of the product
     */
    name: string
    newAccountSettings: DepositNewAccountSettings
    /**
     * Some notes/a description about the product
     */
    notes?: string | undefined
    offsetSettings?: DepositProductOffsetSettings | undefined
    overdraftInterestSettings?: OverdraftInterestSettings | undefined
    overdraftSettings?: DepositProductOverdraftSettings | undefined
    /**
     * Indicates the current state of the product
     */
    state: 'ACTIVE' | 'INACTIVE'
    taxSettings?: DepositProductTaxSettings | undefined
    /**
     * Template documents of the product.
     */
    templates?: DocumentTemplate[] | undefined
    /**
     * Indicates the type of product.
     */
    type: 'CURRENT_ACCOUNT' | 'REGULAR_SAVINGS' | 'FIXED_DEPOSIT' | 'SAVINGS_PLAN' | 'INVESTOR_ACCOUNT'
}

export const DepositProduct = {
    validate: DepositProductValidator as ValidateFunction<DepositProduct>,
    get schema() {
        return DepositProduct.validate.schema
    },
    get errors() {
        return DepositProduct.validate.errors ?? undefined
    },
    is: (o: unknown): o is DepositProduct => DepositProduct.validate(o) === true,
    parse: (o: unknown): { right: DepositProduct } | { left: DefinedError[] } => {
        if (DepositProduct.is(o)) {
            return { right: o }
        }
        return { left: (DepositProduct.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Accounting settings, defines the accounting settings for the product.
 */
export interface DepositProductAccountingSettings {
    /**
     * The calculation method used for accounting.
     */
    accountingMethod: 'NONE' | 'CASH' | 'ACCRUAL'
    /**
     * A list of accounting rules for the product.
     */
    accountingRules?: DepositGLAccountingRule[] | undefined
    /**
     * The accounting interest calculation option selected for the product.
     */
    interestAccrualCalculation?: 'NONE' | 'AGGREGATED_AMOUNT' | 'BREAKDOWN_PER_ACCOUNT' | undefined
    /**
     * The interval defined for a product when the interest accrues should be maintained.
     */
    interestAccruedAccountingMethod?: 'NONE' | 'DAILY' | 'END_OF_MONTH' | undefined
}

/**
 * Specify the batch update action details for a deposit product.
 */
export interface DepositProductAction {
    /**
     * The action type to be applied. When UPDATE_INTEREST_SETTINGS action type is used, all the existing deposit accounts will be updated with the latest interest-related fields at the end of day job execution
     */
    action: 'UPDATE_INTEREST_SETTINGS'
}

export const DepositProductAction = {
    validate: DepositProductActionValidator as ValidateFunction<DepositProductAction>,
    get schema() {
        return DepositProductAction.validate.schema
    },
    get errors() {
        return DepositProductAction.validate.errors ?? undefined
    },
    is: (o: unknown): o is DepositProductAction => DepositProductAction.validate(o) === true,
    parse: (o: unknown): { right: DepositProductAction } | { left: DefinedError[] } => {
        if (DepositProductAction.is(o)) {
            return { right: o }
        }
        return { left: (DepositProductAction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the response returned after a batch update action for a deposit product.
 */
export interface DepositProductActionResponse {
    /**
     * The state of the deposit product action
     */
    state?: 'QUEUED' | undefined
}

export const DepositProductActionResponse = {
    validate: DepositProductActionResponseValidator as ValidateFunction<DepositProductActionResponse>,
    get schema() {
        return DepositProductActionResponse.validate.schema
    },
    get errors() {
        return DepositProductActionResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is DepositProductActionResponse => DepositProductActionResponse.validate(o) === true,
    parse: (o: unknown): { right: DepositProductActionResponse } | { left: DefinedError[] } => {
        if (DepositProductActionResponse.is(o)) {
            return { right: o }
        }
        return { left: (DepositProductActionResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Holds information about product availability.
 */
export interface DepositProductAvailabilitySettings {
    /**
     * Holds the entities this product is available for. i.e Individuals
     */
    availableFor?: ('INDIVIDUALS' | 'PURE_GROUPS')[] | undefined
    branchSettings?: BranchSettings | undefined
}

/**
 * Currency settings for the product.
 */
export interface DepositProductCurrencySettings {
    /**
     * Currencies that can be used by accounts of this product
     */
    currencies?: Currency[] | undefined
}

/**
 * Defines fees settings for the product.
 */
export interface DepositProductFeeSettings {
    /**
     * Only if true users will be able to apply fees, for current object, of type 'Other'; these fees can have any amount.
     */
    allowArbitraryFees?: boolean | undefined
    /**
     * List of all fees that can be applied for accounts of this loan product.
     */
    fees?: DepositProductPredefinedFee[] | undefined
}

/**
 * The interest settings, defines constraints regarding interest that will be used on the deposit created based on this product.
 */
export interface DepositProductInterestRateSettings {
    /**
     * If the product supports this option, specify if the interest should be accrued after the account maturity date
     */
    accrueInterestAfterMaturity?: boolean | undefined
    /**
     * Indicator whether the deposit product allows negative values for interest rate
     */
    allowNegativeInterestRate?: boolean | undefined
    /**
     * The encoded key of the interest rate tier, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * Index rate source key.
     */
    indexSourceKey?: string | undefined
    /**
     * The interval used for determining how often is interest charged
     */
    interestChargeFrequency?:
        | 'ANNUALIZED'
        | 'EVERY_MONTH'
        | 'EVERY_FOUR_WEEKS'
        | 'EVERY_WEEK'
        | 'EVERY_DAY'
        | 'EVERY_X_DAYS'
        | undefined
    /**
     * the count of units to apply over the interval
     */
    interestChargeFrequencyCount?: number | undefined
    interestRate?: DecimalInterval | undefined
    /**
     * Interest rate review frequency unit count
     */
    interestRateReviewCount?: number | undefined
    /**
     * Interest rate review frequency measurement unit
     */
    interestRateReviewUnit?: 'DAYS' | 'WEEKS' | 'MONTHS' | undefined
    /**
     * Interest calculation method: fixed or (interest spread + active organization index interest rate)
     */
    interestRateSource?: 'FIXED_INTEREST_RATE' | 'INDEX_INTEREST_RATE' | undefined
    /**
     * The option for how is the interest rate determined when being accrued for an account
     */
    interestRateTerms?: 'FIXED' | 'TIERED' | 'TIERED_PERIOD' | 'TIERED_BAND' | undefined
    /**
     * The list of interest rate tiers available for the current settings instance
     */
    interestRateTiers?: DepositProductInterestRateTier[] | undefined
}

/**
 * Used or TIERED interest rates, holds the values to define how the interest is computed
 */
export interface DepositProductInterestRateTier {
    /**
     * The encoded key of the interest rate tier, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * The top-limit value for the account balance in order to determine if this tier is used or not
     */
    endingBalance?: number | undefined
    /**
     * The top-limit value for the account period since activation in order to determine if this tier is used or not
     */
    endingDay?: number | undefined
    /**
     * The rate used for computing the interest for an account which has the balance less than the ending balance
     */
    interestRate: number
}

/**
 * The interest settings, defines constraints regarding interest that will be used on the deposit account based on this product.
 */
export interface DepositProductInterestSettings {
    /**
     * Whether locked accounts still collect Interest or not
     */
    collectInterestWhenLocked?: boolean | undefined
    /**
     * How many days in a year should be used for interest calculations
     */
    daysInYear?: 'ACTUAL_365_FIXED' | 'ACTUAL_360' | 'ACTUAL_ACTUAL_ISDA' | 'E30_360' | 'E30_42_365' | 'BUS_252' | undefined
    /**
     * The balance which is used for the Interest calculation
     */
    interestCalculationBalance?:
        | 'MINIMUM'
        | 'AVERAGE'
        | 'END_OF_DAY'
        | 'MINIMUM_TO_END_OF_DAY'
        | 'FRENCH_INTEREST_ACCRUAL'
        | undefined
    /**
     * The date when the accounts under this product, will no longer have interest gains provided
     */
    interestGainsProvidedEndDate?: string | undefined
    /**
     * The date when the accounts of this product will start to have interest gains provided. Starting with this date 0 interest rate is enforced on the accounts of this product.
     */
    interestGainsProvidedStartDate?: string | undefined
    /**
     * If interest should be payed into the deposit account
     */
    interestPaidIntoAccount?: boolean | undefined
    interestPaymentSettings?: InterestPaymentSettings | undefined
    interestRateSettings?: DepositProductInterestRateSettings | undefined
    /**
     * The maximum balance used for Interest calculation
     */
    maximumBalance?: number | undefined
}

/**
 * Constraints and automated actions and that will be applied on the accounts.
 */
export interface DepositProductInternalControls {
    /**
     * Specifies the number of days for an account to be fully paid in order to auto close it.
     */
    dormancyPeriodDays?: number | undefined
    /**
     * Max amount per withdrawal
     */
    maxWithdrawalAmount?: number | undefined
    openingBalance?: AmountDecimalInterval | undefined
    /**
     * Recommended amount for a deposit
     */
    recommendedDepositAmount?: number | undefined
}

/**
 * The offset settings, holds information about offset.
 */
export interface DepositProductOffsetSettings {
    /**
     * Specify if the product allow to create accounts which can be used as offset for loans
     */
    allowOffset?: boolean | undefined
}

/**
 * The overdraft interest settings, defines constraints regarding interest that will be used on the account created based on this product.
 */
export interface DepositProductOverdraftInterestRateSettings {
    /**
     * Index rate source key.
     */
    indexSourceKey?: string | undefined
    /**
     * The interval used for determining how often is interest charged
     */
    interestChargeFrequency?:
        | 'ANNUALIZED'
        | 'EVERY_MONTH'
        | 'EVERY_FOUR_WEEKS'
        | 'EVERY_WEEK'
        | 'EVERY_DAY'
        | 'EVERY_X_DAYS'
        | undefined
    /**
     * the count of units to apply over the interval
     */
    interestChargeFrequencyCount?: number | undefined
    interestRate?: DecimalInterval | undefined
    /**
     * Interest rate review frequency unit count
     */
    interestRateReviewCount?: number | undefined
    /**
     * Interest rate review frequency measurement unit
     */
    interestRateReviewUnit?: 'DAYS' | 'WEEKS' | 'MONTHS' | undefined
    /**
     * Interest calculation method: fixed or (interest spread + active organization index interest rate)
     */
    interestRateSource?: 'FIXED_INTEREST_RATE' | 'INDEX_INTEREST_RATE' | undefined
    /**
     * The option for how is the interest rate determined when being accrued for an account
     */
    interestRateTerms?: 'FIXED' | 'TIERED' | 'TIERED_PERIOD' | 'TIERED_BAND' | undefined
    /**
     * The list of interest rate tiers available for the current settings instance
     */
    interestRateTiers?: DepositProductOverdraftInterestRateTier[] | undefined
}

/**
 * Used for TIERED interest rates, holds the values to define how the interest is computed
 */
export interface DepositProductOverdraftInterestRateTier {
    /**
     * The encoded key of the interest rate tier, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * The top-limit value for the account balance in order to determine if this tier is used or not
     */
    endingBalance?: number | undefined
    /**
     * The rate used for computing the interest for an account which has the balance less than the ending balance
     */
    interestRate: number
}

/**
 * The overdraft settings of the deposit product
 */
export interface DepositProductOverdraftSettings {
    /**
     * Whether the accounts for this product may have overdraft
     */
    allowOverdraft?: boolean | undefined
    /**
     * Whether the accounts for this product may have technical overdraft
     */
    allowTechnicalOverdraft?: boolean | undefined
    /**
     * How much money may be taken out for the account to go negative
     */
    maxOverdraftLimit?: number | undefined
}

/**
 * The response representation of the PredefinedFee. Represents a fee with a defined name and a fixed value.
 */
export interface DepositProductPredefinedFee {
    /**
     * A list of accounting rules defined for this fee. If null, product default rules are selected.
     */
    accountingRules?: DepositGLAccountingRule[] | undefined
    /**
     * The amount of the fee
     */
    amount?: number | undefined
    /**
     * External function
     */
    amountCalculationFunctionName?: string | undefined
    /**
     * The amount from which the fee is calculated using percentageAmount
     */
    amountCalculationMethod?: 'FLAT' | 'MAMBU_FUNCTION' | undefined
    /**
     * Shows when a fee should be applied; to be used with monthly deposit fees
     */
    applyDateMethod?: 'MONTHLY_FROM_ACTIVATION' | 'FIRST_OF_EVERY_MONTH' | undefined
    /**
     * Shows the creation date of the fee
     */
    creationDate?: string | undefined
    /**
     * The encoded key of the predefined fee, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * The type of fee application when disbursement is applied
     */
    feeApplication: 'REQUIRED' | 'OPTIONAL'
    /**
     * The id of the fee
     */
    id?: string | undefined
    /**
     * Shows the last modified date of the fee
     */
    lastModifiedDate?: string | undefined
    /**
     * The name of the fee
     */
    name?: string | undefined
    /**
     * Indicates the state of the fee
     */
    state: 'ACTIVE' | 'INACTIVE'
    /**
     * Shows the event that will trigger a fee
     */
    trigger: 'MANUAL' | 'MONTHLY_FEE' | 'ARBITRARY'
}

/**
 * Tax settings, defines some settings for taxes on the loan product
 */
export interface DepositProductTaxSettings {
    /**
     * Whether withholding taxes are enabled for this product or not
     */
    withholdingTaxEnabled?: boolean | undefined
}

/**
 * Transaction to be executed.
 */
export interface DepositsTransaction {
    deposit?: DepositTransactionInput | undefined
    fee?: FeeAppliedDepositTransactionInput | undefined
    withdrawal?: WithdrawalDepositTransactionInput | undefined
}

/**
 * The taxes applied within a transaction
 */
export interface DepositTaxes {
    /**
     * The tax rate that was set or changed in this transaction
     */
    taxRate?: number | undefined
}

/**
 * The deposit transaction terms
 */
export interface DepositTerms {
    interestSettings?: DepositTransactionInterestSettings | undefined
    overdraftInterestSettings?: DepositOverdraftInterestSettings | undefined
    overdraftSettings?: DepositOverdraftSettings | undefined
}

/**
 * Represents the action performed on an Deposit Account after which the account's amount changes its value.
 */
export interface DepositTransaction {
    accountBalances?: DepositTransactionBalances | undefined
    /**
     * The key of the deposit transaction where the adjustment for this transaction was made (if any adjustment was involved)
     */
    adjustmentTransactionKey?: string | undefined
    affectedAmounts?: DepositAffectedAmounts | undefined
    /**
     * How much was added/removed in account
     */
    amount?: number | undefined
    /**
     * The block fund id associated with the transaction
     */
    blockId?: string | undefined
    /**
     * The date when corresponding JE is booked (as Organization Time)
     */
    bookingDate?: string | undefined
    /**
     * The branch where the transaction was performed
     */
    branchKey?: string | undefined
    cardTransaction?: CardTransaction | undefined
    /**
     * The center where the transaction was performed
     */
    centreKey?: string | undefined
    /**
     * The date when this deposit transaction was created
     */
    creationDate?: string | undefined
    /**
     * The currency in which this transaction was posted
     */
    currencyCode?: string | undefined
    /**
     * Whether the custom fields of the transaction are archived
     */
    customFieldsArchived?: boolean | undefined
    /**
     * The encoded key of the deposit transaction, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * The external id of the deposit transaction, customizable, unique
     */
    externalId?: string | undefined
    /**
     * All the amounts that have been applied or paid within this transaction and involved predefined fees
     */
    fees?: DepositFee[] | undefined
    /**
     * The external id of an account authorization hold
     */
    holdExternalReferenceId?: string | undefined
    /**
     * The id of the deposit transaction, auto generated, unique
     */
    id?: string | undefined
    interestAccruedAmounts?: DepositInterestAccruedAmounts | undefined
    /**
     * The migration event encoded key associated with this deposit account. If this account was imported, track which 'migration event' they came from
     */
    migrationEventKey?: string | undefined
    /**
     * Extra notes about this deposit transaction
     */
    notes?: string | undefined
    /**
     * The encodedKey of the transaction that was adjusted as part of this one. Available only for adjustment transactions
     */
    originalTransactionKey?: string | undefined
    /**
     * The key of the parent deposit account
     */
    parentAccountKey?: string | undefined
    paymentDetails?: PaymentDetails | undefined
    /**
     * The payment order id of the deposit transaction, customizable
     */
    paymentOrderId?: string | undefined
    taxes?: DepositTaxes | undefined
    terms?: DepositTerms | undefined
    /**
     * The till key associated with this transaction
     */
    tillKey?: string | undefined
    transactionDetails?: TransactionDetails | undefined
    transferDetails?: TransferDetails | undefined
    /**
     * The type of the deposit transaction
     */
    type?:
        | 'IMPORT'
        | 'WRITE_OFF'
        | 'WRITE_OFF_ADJUSTMENT'
        | 'DEPOSIT'
        | 'ADJUSTMENT'
        | 'WITHDRAWAL'
        | 'WITHDRAWAL_ADJUSTMENT'
        | 'CARD_TRANSACTION_REVERSAL'
        | 'CARD_TRANSACTION_REVERSAL_ADJUSTMENT'
        | 'TRANSFER'
        | 'TRANSFER_ADJUSTMENT'
        | 'FEE_APPLIED'
        | 'FEE_ADJUSTED'
        | 'FEES_DUE_REDUCED'
        | 'INTEREST_APPLIED'
        | 'INTEREST_APPLIED_ADJUSTMENT'
        | 'NET_DIFF_INTEREST'
        | 'FEE_REDUCTION_ADJUSTMENT'
        | 'WITHHOLDING_TAX'
        | 'WITHHOLDING_TAX_ADJUSTMENT'
        | 'INTEREST_RATE_CHANGED'
        | 'OVERDRAFT_INTEREST_RATE_CHANGED'
        | 'OVERDRAFT_LIMIT_CHANGED'
        | 'BRANCH_CHANGED'
        | 'ACCOUNT_HOLDER_CHANGED'
        | 'LOAN_FUNDED'
        | 'LOAN_FUNDED_ADJUSTMENT'
        | 'LOAN_REPAID'
        | 'LOAN_REPAID_ADJUSTMENT'
        | 'LOAN_FRACTION_BOUGHT'
        | 'LOAN_FRACTION_BOUGHT_ADJUSTMENT'
        | 'LOAN_FRACTION_SOLD'
        | 'LOAN_FRACTION_SOLD_ADJUSTMENT'
        | 'SEIZED_AMOUNT'
        | undefined
    /**
     * The person that performed the transaction
     */
    userKey?: string | undefined
    /**
     * Date of the entry (eg date of repayment or disbursal, etc.) (as Organization Time)
     */
    valueDate?: string | undefined
}

export const DepositTransaction = {
    validate: DepositTransactionValidator as ValidateFunction<DepositTransaction>,
    get schema() {
        return DepositTransaction.validate.schema
    },
    get errors() {
        return DepositTransaction.validate.errors ?? undefined
    },
    is: (o: unknown): o is DepositTransaction => DepositTransaction.validate(o) === true,
    parse: (o: unknown): { right: DepositTransaction } | { left: DefinedError[] } => {
        if (DepositTransaction.is(o)) {
            return { right: o }
        }
        return { left: (DepositTransaction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Contains the details of the transaction adjustment
 */
export interface DepositTransactionAdjustmentDetails {
    /**
     * Date when the adjustment transaction is logged into accounting. Can be null. Available only for DEPOSIT and WITHDRAWAL
     */
    bookingDate?: string | undefined
    /**
     * Notes detailing why the transaction is adjusted
     */
    notes?: string | undefined
}

export const DepositTransactionAdjustmentDetails = {
    validate: DepositTransactionAdjustmentDetailsValidator as ValidateFunction<DepositTransactionAdjustmentDetails>,
    get schema() {
        return DepositTransactionAdjustmentDetails.validate.schema
    },
    get errors() {
        return DepositTransactionAdjustmentDetails.validate.errors ?? undefined
    },
    is: (o: unknown): o is DepositTransactionAdjustmentDetails => DepositTransactionAdjustmentDetails.validate(o) === true,
    parse: (o: unknown): { right: DepositTransactionAdjustmentDetails } | { left: DefinedError[] } => {
        if (DepositTransactionAdjustmentDetails.is(o)) {
            return { right: o }
        }
        return { left: (DepositTransactionAdjustmentDetails.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The balances changed within a transaction.
 */
export interface DepositTransactionBalances {
    /**
     * The running balance owed by deposit
     */
    totalBalance?: number | undefined
}

/**
 * Represents the request payload for creating a deposit transactions when sent in bulk.
 */
export interface DepositTransactionBulkableInputDTO {
    /**
     * The id of the account
     */
    accountId: string
    /**
     * The amount that was added to an account
     */
    amount: number
    /**
     * The external id of the deposit transaction, customizable, unique
     */
    externalId?: string | undefined
    /**
     * The external id of an account authorization hold
     */
    holdExternalReferenceId?: string | undefined
    /**
     * Extra notes about this deposit transaction
     */
    notes?: string | undefined
    paymentDetails?: PaymentDetails | undefined
    /**
     * The payment order id of the deposit transaction, customizable
     */
    paymentOrderId?: string | undefined
    /**
     * Flag indicating that a maximum balance validation should be skipped
     */
    skipMaximumBalanceValidation?: boolean | undefined
    transactionDetails?: TransactionDetailsInput | undefined
}

/**
 * The unit that composes the list used for Deposit transactions client directed searching
 */
export interface DepositTransactionFilterCriteria {
    field:
        | 'encodedKey'
        | 'id'
        | 'externalId'
        | 'holdExternalReferenceId'
        | 'productID'
        | 'currencyCode'
        | 'branchID'
        | 'branchKey'
        | 'centreID'
        | 'centreKey'
        | 'tillID'
        | 'tillKey'
        | 'amount'
        | 'affectedAmounts.fundsAmount'
        | 'affectedAmounts.interestAmount'
        | 'affectedAmounts.feesAmount'
        | 'parentAccountKey'
        | 'parentAccountID'
        | 'productTypeKey'
        | 'paymentOrderId'
        | 'userKey'
        | 'adjustmentTransactionID'
        | 'adjustmentTransactionKey'
        | 'originalTransactionKey'
        | 'originalTransactionID'
        | 'transactionDetails.transactionChannelKey'
        | 'transactionDetails.transactionChannelId'
        | 'type'
        | 'creationDate'
        | 'accountBalances.totalBalance'
        | 'valueDate'
        | 'taxes.taxRate'
        | 'terms.interestSettings.interestRate'
        | 'fees.trigger'
        | 'fees.name'
        | 'fees.predefinedFeeKey'
        | 'wasAdjusted'
        | 'typeIsAdjustment'
        | 'affectedAmounts.overdraftAmount'
        | 'affectedAmounts.overdraftInterestAmount'
        | 'affectedAmounts.overdraftFeesAmount'
        | 'affectedAmounts.technicalOverdraftAmount'
        | 'affectedAmounts.technicalOverdraftInterestAmount'
        | 'terms.overdraftInterestSettings.interestRate'
        | 'terms.overdraftInterestSettings.indexInterestRate'
        | string
    /**
     * | **Operator**                | **Affected values**  | **Available for**                                                    |
     * |---------------               |----------------------|----------------------------------------------------------------------|
     * | EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |
     * | EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |
     * | MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |
     * | ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | STARTS_WITH                  | ONE_VALUE            | STRING                                                               |
     * | STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |
     * | IN                           | LIST                 | ENUM,KEY                                                             |
     * | TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |
     * | EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     * | NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     */
    operator:
        | 'EQUALS'
        | 'EQUALS_CASE_SENSITIVE'
        | 'DIFFERENT_THAN'
        | 'MORE_THAN'
        | 'LESS_THAN'
        | 'BETWEEN'
        | 'ON'
        | 'AFTER'
        | 'AFTER_INCLUSIVE'
        | 'BEFORE'
        | 'BEFORE_INCLUSIVE'
        | 'STARTS_WITH'
        | 'STARTS_WITH_CASE_SENSITIVE'
        | 'IN'
        | 'TODAY'
        | 'THIS_WEEK'
        | 'THIS_MONTH'
        | 'THIS_YEAR'
        | 'LAST_DAYS'
        | 'EMPTY'
        | 'NOT_EMPTY'
    /**
     * The second value to match the searching criteria, when the `BETWEEN` operator is used.
     */
    secondValue?: string | undefined
    /**
     * The value to match the searching criteria.
     */
    value?: string | undefined
    /**
     * List of values when the `IN` operator is used.
     */
    values?: string[] | undefined
}

/**
 * Represents the request payload for creating a transaction of type DEPOSIT.
 */
export interface DepositTransactionInput {
    /**
     * The amount that was added to an account
     */
    amount: number
    /**
     * The date of Journal Entry (as Organization Time)
     */
    bookingDate?: string | undefined
    /**
     * The external id of the deposit transaction, customizable, unique
     */
    externalId?: string | undefined
    /**
     * The external id of an account authorization hold
     */
    holdExternalReferenceId?: string | undefined
    /**
     * Extra notes about this deposit transaction
     */
    notes?: string | undefined
    paymentDetails?: PaymentDetails | undefined
    /**
     * The payment order id of the deposit transaction, customizable
     */
    paymentOrderId?: string | undefined
    /**
     * Flag indicating that a maximum balance validation should be skipped
     */
    skipMaximumBalanceValidation?: boolean | undefined
    transactionDetails?: TransactionDetailsInput | undefined
    /**
     * The entry date of the deposit (as Organization Time)
     */
    valueDate?: string | undefined
}

export const DepositTransactionInput = {
    validate: DepositTransactionInputValidator as ValidateFunction<DepositTransactionInput>,
    get schema() {
        return DepositTransactionInput.validate.schema
    },
    get errors() {
        return DepositTransactionInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is DepositTransactionInput => DepositTransactionInput.validate(o) === true,
    parse: (o: unknown): { right: DepositTransactionInput } | { left: DefinedError[] } => {
        if (DepositTransactionInput.is(o)) {
            return { right: o }
        }
        return { left: (DepositTransactionInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The interest settings, holds all the properties regarding interests for the deposit account
 */
export interface DepositTransactionInterestSettings {
    /**
     * The value of the index interest rate set or changed in this transaction
     */
    indexInterestRate?: number | undefined
    /**
     * The interest rate for the deposit account
     */
    interestRate?: number | undefined
}

/**
 * Wrapper that holds a list of filtering criteria and a sorting criteria for Deposit transaction client directed query
 */
export interface DepositTransactionSearchCriteria {
    /**
     * The list of filtering criteria
     */
    filterCriteria: DepositTransactionFilterCriteria[]
    sortingCriteria?: DepositTransactionSortingCriteria | undefined
}

export const DepositTransactionSearchCriteria = {
    validate: DepositTransactionSearchCriteriaValidator as ValidateFunction<DepositTransactionSearchCriteria>,
    get schema() {
        return DepositTransactionSearchCriteria.validate.schema
    },
    get errors() {
        return DepositTransactionSearchCriteria.validate.errors ?? undefined
    },
    is: (o: unknown): o is DepositTransactionSearchCriteria => DepositTransactionSearchCriteria.validate(o) === true,
    parse: (o: unknown): { right: DepositTransactionSearchCriteria } | { left: DefinedError[] } => {
        if (DepositTransactionSearchCriteria.is(o)) {
            return { right: o }
        }
        return { left: (DepositTransactionSearchCriteria.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The sorting criteria used for Deposit transactions client directed query
 */
export interface DepositTransactionSortingCriteria {
    /**
     * The field to use to sort the selection. The field can be an enumerated value or a custom field using the format [customFieldSetId].[customFieldId].
     */
    field:
        | 'id'
        | 'externalId'
        | 'parentAccountId'
        | 'productId'
        | 'valueDate'
        | 'creationDate'
        | 'amount'
        | 'branchId'
        | 'centreId'
        | 'tillId'
        | 'fees.name'
        | 'transactionDetails.transactionChannelId'
        | 'taxes.taxRate'
        | 'terms.interestSettings.interestRate'
        | 'terms.overdraftInterestSettings.interestRate'
        | 'terms.overdraftSettings.overdraftLimit'
        | 'affectedAmounts.interestAmount'
        | 'affectedAmounts.feesAmount'
        | 'accountBalances.totalBalance'
    /**
     * The sorting order: `ASC` or `DESC`. The default order is `DESC`.
     */
    order?: 'ASC' | 'DESC' | undefined
}

/**
 * The the disbursement details it holds the information related to the disbursement details as disbursement date, first repayment date, disbursement fees.
 */
export interface DisbursementDetails {
    /**
     * The activation date, the date when the disbursement actually took place.
     */
    disbursementDate?: string | undefined
    /**
     * The encoded key of the disbursement details, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * The date of the expected disbursement.Stored as Organization Time.
     */
    expectedDisbursementDate?: string | undefined
    /**
     * List of fees that should be applied at the disbursement time.
     */
    fees?: CustomPredefinedFee[] | undefined
    /**
     * The date of the expected first repayment. Stored as Organization Time.
     */
    firstRepaymentDate?: string | undefined
    transactionDetails?: LoanTransactionDetails | undefined
}

/**
 * The the disbursement details it holds the information related to the disbursement details as disbursement date, first repayment date, disbursement fees.
 */
export interface DisbursementDetailsForSchedulePreview {
    /**
     * The date of the expected disbursement.Stored as Organization Time.
     */
    expectedDisbursementDate?: string | undefined
    /**
     * List of fees that should be applied at the disbursement time.
     */
    fees?: CustomPredefinedFee[] | undefined
    /**
     * The date of the expected first repayment. Stored as Organization Time.
     */
    firstRepaymentDate?: string | undefined
}

/**
 * The input representation of a loan transaction when making a disbursement
 */
export interface DisbursementLoanTransactionInput {
    /**
     * The amount to disburse
     */
    amount?: number | undefined
    /**
     * The date when disbursement is logged into accounting)
     */
    bookingDate?: string | undefined
    /**
     * The external id of the disbursement transaction. Customizable and unique
     */
    externalId?: string | undefined
    /**
     * The list of the fees to apply
     */
    fees?: FeeInput[] | undefined
    /**
     * The date of the first repayment for the loan account (as Organization Time)
     */
    firstRepaymentDate?: string | undefined
    /**
     * Extra notes related to disbursement action or transaction
     */
    notes?: string | undefined
    /**
     * The currency for the disbursement transaction
     */
    originalCurrencyCode?: string | undefined
    /**
     * Indicates whether the validFrom dates from Adjustable Interest Rates can be shifted automatically or not
     */
    shiftAdjustableInterestPeriods?: boolean | undefined
    transactionDetails?: TransactionDetailsInput | undefined
    transferDetails?: DisbursementTransferDetailsInput | undefined
    /**
     * The date of the disbursal (as Organization Time)
     */
    valueDate?: string | undefined
}

export const DisbursementLoanTransactionInput = {
    validate: DisbursementLoanTransactionInputValidator as ValidateFunction<DisbursementLoanTransactionInput>,
    get schema() {
        return DisbursementLoanTransactionInput.validate.schema
    },
    get errors() {
        return DisbursementLoanTransactionInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is DisbursementLoanTransactionInput => DisbursementLoanTransactionInput.validate(o) === true,
    parse: (o: unknown): { right: DisbursementLoanTransactionInput } | { left: DefinedError[] } => {
        if (DisbursementLoanTransactionInput.is(o)) {
            return { right: o }
        }
        return { left: (DisbursementLoanTransactionInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the input for the transfer details for a disbursement transaction
 */
export interface DisbursementTransferDetailsInput {
    /**
     * The id of the linked deposit account
     */
    linkedAccountId?: string | undefined
    /**
     * The encoded key of the linked deposit account
     */
    linkedAccountKey?: string | undefined
}

/**
 * Holds information regarding the documents uploaded as attachments
 */
export interface Document {
    /**
     * The creation date of the document, stored as UTC
     */
    creationDate?: string | undefined
    /**
     * The document encodedKey
     */
    encodedKey?: string | undefined
    /**
     * The original file name of the document
     */
    fileName?: string | undefined
    /**
     * The file size of the document
     */
    fileSize?: number | undefined
    /**
     * The document id
     */
    id: number
    /**
     * The last modified date of the document, stored as UTC
     */
    lastModifiedDate?: string | undefined
    /**
     * Location where the document can be found, eg /myfiles/mypicture.jpeg
     */
    location?: string | undefined
    /**
     * The name of the document
     */
    name: string
    /**
     * Detailed notes about the document
     */
    notes?: string | undefined
    /**
     * Represents the holder of this document. If null, means nobody is the owner of this document
     */
    ownerKey?: string | undefined
    /**
     * Determines the owner type of the document
     */
    ownerType?:
        | 'CLIENT'
        | 'GROUP'
        | 'LOAN_PRODUCT'
        | 'SAVINGS_PRODUCT'
        | 'CENTRE'
        | 'BRANCH'
        | 'USER'
        | 'LOAN_ACCOUNT'
        | 'DEPOSIT_ACCOUNT'
        | 'ID_DOCUMENT'
        | 'LINE_OF_CREDIT'
        | 'GL_JOURNAL_ENTRY'
        | undefined
    /**
     * The extension of the document
     */
    type: string
}

export const Document = {
    validate: DocumentValidator as ValidateFunction<Document>,
    get schema() {
        return Document.validate.schema
    },
    get errors() {
        return Document.validate.errors ?? undefined
    },
    is: (o: unknown): o is Document => Document.validate(o) === true,
    parse: (o: unknown): { right: Document } | { left: DefinedError[] } => {
        if (Document.is(o)) {
            return { right: o }
        }
        return { left: (Document.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Template documents of the product.
 */
export interface DocumentTemplate {
    /**
     * The creation date of the document
     */
    creationDate?: string | undefined
    /**
     * The document encodedKey
     */
    encodedKey?: string | undefined
    /**
     * The last modified date of the document
     */
    lastModifiedDate?: string | undefined
    /**
     * The name the document
     */
    name?: string | undefined
    /**
     * The type of the template
     */
    type?: 'ACCOUNT' | 'TRANSACTION' | 'ACCOUNT_WITH_TRANSACTIONS' | undefined
}

/**
 * Represents a duplicate constraint which needs to apply when saving entities
 */
export interface DuplicateFieldConstraint {
    /**
     * The check will be performed if the field is true
     */
    active?: boolean | undefined
    /**
     * The ENUM data field when the field is an ENUM
     */
    dataField?: string | undefined
    /**
     * The type of the owner (entity) to whom a data field belongs to
     */
    dataItemType?:
        | 'LOANS'
        | 'SAVINGS'
        | 'CLIENT'
        | 'CLIENT_ROLE'
        | 'GROUP'
        | 'GROUP_ROLE'
        | 'TRANSACTION'
        | 'JOURNAL_ENTRY'
        | 'INTEREST_ACCRUAL_BREAKDOWN'
        | 'BRANCH'
        | 'CENTRE'
        | 'USER'
        | 'LOAN_PRODUCT'
        | 'SAVINGS_PRODUCT'
        | 'NOTIFICATION_MESSAGE'
        | 'NOTIFICATION_TEMPLATE'
        | 'REPAYMENT'
        | 'REPAYMENT_COLLECTION'
        | 'ACTIVITY'
        | 'LINE_OF_CREDIT'
        | 'IDENTIFICATION_DOCUMENT'
        | 'ATTACHMENT'
        | 'CURRENCY'
        | 'PRODUCT'
        | 'REVENUE'
        | 'EXPENSE'
        | 'OUTSTANDING_PORTFOLIO_ACCOUNTS'
        | 'OUTSTANDING_PORTFOLIO_AMOUNTS'
        | 'CREATED_ACCOUNTS'
        | 'WRITTEN_OFF_LOANS'
        | 'DISBURSED_LOANS'
        | 'LOAN_GROUP'
        | 'TRANCHE'
        | 'DISBURSEMENT_DETAILS'
        | 'TRANSACTION_DETAILS'
        | 'TRANSACTION_CHANNEL'
        | 'CUSTOM_PREDEFINED_FEE'
        | 'CUSTOM_FIELD_SELECTION'
        | 'PREDEFINED_FEE'
        | 'LOAN_TRANSACTION'
        | 'SAVINGS_TRANSACTION'
        | 'CARD_TRANSACTION_REVERSAL'
        | 'COMPOSED_TRANSACTIONS'
        | 'UNION_TRANSACTIONS'
        | 'INVESTOR_FUND'
        | 'PRINCIPAL_PAYMENT_SETTINGS'
        | 'LOAN_ACCOUNT_GUARANTY'
        | 'TASK'
        | 'DOCUMENT_TEMPLATE'
        | 'INDEX_RATE'
        | 'INDEX_RATE_SOURCE'
        | 'INTEREST_PRODUCT_SETTINGS'
        | 'MCC_EXPIRATION'
        | 'PRODUCT_ARREARS_SETTINGS'
        | 'ACCOUNT_INTEREST_RATE_SETTINGS'
        | 'LENDING_ACCOUNT_CONTRACT'
        | 'REVOLVING_ACCOUNT'
        | 'LENDING_PRODUCT_CONTRACT'
        | undefined
    /**
     * The encoded key of the duplicate field constraint, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * Used for creating an AND clause between constraints
     */
    groupIndex?: number | undefined
}

export type EditScheduleRequest = Installment[]

export const EditScheduleRequest = {
    validate: EditScheduleRequestValidator as ValidateFunction<EditScheduleRequest>,
    get schema() {
        return EditScheduleRequest.validate.schema
    },
    get errors() {
        return EditScheduleRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is EditScheduleRequest => EditScheduleRequest.validate(o) === true,
    parse: (o: unknown): { right: EditScheduleRequest } | { left: DefinedError[] } => {
        if (EditScheduleRequest.is(o)) {
            return { right: o }
        }
        return { left: (EditScheduleRequest.errors ?? []) as DefinedError[] }
    },
} as const

export type EditTranchesRequest = LoanTranche[]

export const EditTranchesRequest = {
    validate: EditTranchesRequestValidator as ValidateFunction<EditTranchesRequest>,
    get schema() {
        return EditTranchesRequest.validate.schema
    },
    get errors() {
        return EditTranchesRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is EditTranchesRequest => EditTranchesRequest.validate(o) === true,
    parse: (o: unknown): { right: EditTranchesRequest } | { left: DefinedError[] } => {
        if (EditTranchesRequest.is(o)) {
            return { right: o }
        }
        return { left: (EditTranchesRequest.errors ?? []) as DefinedError[] }
    },
} as const

export type EditTranchesResponse = LoanTranche[]

export const EditTranchesResponse = {
    validate: EditTranchesResponseValidator as ValidateFunction<EditTranchesResponse>,
    get schema() {
        return EditTranchesResponse.validate.schema
    },
    get errors() {
        return EditTranchesResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is EditTranchesResponse => EditTranchesResponse.validate(o) === true,
    parse: (o: unknown): { right: EditTranchesResponse } | { left: DefinedError[] } => {
        if (EditTranchesResponse.is(o)) {
            return { right: o }
        }
        return { left: (EditTranchesResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type EditTransactionDetailsRequest = PatchOperation[]

export const EditTransactionDetailsRequest = {
    validate: EditTransactionDetailsRequestValidator as ValidateFunction<EditTransactionDetailsRequest>,
    get schema() {
        return EditTransactionDetailsRequest.validate.schema
    },
    get errors() {
        return EditTransactionDetailsRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is EditTransactionDetailsRequest => EditTransactionDetailsRequest.validate(o) === true,
    parse: (o: unknown): { right: EditTransactionDetailsRequest } | { left: DefinedError[] } => {
        if (EditTransactionDetailsRequest.is(o)) {
            return { right: o }
        }
        return { left: (EditTransactionDetailsRequest.errors ?? []) as DefinedError[] }
    },
} as const

type EnabledComponents = 'LOANS' | 'DEPOSITS' | 'BRANCHES' | 'CENTRES' | 'CLIENTS' | 'GROUPS' | 'ACCOUNTING' | 'CREDIT_OFFICERS'

export interface ErrorResponse {
    errors?: RestError[] | undefined
}

export const ErrorResponse = {
    validate: ErrorResponseValidator as ValidateFunction<ErrorResponse>,
    get schema() {
        return ErrorResponse.validate.schema
    },
    get errors() {
        return ErrorResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is ErrorResponse => ErrorResponse.validate(o) === true,
    parse: (o: unknown): { right: ErrorResponse } | { left: DefinedError[] } => {
        if (ErrorResponse.is(o)) {
            return { right: o }
        }
        return { left: (ErrorResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Model representation of an exchange rates.
 */
export interface ExchangeRate {
    /**
     * The buy exchange rate.
     */
    buyRate?: number | undefined
    /**
     * The exchange rate applies starting with this date.
     */
    endDate?: string | undefined
    /**
     * Organisation currency code
     */
    fromCurrencyCode?: string | undefined
    /**
     * The sell exchange rate.
     */
    sellRate?: number | undefined
    /**
     * The exchange rate applies starting with this date.
     */
    startDate?: string | undefined
    /**
     * Foreign currency code
     */
    toCurrencyCode?: string | undefined
    /**
     * The key for the user that last modified the exchange rate.
     */
    userKey?: string | undefined
}

export const ExchangeRate = {
    validate: ExchangeRateValidator as ValidateFunction<ExchangeRate>,
    get schema() {
        return ExchangeRate.validate.schema
    },
    get errors() {
        return ExchangeRate.validate.errors ?? undefined
    },
    is: (o: unknown): o is ExchangeRate => ExchangeRate.validate(o) === true,
    parse: (o: unknown): { right: ExchangeRate } | { left: DefinedError[] } => {
        if (ExchangeRate.is(o)) {
            return { right: o }
        }
        return { left: (ExchangeRate.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Model representation of an exchange rate inputs for filtering.
 */
export interface ExchangeRateInput {
    /**
     * The buy exchange rate.
     */
    buyRate: number
    /**
     * The sell exchange rate.
     */
    sellRate: number
    /**
     * The exchange rate applies starting with this date.
     */
    startDate?: string | undefined
}

export const ExchangeRateInput = {
    validate: ExchangeRateInputValidator as ValidateFunction<ExchangeRateInput>,
    get schema() {
        return ExchangeRateInput.validate.schema
    },
    get errors() {
        return ExchangeRateInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is ExchangeRateInput => ExchangeRateInput.validate(o) === true,
    parse: (o: unknown): { right: ExchangeRateInput } | { left: DefinedError[] } => {
        if (ExchangeRateInput.is(o)) {
            return { right: o }
        }
        return { left: (ExchangeRateInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * An amount of predefined fee that was applied or paid on an account.
 */
export interface Fee {
    /**
     * The amount of the fee that was applied/paid in the transaction for the given predefined fee.
     */
    amount?: number | undefined
    /**
     * The name of the predefined fee
     */
    name?: string | undefined
    /**
     * The encoded key of the predefined fee, auto generated, unique
     */
    predefinedFeeKey: string
    /**
     * The amount of the taxes on fee that was applied/paid in the transaction.
     */
    taxAmount?: number | undefined
    /**
     * Shows the event that will trigger a fee
     */
    trigger?:
        | 'MANUAL'
        | 'MANUAL_PLANNED'
        | 'DISBURSEMENT'
        | 'CAPITALIZED_DISBURSEMENT'
        | 'UPFRONT_DISBURSEMENT'
        | 'LATE_REPAYMENT'
        | 'PAYMENT_DUE'
        | 'PAYMENT_DUE_APPLIED_ON_DUE_DATES'
        | 'ARBITRARY'
        | 'IOF'
        | 'EARLY_REPAYMENT_CHARGE'
        | undefined
}

/**
 * Represents a fee amount.
 */
export interface FeeAmount {
    /**
     * The due amount.
     */
    due?: number | undefined
    /**
     * The expected amount, which is sum of paid and due amounts.
     */
    expected?: number | undefined
    /**
     * The expected amount, which is the sum of unapplied fee and planned fee due amounts.
     */
    expectedUnapplied?: number | undefined
    /**
     * The paid amount.
     */
    paid?: number | undefined
}

/**
 * Represents the request payload for creating a transaction of type FEE_APPLIED.
 */
export interface FeeAppliedDepositTransactionInput {
    /**
     * The value of the fee applied on the account
     */
    amount?: number | undefined
    /**
     * The external id of the current transaction, customizable, unique
     */
    externalId?: string | undefined
    /**
     * Extra notes about the current transaction
     */
    notes?: string | undefined
    /**
     * The encodedKey of the predefined fee that defines the current fee
     */
    predefinedFeeKey?: string | undefined
}

export const FeeAppliedDepositTransactionInput = {
    validate: FeeAppliedDepositTransactionInputValidator as ValidateFunction<FeeAppliedDepositTransactionInput>,
    get schema() {
        return FeeAppliedDepositTransactionInput.validate.schema
    },
    get errors() {
        return FeeAppliedDepositTransactionInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is FeeAppliedDepositTransactionInput => FeeAppliedDepositTransactionInput.validate(o) === true,
    parse: (o: unknown): { right: FeeAppliedDepositTransactionInput } | { left: DefinedError[] } => {
        if (FeeAppliedDepositTransactionInput.is(o)) {
            return { right: o }
        }
        return { left: (FeeAppliedDepositTransactionInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * An amount of predefined fee to apply on account.
 */
export interface FeeInput {
    /**
     * The amount of the fee to apply
     */
    amount?: number | undefined
    /**
     * The percentage of the fee to apply
     */
    percentage?: number | undefined
    /**
     * The encoded key of the predefined fee
     */
    predefinedFeeKey: string
}

/**
 * Represents the request payload for creating a transaction of type FEE_APPLIED
 */
export interface FeeLoanTransactionInput {
    /**
     * The fee amount to be applied on the account
     */
    amount?: number | undefined
    /**
     * The date when the fee transaction is logged into accounting (as Organization Time)
     */
    bookingDate?: string | undefined
    /**
     * The external id of the repayment transaction, customizable, unique
     */
    externalId?: string | undefined
    /**
     * This flag indicates whether the fee should be capitalised or not
     */
    feeCapitalisation?: boolean | undefined
    /**
     * The date of the first repayment for the loan account (as Organization Time)
     */
    firstRepaymentDate?: string | undefined
    /**
     * The installment number on which the fee will be applied
     */
    installmentNumber?: number | undefined
    /**
     * Extra notes about the current transaction
     */
    notes?: string | undefined
    /**
     * The encodedKey of the predefined fee that defines the current fee
     */
    predefinedFeeKey?: string | undefined
    /**
     * The date when to apply the fee (as Organization Time)
     */
    valueDate?: string | undefined
}

export const FeeLoanTransactionInput = {
    validate: FeeLoanTransactionInputValidator as ValidateFunction<FeeLoanTransactionInput>,
    get schema() {
        return FeeLoanTransactionInput.validate.schema
    },
    get errors() {
        return FeeLoanTransactionInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is FeeLoanTransactionInput => FeeLoanTransactionInput.validate(o) === true,
    parse: (o: unknown): { right: FeeLoanTransactionInput } | { left: DefinedError[] } => {
        if (FeeLoanTransactionInput.is(o)) {
            return { right: o }
        }
        return { left: (FeeLoanTransactionInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Defines fees settings for the product.
 */
export interface FeesSettings {
    /**
     * Only if true users will be able to apply fees, for current object, of type 'Other'; these fees can have any amount.
     */
    allowArbitraryFees?: boolean | undefined
    /**
     * List of all fees that can be applied for accounts of this loan product.
     */
    fees?: PredefinedFee[] | undefined
}

/**
 * Tax settings for a specific Predefined fee that overrides the tax settings of Loan Product
 */
export interface FeeTaxSettings {
    /**
     * Marks a specific fee as non-taxable (taxes are not calculated for it).Feature is in the Early Stage. To be enabled by request.
     */
    taxableCalculationMethod?: 'DEFAULT' | 'NON_TAXABLE' | 'CUSTOM_TAX' | undefined
}

/**
 * Specifies range of dates to be used in searching
 */
export interface FilterCriteriaValueDateBetweenDTO {
    /**
     * The start date for searching archived data.
     */
    dateFrom?: string | undefined
    /**
     * The end date for searching archived data.
     */
    dateTo?: string | undefined
}

export const FilterCriteriaValueDateBetweenDTO = {
    validate: FilterCriteriaValueDateBetweenDTOValidator as ValidateFunction<FilterCriteriaValueDateBetweenDTO>,
    get schema() {
        return FilterCriteriaValueDateBetweenDTO.validate.schema
    },
    get errors() {
        return FilterCriteriaValueDateBetweenDTO.validate.errors ?? undefined
    },
    is: (o: unknown): o is FilterCriteriaValueDateBetweenDTO => FilterCriteriaValueDateBetweenDTO.validate(o) === true,
    parse: (o: unknown): { right: FilterCriteriaValueDateBetweenDTO } | { left: DefinedError[] } => {
        if (FilterCriteriaValueDateBetweenDTO.is(o)) {
            return { right: o }
        }
        return { left: (FilterCriteriaValueDateBetweenDTO.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The identification of the financial institution
 */
export interface FinancialInstitutionIdentification {
    /**
     * Business identifier code
     */
    bic?: string | undefined
}

/**
 * Represents the details of general ledger journal entries posted in foreign currency.
 */
export interface ForeignAmount {
    accountingRate?: AccountingRate | undefined
    /**
     * The foreign currency amount of the accounting entry.
     */
    amount?: number | undefined
    currency?: Currency | undefined
}

/**
 * Settings for Four Eyes Principle
 */
export interface FourEyesPrinciple {
    /**
     * Requires separate users to create and approve loan accounts
     */
    activeForLoanApproval?: boolean | undefined
}

/**
 * The funding settings, holds the settings regarding the funding for the loan product.
 */
export interface FundingSettings {
    /**
     * Indicates whether the product has the investor funds enabled or not.
     */
    enabled?: boolean | undefined
    funderInterestCommission?: DecimalConstraints | undefined
    /**
     * Define how the Interest is allocated to the investors(if the investors can define their own percentages for their own contribution to the loan, or if all of them are using the same percentage).
     */
    funderInterestCommissionAllocationType?: 'PERCENTAGE_OF_LOAN_FUNDING' | 'FIXED_INTEREST_COMMISSIONS' | undefined
    /**
     * Shows whether investor funds are locked or not at the loan account's approval.
     */
    lockFundsAtApproval?: boolean | undefined
    organizationInterestCommission?: DecimalConstraints | undefined
    /**
     * The required investor funds percentage, for opening an account with external funding. If null, the investor funds are not enabled.
     */
    requiredFunds?: number | undefined
}

/**
 * Funding source purchase, hold information about a funding source purchase (buyer, price, amount)
 */
export interface FundingSourcePurchase {
    /**
     * The amount bought (a portion of the whole fraction being sold)
     */
    amount: number
    /**
     * The buyer funding account (savings account) key
     */
    depositAccountKey?: string | undefined
    /**
     * The price paid for the amount
     */
    price: number
}

/**
 * Represents the general setup for an organization.
 */
export interface GeneralSetup {
    /**
     * The accounting cut off time.
     */
    accountingCutOffTime?: string | undefined
    /**
     * `TRUE` if separate users are required for approval and disbursal, `FALSE` otherwise.
     */
    approvalDisbursalTwoManRuleEnabled?: boolean | undefined
    /**
     * The number of days that are required before an account can be written off.
     */
    arrearsDaysBeforeWriteOff?: number | undefined
    /**
     * The list of required assignments for clients and groups.
     */
    assignmentConstraints?: ('BRANCH' | 'CENTRE' | 'CREDIT_OFFICER' | 'GROUP')[] | undefined
    /**
     * The interval (number of days) between the execution of automated accounting closures. If this number is 0, automated closure is performed.
     */
    automatedAccountingClosuresInterval?: number | undefined
    /**
     * The pattern for generating individual client IDs.
     */
    clientIdFormat?: string | undefined
    /**
     * The dashboard configuration.
     */
    dashboardConfigurations?: DashboardConfiguration[] | undefined
    /**
     * The date (dd-MM-yyyy) or date time (dd-MM-yyyy HH:mm:ss) formats.
     */
    dateFormats?:
        | {
              [k: string]: string | undefined
          }
        | undefined
    /**
     * The symbol used to mark the border between the integral and the fractional parts of a decimal numeral.
     */
    decimalSeparator?: 'COMMA' | 'POINT' | undefined
    /**
     * The client role used as default.
     */
    defaultClientRoleKey?: string | undefined
    /**
     * The client default state.
     */
    defaultClientState?: 'PENDING_APPROVAL' | 'INACTIVE' | 'ACTIVE' | 'EXITED' | 'BLACKLISTED' | 'REJECTED' | undefined
    /**
     * The group role used as default.
     */
    defaultGroupRoleKey?: string | undefined
    /**
     * The line of credit default state.
     */
    defaultLineOfCreditState?: 'PENDING_APPROVAL' | 'APPROVED' | 'ACTIVE' | 'CLOSED' | 'WITHDRAWN' | 'REJECTED' | undefined
    /**
     * The transaction channel that is used as the default.
     */
    defaultTransactionChannelKey?: string | undefined
    /**
     * The list of duplicate client constraints that are available in the administration and can be performed.
     */
    duplicateClientChecks?: DuplicateFieldConstraint[] | undefined
    /**
     * The action to be taken when the duplicate client validation fails.
     */
    duplicateClientConstraintAction?: 'NONE' | 'WARNING' | 'ERROR' | undefined
    /**
     * The list of all the enabled components for the current tenant.
     */
    enabledComponents?: EnabledComponents[] | undefined
    /**
     * The encoded key of the general setup, which is auto generated, and unique.
     */
    encodedKey?: string | undefined
    /**
     * The end of day (EOD) processing settings. The `AUTOMATIC` EOD processing runs every midnight. The `MANUAL` EOD processing runs when the client initiates the action from the Mambu UI.
     */
    eodProcessingMethod?: 'AUTOMATIC' | 'MANUAL' | undefined
    /**
     * The maximum exposure amount.
     */
    exposureAmount?: number | undefined
    /**
     * The maximum exposure a client can have in outstanding loans at any time.
     */
    exposureType?: 'UNLIMITED' | 'SUM_OF_LOANS' | 'SUM_OF_LOANS_MINUS_SAVINGS' | undefined
    /**
     * The pattern for generating group client IDs.
     */
    groupIdFormat?: string | undefined
    /**
     * The group size limitation type.
     */
    groupSizeLimitType?: 'HARD' | 'WARNING' | 'NONE' | undefined
    /**
     * The key of the general ledger (GL) account which will be used for inter-branch transfers.
     */
    interBranchTransferGLAccountKey?: string | undefined
    /**
     * The unique pattern after which all the lines of credit IDs should be created.
     */
    lineOfCreditIdFormat?: string | undefined
    /**
     * The maximum allowed ID document attachments.
     */
    maxAllowedIdDocumentAttachments?: number | undefined
    /**
     * The maximum allowed journal entry attachments.
     */
    maxAllowedJournalEntryDocumentAttachments?: number | undefined
    /**
     * The maximum number of days users are allowed to undo of close obligations met for a loan account.
     */
    maxAllowedUndoClosurePeriod?: number | undefined
    /**
     * The maximum group size allowed. A null value means the limit is ignored.
     */
    maxGroupSizeLimit?: number | undefined
    /**
     * The minimum group size allowed. A null value means the limit is ignored.
     */
    minGroupSizeLimit?: number | undefined
    /**
     * The constraint on whether clients can belong to more than one group or not.
     */
    multipleGroupMemberships?: 'UNLIMITED' | 'ONE_GROUP' | undefined
    /**
     * The option that shows if multiple loans are allowed or not.
     */
    multipleLoans?: 'UNLIMITED' | 'ONE_LOAN' | undefined
    /**
     * `TRUE` if other ID documents are enabled, `FALSE` otherwise.
     */
    otherIdDocumentsEnabled?: boolean | undefined
    /**
     * The date used when computing overdraft interest for savings accounts.
     */
    overdraftInterestEodBalanceDate?: string | undefined
    /**
     * The unique pattern after which all the till IDs should be created.
     */
    tillIdFormat?: string | undefined
}

export const GeneralSetup = {
    validate: GeneralSetupValidator as ValidateFunction<GeneralSetup>,
    get schema() {
        return GeneralSetup.validate.schema
    },
    get errors() {
        return GeneralSetup.validate.errors ?? undefined
    },
    is: (o: unknown): o is GeneralSetup => GeneralSetup.validate(o) === true,
    parse: (o: unknown): { right: GeneralSetup } | { left: DefinedError[] } => {
        if (GeneralSetup.is(o)) {
            return { right: o }
        }
        return { left: (GeneralSetup.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll10Response = ExchangeRate[]

export const GetAll10Response = {
    validate: GetAll10ResponseValidator as ValidateFunction<GetAll10Response>,
    get schema() {
        return GetAll10Response.validate.schema
    },
    get errors() {
        return GetAll10Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll10Response => GetAll10Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll10Response } | { left: DefinedError[] } => {
        if (GetAll10Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll10Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll11Response = GLAccount[]

export const GetAll11Response = {
    validate: GetAll11ResponseValidator as ValidateFunction<GetAll11Response>,
    get schema() {
        return GetAll11Response.validate.schema
    },
    get errors() {
        return GetAll11Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll11Response => GetAll11Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll11Response } | { left: DefinedError[] } => {
        if (GetAll11Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll11Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll12Response = GLJournalEntry[]

export const GetAll12Response = {
    validate: GetAll12ResponseValidator as ValidateFunction<GetAll12Response>,
    get schema() {
        return GetAll12Response.validate.schema
    },
    get errors() {
        return GetAll12Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll12Response => GetAll12Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll12Response } | { left: DefinedError[] } => {
        if (GetAll12Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll12Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll13Response = Group[]

export const GetAll13Response = {
    validate: GetAll13ResponseValidator as ValidateFunction<GetAll13Response>,
    get schema() {
        return GetAll13Response.validate.schema
    },
    get errors() {
        return GetAll13Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll13Response => GetAll13Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll13Response } | { left: DefinedError[] } => {
        if (GetAll13Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll13Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll14Response = IdentificationDocumentTemplate[]

export const GetAll14Response = {
    validate: GetAll14ResponseValidator as ValidateFunction<GetAll14Response>,
    get schema() {
        return GetAll14Response.validate.schema
    },
    get errors() {
        return GetAll14Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll14Response => GetAll14Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll14Response } | { left: DefinedError[] } => {
        if (GetAll14Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll14Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll15Response = Installment[]

export const GetAll15Response = {
    validate: GetAll15ResponseValidator as ValidateFunction<GetAll15Response>,
    get schema() {
        return GetAll15Response.validate.schema
    },
    get errors() {
        return GetAll15Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll15Response => GetAll15Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll15Response } | { left: DefinedError[] } => {
        if (GetAll15Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll15Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll16Response = LoanAccount[]

export const GetAll16Response = {
    validate: GetAll16ResponseValidator as ValidateFunction<GetAll16Response>,
    get schema() {
        return GetAll16Response.validate.schema
    },
    get errors() {
        return GetAll16Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll16Response => GetAll16Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll16Response } | { left: DefinedError[] } => {
        if (GetAll16Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll16Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll17Response = LoanProduct[]

export const GetAll17Response = {
    validate: GetAll17ResponseValidator as ValidateFunction<GetAll17Response>,
    get schema() {
        return GetAll17Response.validate.schema
    },
    get errors() {
        return GetAll17Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll17Response => GetAll17Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll17Response } | { left: DefinedError[] } => {
        if (GetAll17Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll17Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll18Response = LoanTransaction[]

export const GetAll18Response = {
    validate: GetAll18ResponseValidator as ValidateFunction<GetAll18Response>,
    get schema() {
        return GetAll18Response.validate.schema
    },
    get errors() {
        return GetAll18Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll18Response => GetAll18Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll18Response } | { left: DefinedError[] } => {
        if (GetAll18Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll18Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll19Response = Task[]

export const GetAll19Response = {
    validate: GetAll19ResponseValidator as ValidateFunction<GetAll19Response>,
    get schema() {
        return GetAll19Response.validate.schema
    },
    get errors() {
        return GetAll19Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll19Response => GetAll19Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll19Response } | { left: DefinedError[] } => {
        if (GetAll19Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll19Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll1Response = ApiConsumer[]

export const GetAll1Response = {
    validate: GetAll1ResponseValidator as ValidateFunction<GetAll1Response>,
    get schema() {
        return GetAll1Response.validate.schema
    },
    get errors() {
        return GetAll1Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll1Response => GetAll1Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll1Response } | { left: DefinedError[] } => {
        if (GetAll1Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll1Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll20Response = TransactionChannel[]

export const GetAll20Response = {
    validate: GetAll20ResponseValidator as ValidateFunction<GetAll20Response>,
    get schema() {
        return GetAll20Response.validate.schema
    },
    get errors() {
        return GetAll20Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll20Response => GetAll20Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll20Response } | { left: DefinedError[] } => {
        if (GetAll20Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll20Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll21Response = Role[]

export const GetAll21Response = {
    validate: GetAll21ResponseValidator as ValidateFunction<GetAll21Response>,
    get schema() {
        return GetAll21Response.validate.schema
    },
    get errors() {
        return GetAll21Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll21Response => GetAll21Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll21Response } | { left: DefinedError[] } => {
        if (GetAll21Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll21Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll22Response = User[]

export const GetAll22Response = {
    validate: GetAll22ResponseValidator as ValidateFunction<GetAll22Response>,
    get schema() {
        return GetAll22Response.validate.schema
    },
    get errors() {
        return GetAll22Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll22Response => GetAll22Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll22Response } | { left: DefinedError[] } => {
        if (GetAll22Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll22Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll23Response = CurrencyDetails[]

export const GetAll23Response = {
    validate: GetAll23ResponseValidator as ValidateFunction<GetAll23Response>,
    get schema() {
        return GetAll23Response.validate.schema
    },
    get errors() {
        return GetAll23Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll23Response => GetAll23Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll23Response } | { left: DefinedError[] } => {
        if (GetAll23Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll23Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll2Response = Branch[]

export const GetAll2Response = {
    validate: GetAll2ResponseValidator as ValidateFunction<GetAll2Response>,
    get schema() {
        return GetAll2Response.validate.schema
    },
    get errors() {
        return GetAll2Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll2Response => GetAll2Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll2Response } | { left: DefinedError[] } => {
        if (GetAll2Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll2Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll3Response = Centre[]

export const GetAll3Response = {
    validate: GetAll3ResponseValidator as ValidateFunction<GetAll3Response>,
    get schema() {
        return GetAll3Response.validate.schema
    },
    get errors() {
        return GetAll3Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll3Response => GetAll3Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll3Response } | { left: DefinedError[] } => {
        if (GetAll3Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll3Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll4Response = Client[]

export const GetAll4Response = {
    validate: GetAll4ResponseValidator as ValidateFunction<GetAll4Response>,
    get schema() {
        return GetAll4Response.validate.schema
    },
    get errors() {
        return GetAll4Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll4Response => GetAll4Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll4Response } | { left: DefinedError[] } => {
        if (GetAll4Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll4Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll5Response = CreditArrangement[]

export const GetAll5Response = {
    validate: GetAll5ResponseValidator as ValidateFunction<GetAll5Response>,
    get schema() {
        return GetAll5Response.validate.schema
    },
    get errors() {
        return GetAll5Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll5Response => GetAll5Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll5Response } | { left: DefinedError[] } => {
        if (GetAll5Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll5Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll6Response = CustomFieldSetMeta[]

export const GetAll6Response = {
    validate: GetAll6ResponseValidator as ValidateFunction<GetAll6Response>,
    get schema() {
        return GetAll6Response.validate.schema
    },
    get errors() {
        return GetAll6Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll6Response => GetAll6Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll6Response } | { left: DefinedError[] } => {
        if (GetAll6Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll6Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll7Response = DepositAccount[]

export const GetAll7Response = {
    validate: GetAll7ResponseValidator as ValidateFunction<GetAll7Response>,
    get schema() {
        return GetAll7Response.validate.schema
    },
    get errors() {
        return GetAll7Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll7Response => GetAll7Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll7Response } | { left: DefinedError[] } => {
        if (GetAll7Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll7Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll8Response = DepositProduct[]

export const GetAll8Response = {
    validate: GetAll8ResponseValidator as ValidateFunction<GetAll8Response>,
    get schema() {
        return GetAll8Response.validate.schema
    },
    get errors() {
        return GetAll8Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll8Response => GetAll8Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll8Response } | { left: DefinedError[] } => {
        if (GetAll8Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll8Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAll9Response = DepositTransaction[]

export const GetAll9Response = {
    validate: GetAll9ResponseValidator as ValidateFunction<GetAll9Response>,
    get schema() {
        return GetAll9Response.validate.schema
    },
    get errors() {
        return GetAll9Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAll9Response => GetAll9Response.validate(o) === true,
    parse: (o: unknown): { right: GetAll9Response } | { left: DefinedError[] } => {
        if (GetAll9Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAll9Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAllAuthorizationHolds1Response = GetAuthorizationHold[]

export const GetAllAuthorizationHolds1Response = {
    validate: GetAllAuthorizationHolds1ResponseValidator as ValidateFunction<GetAllAuthorizationHolds1Response>,
    get schema() {
        return GetAllAuthorizationHolds1Response.validate.schema
    },
    get errors() {
        return GetAllAuthorizationHolds1Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAllAuthorizationHolds1Response => GetAllAuthorizationHolds1Response.validate(o) === true,
    parse: (o: unknown): { right: GetAllAuthorizationHolds1Response } | { left: DefinedError[] } => {
        if (GetAllAuthorizationHolds1Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAllAuthorizationHolds1Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAllAuthorizationHoldsResponse = GetAuthorizationHold[]

export const GetAllAuthorizationHoldsResponse = {
    validate: GetAllAuthorizationHoldsResponseValidator as ValidateFunction<GetAllAuthorizationHoldsResponse>,
    get schema() {
        return GetAllAuthorizationHoldsResponse.validate.schema
    },
    get errors() {
        return GetAllAuthorizationHoldsResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAllAuthorizationHoldsResponse => GetAllAuthorizationHoldsResponse.validate(o) === true,
    parse: (o: unknown): { right: GetAllAuthorizationHoldsResponse } | { left: DefinedError[] } => {
        if (GetAllAuthorizationHoldsResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetAllAuthorizationHoldsResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAllBlocksResponse = BlockFund[]

export const GetAllBlocksResponse = {
    validate: GetAllBlocksResponseValidator as ValidateFunction<GetAllBlocksResponse>,
    get schema() {
        return GetAllBlocksResponse.validate.schema
    },
    get errors() {
        return GetAllBlocksResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAllBlocksResponse => GetAllBlocksResponse.validate(o) === true,
    parse: (o: unknown): { right: GetAllBlocksResponse } | { left: DefinedError[] } => {
        if (GetAllBlocksResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetAllBlocksResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAllBySetIdResponse = CustomFieldMeta[]

export const GetAllBySetIdResponse = {
    validate: GetAllBySetIdResponseValidator as ValidateFunction<GetAllBySetIdResponse>,
    get schema() {
        return GetAllBySetIdResponse.validate.schema
    },
    get errors() {
        return GetAllBySetIdResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAllBySetIdResponse => GetAllBySetIdResponse.validate(o) === true,
    parse: (o: unknown): { right: GetAllBySetIdResponse } | { left: DefinedError[] } => {
        if (GetAllBySetIdResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetAllBySetIdResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAllCards1Response = Card[]

export const GetAllCards1Response = {
    validate: GetAllCards1ResponseValidator as ValidateFunction<GetAllCards1Response>,
    get schema() {
        return GetAllCards1Response.validate.schema
    },
    get errors() {
        return GetAllCards1Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAllCards1Response => GetAllCards1Response.validate(o) === true,
    parse: (o: unknown): { right: GetAllCards1Response } | { left: DefinedError[] } => {
        if (GetAllCards1Response.is(o)) {
            return { right: o }
        }
        return { left: (GetAllCards1Response.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAllCardsResponse = Card[]

export const GetAllCardsResponse = {
    validate: GetAllCardsResponseValidator as ValidateFunction<GetAllCardsResponse>,
    get schema() {
        return GetAllCardsResponse.validate.schema
    },
    get errors() {
        return GetAllCardsResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAllCardsResponse => GetAllCardsResponse.validate(o) === true,
    parse: (o: unknown): { right: GetAllCardsResponse } | { left: DefinedError[] } => {
        if (GetAllCardsResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetAllCardsResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAllIndexRateSourcesResponse = IndexRateSource[]

export const GetAllIndexRateSourcesResponse = {
    validate: GetAllIndexRateSourcesResponseValidator as ValidateFunction<GetAllIndexRateSourcesResponse>,
    get schema() {
        return GetAllIndexRateSourcesResponse.validate.schema
    },
    get errors() {
        return GetAllIndexRateSourcesResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAllIndexRateSourcesResponse => GetAllIndexRateSourcesResponse.validate(o) === true,
    parse: (o: unknown): { right: GetAllIndexRateSourcesResponse } | { left: DefinedError[] } => {
        if (GetAllIndexRateSourcesResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetAllIndexRateSourcesResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAllIndexRatesResponse = IndexRate[]

export const GetAllIndexRatesResponse = {
    validate: GetAllIndexRatesResponseValidator as ValidateFunction<GetAllIndexRatesResponse>,
    get schema() {
        return GetAllIndexRatesResponse.validate.schema
    },
    get errors() {
        return GetAllIndexRatesResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAllIndexRatesResponse => GetAllIndexRatesResponse.validate(o) === true,
    parse: (o: unknown): { right: GetAllIndexRatesResponse } | { left: DefinedError[] } => {
        if (GetAllIndexRatesResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetAllIndexRatesResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAllPlannedFeesResponse = PlannedInstallmentFee[]

export const GetAllPlannedFeesResponse = {
    validate: GetAllPlannedFeesResponseValidator as ValidateFunction<GetAllPlannedFeesResponse>,
    get schema() {
        return GetAllPlannedFeesResponse.validate.schema
    },
    get errors() {
        return GetAllPlannedFeesResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAllPlannedFeesResponse => GetAllPlannedFeesResponse.validate(o) === true,
    parse: (o: unknown): { right: GetAllPlannedFeesResponse } | { left: DefinedError[] } => {
        if (GetAllPlannedFeesResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetAllPlannedFeesResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetAllResponse = AccountingRate[]

export const GetAllResponse = {
    validate: GetAllResponseValidator as ValidateFunction<GetAllResponse>,
    get schema() {
        return GetAllResponse.validate.schema
    },
    get errors() {
        return GetAllResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAllResponse => GetAllResponse.validate(o) === true,
    parse: (o: unknown): { right: GetAllResponse } | { left: DefinedError[] } => {
        if (GetAllResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetAllResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Details for retrieving a authorization hold. Deprecated due to encodedKey field.
 */
export interface GetAuthorizationHold {
    /**
     * The key of the account linked with the authorization hold.
     */
    accountKey?: string | undefined
    /**
     * Whether the given request should be accepted without balance validations.
     */
    advice: boolean
    /**
     * The amount of money to be held as a result of the authorization hold request.
     */
    amount: number
    balances?: AccountBalances | undefined
    cardAcceptor?: CardAcceptor | undefined
    /**
     * The reference token of the card.
     */
    cardToken?: string | undefined
    /**
     * The organization time when the authorization hold was created
     */
    creationDate?: string | undefined
    /**
     * Indicates whether the authorization hold amount is credited or debited.If not provided, the default values is DBIT.
     */
    creditDebitIndicator?: 'DBIT' | 'CRDT' | undefined
    /**
     * The ISO currency code in which the hold was created. The amounts are stored in the base currency, but the user could have enter it in a foreign currency.
     */
    currencyCode?: string | undefined
    /**
     * The custom expiration period for the hold which overwrites mcc and default expiration periods
     */
    customExpirationPeriod?: number | undefined
    /**
     * The internal ID of the authorization hold, auto generated, unique.
     */
    encodedKey?: string | undefined
    /**
     * The exchange rate for the original currency.
     */
    exchangeRate?: number | undefined
    /**
     * The external reference ID to be used to reference the account hold in subsequent requests.
     */
    externalReferenceId: string
    /**
     * The original amount of money to be held as a result of the authorization hold request.
     */
    originalAmount?: number | undefined
    /**
     * The original currency in which the hold was created.
     */
    originalCurrency?: string | undefined
    /**
     * Indicates whether the authorization is partial or not
     */
    partial?: boolean | undefined
    /**
     * The date to consider as start date when calculating the number of days passed until expiration
     */
    referenceDateForExpiration?: string | undefined
    /**
     * Indicates the source of the authorization hold, the default values is CARD.
     */
    source?: 'CARD' | 'ACCOUNT' | undefined
    /**
     * The authorization hold status.
     */
    status?: 'PENDING' | 'REVERSED' | 'SETTLED' | 'EXPIRED' | undefined
    /**
     * The formatted time at which the user made this authorization hold.
     */
    userTransactionTime?: string | undefined
}

export const GetAuthorizationHold = {
    validate: GetAuthorizationHoldValidator as ValidateFunction<GetAuthorizationHold>,
    get schema() {
        return GetAuthorizationHold.validate.schema
    },
    get errors() {
        return GetAuthorizationHold.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetAuthorizationHold => GetAuthorizationHold.validate(o) === true,
    parse: (o: unknown): { right: GetAuthorizationHold } | { left: DefinedError[] } => {
        if (GetAuthorizationHold.is(o)) {
            return { right: o }
        }
        return { left: (GetAuthorizationHold.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Details for retrieving a card financial transaction.
 */
export interface GetCardTransaction {
    accountBalances?: DepositTransactionBalances | undefined
    /**
     * The key of the deposit transaction where the adjustment for this transaction was made (if any adjustment was involved)
     */
    adjustmentTransactionKey?: string | undefined
    affectedAmounts?: DepositAffectedAmounts | undefined
    /**
     * How much was added/removed in account
     */
    amount?: number | undefined
    /**
     * The block fund id associated with the transaction
     */
    blockId?: string | undefined
    /**
     * The date when corresponding JE is booked (as Organization Time)
     */
    bookingDate?: string | undefined
    /**
     * The branch where the transaction was performed
     */
    branchKey?: string | undefined
    cardTransaction?: CardTransaction | undefined
    /**
     * Object containing all the associated reversal transactions.
     */
    cardTransactionReversals?: CardTransactionReversal[] | undefined
    /**
     * The center where the transaction was performed
     */
    centreKey?: string | undefined
    /**
     * The date when this deposit transaction was created
     */
    creationDate?: string | undefined
    /**
     * The currency in which this transaction was posted
     */
    currencyCode?: string | undefined
    /**
     * The encoded key of the deposit transaction, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * The external id of the deposit transaction, customizable, unique
     */
    externalId?: string | undefined
    /**
     * All the amounts that have been applied or paid within this transaction and involved predefined fees
     */
    fees?: DepositFee[] | undefined
    /**
     * The external id of an account authorization hold
     */
    holdExternalReferenceId?: string | undefined
    /**
     * The id of the deposit transaction, auto generated, unique
     */
    id?: string | undefined
    interestAccruedAmounts?: DepositInterestAccruedAmounts | undefined
    /**
     * The migration event encoded key associated with this deposit account. If this account was imported, track which 'migration event' they came from
     */
    migrationEventKey?: string | undefined
    /**
     * Extra notes about this deposit transaction
     */
    notes?: string | undefined
    /**
     * The encodedKey of the transaction that was adjusted as part of this one. Available only for adjustment transactions
     */
    originalTransactionKey?: string | undefined
    /**
     * The key of the parent deposit account
     */
    parentAccountKey?: string | undefined
    paymentDetails?: PaymentDetails | undefined
    /**
     * The payment order id of the deposit transaction, customizable
     */
    paymentOrderId?: string | undefined
    taxes?: DepositTaxes | undefined
    terms?: DepositTerms | undefined
    /**
     * The till key associated with this transaction
     */
    tillKey?: string | undefined
    transactionDetails?: TransactionDetails | undefined
    transferDetails?: TransferDetails | undefined
    /**
     * The type of the deposit transaction
     */
    type?:
        | 'IMPORT'
        | 'WRITE_OFF'
        | 'WRITE_OFF_ADJUSTMENT'
        | 'DEPOSIT'
        | 'ADJUSTMENT'
        | 'WITHDRAWAL'
        | 'WITHDRAWAL_ADJUSTMENT'
        | 'CARD_TRANSACTION_REVERSAL'
        | 'CARD_TRANSACTION_REVERSAL_ADJUSTMENT'
        | 'TRANSFER'
        | 'TRANSFER_ADJUSTMENT'
        | 'FEE_APPLIED'
        | 'FEE_ADJUSTED'
        | 'FEES_DUE_REDUCED'
        | 'INTEREST_APPLIED'
        | 'INTEREST_APPLIED_ADJUSTMENT'
        | 'NET_DIFF_INTEREST'
        | 'FEE_REDUCTION_ADJUSTMENT'
        | 'WITHHOLDING_TAX'
        | 'WITHHOLDING_TAX_ADJUSTMENT'
        | 'INTEREST_RATE_CHANGED'
        | 'OVERDRAFT_INTEREST_RATE_CHANGED'
        | 'OVERDRAFT_LIMIT_CHANGED'
        | 'BRANCH_CHANGED'
        | 'ACCOUNT_HOLDER_CHANGED'
        | 'LOAN_FUNDED'
        | 'LOAN_FUNDED_ADJUSTMENT'
        | 'LOAN_REPAID'
        | 'LOAN_REPAID_ADJUSTMENT'
        | 'LOAN_FRACTION_BOUGHT'
        | 'LOAN_FRACTION_BOUGHT_ADJUSTMENT'
        | 'LOAN_FRACTION_SOLD'
        | 'LOAN_FRACTION_SOLD_ADJUSTMENT'
        | 'SEIZED_AMOUNT'
        | undefined
    /**
     * The person that performed the transaction
     */
    userKey?: string | undefined
    /**
     * Date of the entry (eg date of repayment or disbursal, etc.) (as Organization Time)
     */
    valueDate?: string | undefined
}

export const GetCardTransaction = {
    validate: GetCardTransactionValidator as ValidateFunction<GetCardTransaction>,
    get schema() {
        return GetCardTransaction.validate.schema
    },
    get errors() {
        return GetCardTransaction.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetCardTransaction => GetCardTransaction.validate(o) === true,
    parse: (o: unknown): { right: GetCardTransaction } | { left: DefinedError[] } => {
        if (GetCardTransaction.is(o)) {
            return { right: o }
        }
        return { left: (GetCardTransaction.errors ?? []) as DefinedError[] }
    },
} as const

export type GetCommentsResponse = Comment[]

export const GetCommentsResponse = {
    validate: GetCommentsResponseValidator as ValidateFunction<GetCommentsResponse>,
    get schema() {
        return GetCommentsResponse.validate.schema
    },
    get errors() {
        return GetCommentsResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetCommentsResponse => GetCommentsResponse.validate(o) === true,
    parse: (o: unknown): { right: GetCommentsResponse } | { left: DefinedError[] } => {
        if (GetCommentsResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetCommentsResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetCreditArrangementsByClientIdOrKeyResponse = CreditArrangement[]

export const GetCreditArrangementsByClientIdOrKeyResponse = {
    validate:
        GetCreditArrangementsByClientIdOrKeyResponseValidator as ValidateFunction<GetCreditArrangementsByClientIdOrKeyResponse>,
    get schema() {
        return GetCreditArrangementsByClientIdOrKeyResponse.validate.schema
    },
    get errors() {
        return GetCreditArrangementsByClientIdOrKeyResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetCreditArrangementsByClientIdOrKeyResponse =>
        GetCreditArrangementsByClientIdOrKeyResponse.validate(o) === true,
    parse: (o: unknown): { right: GetCreditArrangementsByClientIdOrKeyResponse } | { left: DefinedError[] } => {
        if (GetCreditArrangementsByClientIdOrKeyResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetCreditArrangementsByClientIdOrKeyResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetCreditArrangementsByGroupIdOrKeyResponse = CreditArrangement[]

export const GetCreditArrangementsByGroupIdOrKeyResponse = {
    validate:
        GetCreditArrangementsByGroupIdOrKeyResponseValidator as ValidateFunction<GetCreditArrangementsByGroupIdOrKeyResponse>,
    get schema() {
        return GetCreditArrangementsByGroupIdOrKeyResponse.validate.schema
    },
    get errors() {
        return GetCreditArrangementsByGroupIdOrKeyResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetCreditArrangementsByGroupIdOrKeyResponse =>
        GetCreditArrangementsByGroupIdOrKeyResponse.validate(o) === true,
    parse: (o: unknown): { right: GetCreditArrangementsByGroupIdOrKeyResponse } | { left: DefinedError[] } => {
        if (GetCreditArrangementsByGroupIdOrKeyResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetCreditArrangementsByGroupIdOrKeyResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetDepositAccountDocumentResponse = string

export const GetDepositAccountDocumentResponse = {
    validate: GetDepositAccountDocumentResponseValidator as ValidateFunction<GetDepositAccountDocumentResponse>,
    get schema() {
        return GetDepositAccountDocumentResponse.validate.schema
    },
    get errors() {
        return GetDepositAccountDocumentResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetDepositAccountDocumentResponse => GetDepositAccountDocumentResponse.validate(o) === true,
    parse: (o: unknown): { right: GetDepositAccountDocumentResponse } | { left: DefinedError[] } => {
        if (GetDepositAccountDocumentResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetDepositAccountDocumentResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetDepositTransactionDocumentResponse = string

export const GetDepositTransactionDocumentResponse = {
    validate: GetDepositTransactionDocumentResponseValidator as ValidateFunction<GetDepositTransactionDocumentResponse>,
    get schema() {
        return GetDepositTransactionDocumentResponse.validate.schema
    },
    get errors() {
        return GetDepositTransactionDocumentResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetDepositTransactionDocumentResponse => GetDepositTransactionDocumentResponse.validate(o) === true,
    parse: (o: unknown): { right: GetDepositTransactionDocumentResponse } | { left: DefinedError[] } => {
        if (GetDepositTransactionDocumentResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetDepositTransactionDocumentResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetDocumentsByClientIdResponse = Document[]

export const GetDocumentsByClientIdResponse = {
    validate: GetDocumentsByClientIdResponseValidator as ValidateFunction<GetDocumentsByClientIdResponse>,
    get schema() {
        return GetDocumentsByClientIdResponse.validate.schema
    },
    get errors() {
        return GetDocumentsByClientIdResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetDocumentsByClientIdResponse => GetDocumentsByClientIdResponse.validate(o) === true,
    parse: (o: unknown): { right: GetDocumentsByClientIdResponse } | { left: DefinedError[] } => {
        if (GetDocumentsByClientIdResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetDocumentsByClientIdResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetDocumentsByEntityIdResponse = Document[]

export const GetDocumentsByEntityIdResponse = {
    validate: GetDocumentsByEntityIdResponseValidator as ValidateFunction<GetDocumentsByEntityIdResponse>,
    get schema() {
        return GetDocumentsByEntityIdResponse.validate.schema
    },
    get errors() {
        return GetDocumentsByEntityIdResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetDocumentsByEntityIdResponse => GetDocumentsByEntityIdResponse.validate(o) === true,
    parse: (o: unknown): { right: GetDocumentsByEntityIdResponse } | { left: DefinedError[] } => {
        if (GetDocumentsByEntityIdResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetDocumentsByEntityIdResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetFundedLoansResponse = LoanAccount[]

export const GetFundedLoansResponse = {
    validate: GetFundedLoansResponseValidator as ValidateFunction<GetFundedLoansResponse>,
    get schema() {
        return GetFundedLoansResponse.validate.schema
    },
    get errors() {
        return GetFundedLoansResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetFundedLoansResponse => GetFundedLoansResponse.validate(o) === true,
    parse: (o: unknown): { right: GetFundedLoansResponse } | { left: DefinedError[] } => {
        if (GetFundedLoansResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetFundedLoansResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetInterestAvailabilitiesListResponse = InterestAccountSettingsAvailabilityResponse[]

export const GetInterestAvailabilitiesListResponse = {
    validate: GetInterestAvailabilitiesListResponseValidator as ValidateFunction<GetInterestAvailabilitiesListResponse>,
    get schema() {
        return GetInterestAvailabilitiesListResponse.validate.schema
    },
    get errors() {
        return GetInterestAvailabilitiesListResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetInterestAvailabilitiesListResponse => GetInterestAvailabilitiesListResponse.validate(o) === true,
    parse: (o: unknown): { right: GetInterestAvailabilitiesListResponse } | { left: DefinedError[] } => {
        if (GetInterestAvailabilitiesListResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetInterestAvailabilitiesListResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetKeysByConsumerIdResponse = ApiKey[]

export const GetKeysByConsumerIdResponse = {
    validate: GetKeysByConsumerIdResponseValidator as ValidateFunction<GetKeysByConsumerIdResponse>,
    get schema() {
        return GetKeysByConsumerIdResponse.validate.schema
    },
    get errors() {
        return GetKeysByConsumerIdResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetKeysByConsumerIdResponse => GetKeysByConsumerIdResponse.validate(o) === true,
    parse: (o: unknown): { right: GetKeysByConsumerIdResponse } | { left: DefinedError[] } => {
        if (GetKeysByConsumerIdResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetKeysByConsumerIdResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetLoanAccountDocumentResponse = string

export const GetLoanAccountDocumentResponse = {
    validate: GetLoanAccountDocumentResponseValidator as ValidateFunction<GetLoanAccountDocumentResponse>,
    get schema() {
        return GetLoanAccountDocumentResponse.validate.schema
    },
    get errors() {
        return GetLoanAccountDocumentResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetLoanAccountDocumentResponse => GetLoanAccountDocumentResponse.validate(o) === true,
    parse: (o: unknown): { right: GetLoanAccountDocumentResponse } | { left: DefinedError[] } => {
        if (GetLoanAccountDocumentResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetLoanAccountDocumentResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetLoanAccountRsvResponse = LoanAccountRepaymentScheduleVersioning[]

export const GetLoanAccountRsvResponse = {
    validate: GetLoanAccountRsvResponseValidator as ValidateFunction<GetLoanAccountRsvResponse>,
    get schema() {
        return GetLoanAccountRsvResponse.validate.schema
    },
    get errors() {
        return GetLoanAccountRsvResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetLoanAccountRsvResponse => GetLoanAccountRsvResponse.validate(o) === true,
    parse: (o: unknown): { right: GetLoanAccountRsvResponse } | { left: DefinedError[] } => {
        if (GetLoanAccountRsvResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetLoanAccountRsvResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetTranchesResponse = LoanTranche[]

export const GetTranchesResponse = {
    validate: GetTranchesResponseValidator as ValidateFunction<GetTranchesResponse>,
    get schema() {
        return GetTranchesResponse.validate.schema
    },
    get errors() {
        return GetTranchesResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetTranchesResponse => GetTranchesResponse.validate(o) === true,
    parse: (o: unknown): { right: GetTranchesResponse } | { left: DefinedError[] } => {
        if (GetTranchesResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetTranchesResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetTransactionsForAllVersionsResponse = LoanTransaction[]

export const GetTransactionsForAllVersionsResponse = {
    validate: GetTransactionsForAllVersionsResponseValidator as ValidateFunction<GetTransactionsForAllVersionsResponse>,
    get schema() {
        return GetTransactionsForAllVersionsResponse.validate.schema
    },
    get errors() {
        return GetTransactionsForAllVersionsResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetTransactionsForAllVersionsResponse => GetTransactionsForAllVersionsResponse.validate(o) === true,
    parse: (o: unknown): { right: GetTransactionsForAllVersionsResponse } | { left: DefinedError[] } => {
        if (GetTransactionsForAllVersionsResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetTransactionsForAllVersionsResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetVersionsByIdResponse = LoanAccount[]

export const GetVersionsByIdResponse = {
    validate: GetVersionsByIdResponseValidator as ValidateFunction<GetVersionsByIdResponse>,
    get schema() {
        return GetVersionsByIdResponse.validate.schema
    },
    get errors() {
        return GetVersionsByIdResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetVersionsByIdResponse => GetVersionsByIdResponse.validate(o) === true,
    parse: (o: unknown): { right: GetVersionsByIdResponse } | { left: DefinedError[] } => {
        if (GetVersionsByIdResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetVersionsByIdResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type GetWithholdingTaxHistoryResponse = AccountTax[]

export const GetWithholdingTaxHistoryResponse = {
    validate: GetWithholdingTaxHistoryResponseValidator as ValidateFunction<GetWithholdingTaxHistoryResponse>,
    get schema() {
        return GetWithholdingTaxHistoryResponse.validate.schema
    },
    get errors() {
        return GetWithholdingTaxHistoryResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetWithholdingTaxHistoryResponse => GetWithholdingTaxHistoryResponse.validate(o) === true,
    parse: (o: unknown): { right: GetWithholdingTaxHistoryResponse } | { left: DefinedError[] } => {
        if (GetWithholdingTaxHistoryResponse.is(o)) {
            return { right: o }
        }
        return { left: (GetWithholdingTaxHistoryResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents a general ledger account.
 */
export interface GLAccount {
    /**
     * `TRUE` if the account is activated and may be used, `FALSE` otherwise.
     */
    activated?: boolean | undefined
    /**
     * `TRUE` if manual journal entries are allowed, `FALSE` otherwise.
     */
    allowManualJournalEntries?: boolean | undefined
    /**
     * The balance of the general ledger account, which is only populated for the GET /glaccounts endpoint.
     */
    balance?: number | undefined
    /**
     * The creation date for this account, which is stored as UTC.
     */
    creationDate?: string | undefined
    currency?: Currency | undefined
    /**
     * A description of the general ledger account.
     */
    description?: string | undefined
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The general ledger code used to identify different account types. Also used for grouping and categorizing accounts. For example: an account code of '3201' is considered a subtype of '3200'.
     */
    glCode?: string | undefined
    /**
     * The last modification date and time, which is stored as UTC.
     */
    lastModifiedDate?: string | undefined
    /**
     * The data migration event key if the general ledger account was created as a part of a data migration event.
     */
    migrationEventKey?: string | undefined
    /**
     * The name of the general ledger account.
     */
    name?: string | undefined
    /**
     * `TRUE` if trailing zeros are stripped, `FALSE` otherwise.
     */
    stripTrailingZeros?: boolean | undefined
    /**
     * The general ledger account type.
     */
    type?: 'ASSET' | 'LIABILITY' | 'EQUITY' | 'INCOME' | 'EXPENSE' | undefined
    /**
     * The usage type of the general ledger account. `DETAIL` accounts are used to stores transaction balances. `HEADER` accounts are used to organise and group detail accounts for reporting purposes.
     */
    usage?: 'DETAIL' | 'HEADER' | undefined
}

export const GLAccount = {
    validate: GLAccountValidator as ValidateFunction<GLAccount>,
    get schema() {
        return GLAccount.validate.schema
    },
    get errors() {
        return GLAccount.validate.errors ?? undefined
    },
    is: (o: unknown): o is GLAccount => GLAccount.validate(o) === true,
    parse: (o: unknown): { right: GLAccount } | { left: DefinedError[] } => {
        if (GLAccount.is(o)) {
            return { right: o }
        }
        return { left: (GLAccount.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the general ledger account and amount used in a journal entry record.
 */
export interface GLAccountAmount {
    /**
     * The amount which was debited or credited.
     */
    amount?: number | undefined
    /**
     * Represents the general ledger account code of the the general ledger account that was debited or credited.
     */
    glAccount?: string | undefined
}

/**
 * The GL accounting rule, it maps a financial resource with a GL account for a specific product (i.e loan or saving).
 */
export interface GLAccountingRule {
    /**
     * The encoded key of the accounting rule, auto generated, unique.
     */
    encodedKey?: string | undefined
    /**
     * General Ledger Financial Resources used to setup the product accounting rules and determine the credit and debit accounts when logging journal entries
     */
    financialResource:
        | 'PORTFOLIO_CONTROL'
        | 'FUND_SOURCE'
        | 'WRITE_OFF_EXPENSE'
        | 'INTEREST_INCOME'
        | 'PAYMENT_HOLIDAY_INTEREST_INCOME'
        | 'TAXES_PAYABLE'
        | 'FEE_INCOME'
        | 'PENALTY_INCOME'
        | 'NEGATIVE_INTEREST_PAYABLE_RECEIVABLE'
        | 'NEGATIVE_INTEREST_PAYABLE'
        | 'INTEREST_RECEIVABLE'
        | 'PAYMENT_HOLIDAY_INTEREST_RECEIVABLE'
        | 'FEE_RECEIVABLE'
        | 'PENALTY_RECEIVABLE'
        | 'TAXES_RECEIVABLE'
        | 'DEFERRED_INTERESTS_INCOME'
        | 'DEFERRED_FEE_INCOME'
        | 'DEFERRED_TAXES'
        | 'DEPOSIT_REFERENCE'
        | 'SAVINGS_CONTROL'
        | 'INTEREST_EXPENSE'
        | 'INTEREST_PAYABLE'
        | 'NEGATIVE_INTEREST_INCOME'
        | 'NEGATIVE_INTEREST_RECEIVABLE'
        | 'OVERDRAFT_PORTFOLIO_CONTROL'
        | 'OVERDRAFT_INTEREST_INCOME'
        | 'OVERDRAFT_WRITE_OFF_EXPENSE'
        | 'OVERDRAFT_INTEREST_RECEIVABLE'
        | 'INTER_BRANCH_TRANSFER'
        | 'INTEREST_FROM_ARREARS_INCOME'
        | 'INTEREST_FROM_ARREARS_RECEIVABLE'
        | 'INTEREST_FROM_ARREARS_WRITE_OFF_EXPENSE'
    /**
     * The encoded key of the account that is mapped to the financialResource
     */
    glAccountKey: string
    /**
     * The key of the transaction rule that uses this rule
     */
    transactionChannelKey?: string | undefined
}

/**
 * Represents the request payload for creating a GL Account
 */
export interface GLAccountInput {
    /**
     * `TRUE` if manual journal entries are allowed, `FALSE` otherwise. This is only available for Detail Accounts.
     */
    allowManualJournalEntries?: boolean | undefined
    currency?: Currency | undefined
    /**
     * The description of the general ledger account.
     */
    description?: string | undefined
    /**
     * The general ledger code used to identify different account types. Also used for grouping and categorizing accounts. For example: an account code of '3201' is considered a subtype of '3200'.
     */
    glCode: string
    /**
     * The name of the general ledger account.
     */
    name: string
    /**
     * `TRUE` to strip trailing zeros, `FALSE` otherwise. Only available for Header Accounts.
     */
    stripTrailingZeros?: boolean | undefined
    /**
     * The general ledger account type.
     */
    type: 'ASSET' | 'LIABILITY' | 'EQUITY' | 'INCOME' | 'EXPENSE'
    /**
     * `DETAIL` for general ledger accounts that log transactions, and `HEADER` for general ledger accounts used for reporting and organizational purposes.
     */
    usage: 'DETAIL' | 'HEADER'
}

/**
 * Represents a general ledger journal entry.
 */
export interface GLJournalEntry {
    /**
     * The account associated with this journal entry. `Null` if the journal entry is not associated to any account.
     */
    accountKey?: string | undefined
    /**
     * The amount which was debited or credited in the organization's currency.
     */
    amount?: number | undefined
    /**
     * The key of the assigned branch for this general ledger journal entry.
     */
    assignedBranchKey?: string | undefined
    /**
     * The date and time when the general ledger journal entry was recorded.
     */
    bookingDate?: string | undefined
    /**
     * The creation date of the general ledger journal entry.
     */
    creationDate?: string | undefined
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The ID of the general ledger journal entry.
     */
    entryID?: number | undefined
    foreignAmount?: GLJournalEntryForeignAmount | undefined
    glAccount?: GLAccount | undefined
    /**
     * Optional notes entered by the user when they performed the journal entry.
     */
    notes?: string | undefined
    /**
     * The product associated with this journal entry. `Null` if the journal entry is not associated with any product.
     */
    productKey?: string | undefined
    /**
     * The product type that is referenced by the account key. `Null` if the journal entry is not associated to any product.
     */
    productType?: 'LOAN' | 'SAVINGS' | undefined
    /**
     * The entry key of the general ledger journal entry that reverses this general ledger journal entry. Null if the general ledger journal entry isn't reversed.
     */
    reversalEntryKey?: string | undefined
    /**
     * The transation ID, which is not unique.
     */
    transactionId?: string | undefined
    /**
     * The general ledger journal entry type, which may be debit or credit.
     */
    type?: 'DEBIT' | 'CREDIT' | undefined
    /**
     * The encoded key of the user that performed the transaction.
     */
    userKey?: string | undefined
}

/**
 * Represents the filtering criteria used for searching general ledger journal entries.
 */
export interface GLJournalEntryFilterCriteria {
    field:
        | 'productType'
        | 'glAccountKey'
        | 'userKey'
        | 'encodedKey'
        | 'entryId'
        | 'bookingDate'
        | 'creationDate'
        | 'transactionId'
        | 'glAccountId'
        | 'glAccountType'
        | 'source'
        | 'debit'
        | 'credit'
        | 'foreignDebit'
        | 'foreignCredit'
        | 'loanAccountId'
        | 'foreignCurrencyCode'
        | 'assignedBranchKey'
        | string
    /**
     * | **Operator**                | **Affected values**  | **Available for**                                                    |
     * |---------------               |----------------------|----------------------------------------------------------------------|
     * | EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |
     * | EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |
     * | MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |
     * | ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | STARTS_WITH                  | ONE_VALUE            | STRING                                                               |
     * | STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |
     * | IN                           | LIST                 | ENUM,KEY                                                             |
     * | TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |
     * | EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     * | NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     */
    operator:
        | 'EQUALS'
        | 'EQUALS_CASE_SENSITIVE'
        | 'DIFFERENT_THAN'
        | 'MORE_THAN'
        | 'LESS_THAN'
        | 'BETWEEN'
        | 'ON'
        | 'AFTER'
        | 'AFTER_INCLUSIVE'
        | 'BEFORE'
        | 'BEFORE_INCLUSIVE'
        | 'STARTS_WITH'
        | 'STARTS_WITH_CASE_SENSITIVE'
        | 'IN'
        | 'TODAY'
        | 'THIS_WEEK'
        | 'THIS_MONTH'
        | 'THIS_YEAR'
        | 'LAST_DAYS'
        | 'EMPTY'
        | 'NOT_EMPTY'
    /**
     * The second value to match the searching criteria, when the `BETWEEN` operator is used.
     */
    secondValue?: string | undefined
    /**
     * The value to match the searching criteria.
     */
    value?: string | undefined
    /**
     * List of values when the `IN` operator is used.
     */
    values?: string[] | undefined
}

/**
 * Represents the details of the general ledger journal entry amount posted in foreign currency.
 */
export interface GLJournalEntryForeignAmount {
    accountingRate?: AccountingRate | undefined
    /**
     * The amount of an accounting entry in foreign currency.
     */
    amount?: number | undefined
    currency?: Currency | undefined
}

/**
 * Represents the list of filtering criteria and the sorting criteria when searching general ledger journal entries.
 */
export interface GLJournalEntrySearchCriteria {
    /**
     * The list of filtering criteria.
     */
    filterCriteria?: GLJournalEntryFilterCriteria[] | undefined
    sortingCriteria?: GLJournalEntrySortingCriteria | undefined
}

export const GLJournalEntrySearchCriteria = {
    validate: GLJournalEntrySearchCriteriaValidator as ValidateFunction<GLJournalEntrySearchCriteria>,
    get schema() {
        return GLJournalEntrySearchCriteria.validate.schema
    },
    get errors() {
        return GLJournalEntrySearchCriteria.validate.errors ?? undefined
    },
    is: (o: unknown): o is GLJournalEntrySearchCriteria => GLJournalEntrySearchCriteria.validate(o) === true,
    parse: (o: unknown): { right: GLJournalEntrySearchCriteria } | { left: DefinedError[] } => {
        if (GLJournalEntrySearchCriteria.is(o)) {
            return { right: o }
        }
        return { left: (GLJournalEntrySearchCriteria.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the sorting criteria used for general ledger journal entries.
 */
export interface GLJournalEntrySortingCriteria {
    /**
     * The field that can be used to sort the selection. These fields can be from the enumerated values or you can specify a custom field using the format [customFieldSetId].[customFieldId].
     */
    field:
        | 'encodedKey'
        | 'entryId'
        | 'bookingDate'
        | 'creationDate'
        | 'transactionId'
        | 'glAccountName'
        | 'glAccountId'
        | 'glAccountType'
        | 'debit'
        | 'credit'
        | 'foreignDebit'
        | 'foreignCredit'
        | 'loanAccountId'
        | 'userName'
        | 'user'
        | 'branchName'
        | 'foreignCurrency'
    /**
     * The sorting order: `ASC` or `DESC`. The default order is `DESC`.
     */
    order?: 'ASC' | 'DESC' | undefined
}

type GlTypes = 'ASSET' | 'LIABILITY' | 'EQUITY' | 'INCOME' | 'EXPENSE'

/**
 * The funding settings, holds the settings regarding the funding for the loan product.
 */
export interface GracePeriodSettings {
    gracePeriod?: IntegerIntervalConstraints | undefined
    /**
     * The grace period type. Representing the type of grace period which is possible for a loan account.
     */
    gracePeriodType?: 'NONE' | 'PAY_INTEREST_ONLY' | 'INTEREST_FORGIVENESS' | undefined
}

/**
 * Represents a group. A group is a type of client that can represent a non-physical person such as a company client or a grouping of individual clients. A group can have its own accounts and can optionally have individual clients as members, in which case they also need to have an individual profile in Mambu.
 */
export interface Group {
    /**
     * The addresses associated with this group.
     */
    addresses?: Address[] | undefined
    /**
     * Key of the branch this group is assigned to.
     */
    assignedBranchKey?: string | undefined
    /**
     * Key of the centre this group is assigned to.
     */
    assignedCentreKey?: string | undefined
    /**
     * Key of the user this group is assigned to.
     */
    assignedUserKey?: string | undefined
    /**
     * The date the group was created.
     */
    creationDate?: string | undefined
    /**
     * The email address associated with the group.
     */
    emailAddress?: string | undefined
    /**
     * The encoded key of the group, which is auto generated, and must be unique.
     */
    encodedKey?: string | undefined
    /**
     * The members of this group.
     */
    groupMembers?: GroupMember[] | undefined
    /**
     * The name of the group.
     */
    groupName: string
    /**
     * A role which describes the intended use of a group in the system.
     */
    groupRoleKey?: string | undefined
    /**
     * The home phone number associated with the group.
     */
    homePhone?: string | undefined
    /**
     * The ID of the group, which can be generated and customized, but must be unique.
     */
    id?: string | undefined
    /**
     * The last date the group was updated.
     */
    lastModifiedDate?: string | undefined
    /**
     * Number of paid and closed (with 'obligations met') accounts for this client. When the closing operation is reverted, this is reduced.
     */
    loanCycle?: number | undefined
    /**
     * The migration event encoded key associated with this group.
     */
    migrationEventKey?: string | undefined
    /**
     * The mobile phone number associated with the group.
     */
    mobilePhone?: string | undefined
    /**
     * Extra notes about this group.
     */
    notes?: string | undefined
    /**
     * The preferred language associated with the group (used for the notifications).
     */
    preferredLanguage?:
        | 'ENGLISH'
        | 'PORTUGESE'
        | 'SPANISH'
        | 'RUSSIAN'
        | 'FRENCH'
        | 'GEORGIAN'
        | 'CHINESE'
        | 'INDONESIAN'
        | 'ROMANIAN'
        | 'BURMESE'
        | 'GERMAN'
        | 'PORTUGUESE_BRAZIL'
        | 'VIETNAMESE'
        | 'ITALIAN'
        | 'THAI'
        | 'NORWEGIAN'
        | 'PHRASE'
        | undefined
}

export const Group = {
    validate: GroupValidator as ValidateFunction<Group>,
    get schema() {
        return Group.validate.schema
    },
    get errors() {
        return Group.validate.errors ?? undefined
    },
    is: (o: unknown): o is Group => Group.validate(o) === true,
    parse: (o: unknown): { right: Group } | { left: DefinedError[] } => {
        if (Group.is(o)) {
            return { right: o }
        }
        return { left: (Group.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The unit that composes the list used for Groups searching
 */
export interface GroupFilterCriteria {
    field:
        | 'encodedKey'
        | 'id'
        | 'creationDate'
        | 'groupRoleKey'
        | 'branchKey'
        | 'centreKey'
        | 'creditOfficerKey'
        | 'groupName'
        | 'lastModifiedDate'
        | 'preferredLanguage'
        | 'depositsBalance'
        | 'loansBalance'
        | 'totalBalance'
        | 'numberOfMembers'
        | 'loanCycle'
        | string
    /**
     * | **Operator**                | **Affected values**  | **Available for**                                                    |
     * |---------------               |----------------------|----------------------------------------------------------------------|
     * | EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |
     * | EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |
     * | MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |
     * | ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | STARTS_WITH                  | ONE_VALUE            | STRING                                                               |
     * | STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |
     * | IN                           | LIST                 | ENUM,KEY                                                             |
     * | TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |
     * | EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     * | NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     */
    operator:
        | 'EQUALS'
        | 'EQUALS_CASE_SENSITIVE'
        | 'DIFFERENT_THAN'
        | 'MORE_THAN'
        | 'LESS_THAN'
        | 'BETWEEN'
        | 'ON'
        | 'AFTER'
        | 'AFTER_INCLUSIVE'
        | 'BEFORE'
        | 'BEFORE_INCLUSIVE'
        | 'STARTS_WITH'
        | 'STARTS_WITH_CASE_SENSITIVE'
        | 'IN'
        | 'TODAY'
        | 'THIS_WEEK'
        | 'THIS_MONTH'
        | 'THIS_YEAR'
        | 'LAST_DAYS'
        | 'EMPTY'
        | 'NOT_EMPTY'
    /**
     * The second value to match the searching criteria, when the `BETWEEN` operator is used.
     */
    secondValue?: string | undefined
    /**
     * The value to match the searching criteria.
     */
    value?: string | undefined
    /**
     * List of values when the `IN` operator is used.
     */
    values?: string[] | undefined
}

/**
 * Represents a group member. A group member is person that uses the services of the bank and is member of a group. Group members may have associated information, such as their client key and a list of roles they have within the group.
 */
export interface GroupMember {
    /**
     * The encoded key of the client assigned as member of the group.
     */
    clientKey: string
    /**
     * The group role name associated with a group member.
     */
    roles?: GroupRole[] | undefined
}

/**
 * Represents a group role. A group role, or group role name, is the role of a group member within the group - for example, money collector. One member could have many roles within a group.
 */
export interface GroupRole {
    /**
     * The encoded key of the group role name, which is auto generated, and unique.
     */
    encodedKey?: string | undefined
    /**
     * The group role name key.
     */
    groupRoleNameKey: string
    /**
     * The group role name.
     */
    roleName?: string | undefined
    /**
     * The group role name ID.
     */
    roleNameId?: string | undefined
}

/**
 * Wrapper that holds a list of filtering criteria and a sorting criteria for Groups client directed query
 */
export interface GroupSearchCriteria {
    /**
     * The list of filtering criteria
     */
    filterCriteria: GroupFilterCriteria[]
    sortingCriteria?: GroupSortingCriteria | undefined
}

export const GroupSearchCriteria = {
    validate: GroupSearchCriteriaValidator as ValidateFunction<GroupSearchCriteria>,
    get schema() {
        return GroupSearchCriteria.validate.schema
    },
    get errors() {
        return GroupSearchCriteria.validate.errors ?? undefined
    },
    is: (o: unknown): o is GroupSearchCriteria => GroupSearchCriteria.validate(o) === true,
    parse: (o: unknown): { right: GroupSearchCriteria } | { left: DefinedError[] } => {
        if (GroupSearchCriteria.is(o)) {
            return { right: o }
        }
        return { left: (GroupSearchCriteria.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The sorting criteria used for Groups search
 */
export interface GroupSortingCriteria {
    /**
     * The field to sort by. It can be a native field (one from the provided list) or otherwise can specify a custom field definitionusing the format [customFieldSetId].[customFieldId].
     */
    field:
        | 'encodedKey'
        | 'id'
        | 'creationDate'
        | 'groupName'
        | 'lastModifiedDate'
        | 'depositsBalance'
        | 'loansBalance'
        | 'totalBalance'
        | 'loanCycle'
    /**
     * The sorting order: `ASC` or `DESC`. The default order is `DESC`.
     */
    order?: 'ASC' | 'DESC' | undefined
}

/**
 * Guarantor, holds information about a client guaranty entry. It can be defined based on another client which guarantees (including or not a savings account whether it is a client of the organization using Mambu or not) or based on a value the client holds (an asset)
 */
export interface Guarantor {
    /**
     * The amount used by the client for the guaranty
     */
    amount: number
    /**
     * The name of a value the client guarantees with (populated when the guaranty type is ASSET)
     */
    assetName?: string | undefined
    /**
     * The key of the deposit account used by the guarantor (populated when the guaranty type is GUARANTOR). It can be null.
     */
    depositAccountKey?: string | undefined
    /**
     * The encoded key of the security, auto generated, unique.
     */
    encodedKey?: string | undefined
    /**
     * The key of the client/group used as the guarantor.
     */
    guarantorKey: string
    /**
     * The type of the guarantor (client/group)
     */
    guarantorType: 'CLIENT' | 'GROUP'
}

/**
 * Represents the holiday.
 */
export interface Holiday {
    /**
     * The date when the holiday was created.
     */
    creationDate?: string | undefined
    /**
     * The date the holiday takes place.
     */
    date?: string | undefined
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The ID of the holiday.
     */
    id?: number | undefined
    /**
     * `TRUE` if a holiday is annually recurring, `FALSE` otherwise.
     */
    isAnnuallyRecurring?: boolean | undefined
    /**
     * The name of the holiday.
     */
    name?: string | undefined
}

export const Holiday = {
    validate: HolidayValidator as ValidateFunction<Holiday>,
    get schema() {
        return Holiday.validate.schema
    },
    get errors() {
        return Holiday.validate.errors ?? undefined
    },
    is: (o: unknown): o is Holiday => Holiday.validate(o) === true,
    parse: (o: unknown): { right: Holiday } | { left: DefinedError[] } => {
        if (Holiday.is(o)) {
            return { right: o }
        }
        return { left: (Holiday.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the holidays of the organization.
 */
export interface Holidays {
    /**
     * The general holidays of the organization.
     */
    holidays?: Holiday[] | undefined
    /**
     * The non-working days of the organization.
     */
    nonWorkingDays?: NonWorkingDays2[] | undefined
}

export const Holidays = {
    validate: HolidaysValidator as ValidateFunction<Holidays>,
    get schema() {
        return Holidays.validate.schema
    },
    get errors() {
        return Holidays.validate.errors ?? undefined
    },
    is: (o: unknown): o is Holidays => Holidays.validate(o) === true,
    parse: (o: unknown): { right: Holidays } | { left: DefinedError[] } => {
        if (Holidays.is(o)) {
            return { right: o }
        }
        return { left: (Holidays.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * An Id document represents a document that can be used to identify a person like a passport, a drivers license an id card etc.
 */
export interface IdentificationDocument {
    /**
     * A list containing information about the attached files for this document
     */
    attachments?: Document[] | undefined
    /**
     * The encoded key of the client that owns this document
     */
    clientKey?: string | undefined
    /**
     * The id of the document
     */
    documentId: string
    /**
     * The type of the document, Passport, Id card Drivers license, etc.
     */
    documentType: string
    /**
     * The encoded key of the document, generated, unique
     */
    encodedKey?: string | undefined
    /**
     * Encoded key of the template used for this document
     */
    identificationDocumentTemplateKey?: string | undefined
    /**
     * This document's index in the list of documents
     */
    indexInList?: number | undefined
    /**
     * Authority that issued the document, eg. Police
     */
    issuingAuthority?: string | undefined
    /**
     * Date when the validity of the document ends
     */
    validUntil?: string | undefined
}

/**
 * Represents a template for identification documents.
 */
export interface IdentificationDocumentTemplate {
    /**
     * `TRUE` if a template allows files to be attached, `FALSE` otherwise.
     */
    allowAttachments?: boolean | undefined
    /**
     * The ID template constraint to define the ID number length and format. Templates consist of the characters `#`, `@`, and `$`, where `#` specifies a number, `@` a letter, and `$` a number or a letter.
     */
    documentIdTemplate?: string | undefined
    /**
     * The type of the document. For example, passport.
     */
    documentType?: string | undefined
    /**
     * The encoded key of the ID template. It is auto generated and unique.
     */
    encodedKey?: string | undefined
    /**
     * The unique identifier for the template.
     */
    id?: string | undefined
    /**
     * The authority that issued the document.
     */
    issuingAuthority?: string | undefined
    /**
     * `TRUE` if a template is mandatory for all the individual clients, `FALSE` otherwise.
     */
    mandatory?: boolean | undefined
}

/**
 * Represents an index rate.
 */
export interface IndexRate {
    /**
     * The index rate source that the index rate belongs to.
     */
    assignedIndexRateSourceKey?: string | undefined
    /**
     * The encoded key of the index rate, which is auto generated, and unique.
     */
    encodedKey?: string | undefined
    /**
     * The ID of the index rate, which can be generated and customized, and must be unique.
     */
    id?: string | undefined
    /**
     * The notes or description attached to this object.
     */
    notes?: string | undefined
    /**
     * The percentage value of the index rate.
     */
    rate?: number | undefined
    /**
     * The date when the index rate starts being the active rate for its source.
     */
    startDate?: string | undefined
    /**
     * The key for the user that last modified the index rate.
     */
    userKey?: string | undefined
}

export const IndexRate = {
    validate: IndexRateValidator as ValidateFunction<IndexRate>,
    get schema() {
        return IndexRate.validate.schema
    },
    get errors() {
        return IndexRate.validate.errors ?? undefined
    },
    is: (o: unknown): o is IndexRate => IndexRate.validate(o) === true,
    parse: (o: unknown): { right: IndexRate } | { left: DefinedError[] } => {
        if (IndexRate.is(o)) {
            return { right: o }
        }
        return { left: (IndexRate.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents an index rate source.
 */
export interface IndexRateSource {
    /**
     * The creation date of the index rate source
     */
    creationDate?: string | undefined
    /**
     * The encoded key of the index rate source, which is auto generated, and unique.
     */
    encodedKey?: string | undefined
    /**
     * The ID of the index rate source, which can be generated and customized, and must be unique.
     */
    id?: string | undefined
    /**
     * The last date this rate source was modified
     */
    lastModifiedDate?: string | undefined
    /**
     * The name of the index rate source.
     */
    name?: string | undefined
    /**
     * The notes about the the index rate source.
     */
    notes?: string | undefined
    /**
     * The type of index rate source.
     */
    type?: 'INTEREST_RATE' | 'TAX_RATE' | 'WITHHOLDING_TAX_RATE' | 'PRINCIPAL_TAX_RATE' | undefined
}

export const IndexRateSource = {
    validate: IndexRateSourceValidator as ValidateFunction<IndexRateSource>,
    get schema() {
        return IndexRateSource.validate.schema
    },
    get errors() {
        return IndexRateSource.validate.errors ?? undefined
    },
    is: (o: unknown): o is IndexRateSource => IndexRateSource.validate(o) === true,
    parse: (o: unknown): { right: IndexRateSource } | { left: DefinedError[] } => {
        if (IndexRateSource.is(o)) {
            return { right: o }
        }
        return { left: (IndexRateSource.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents a single installment details structure.
 */
export interface Installment {
    /**
     * The installment due date.
     */
    dueDate?: string | undefined
    /**
     * The encoded key of the installment, which is auto generated, and unique.
     */
    encodedKey?: string | undefined
    /**
     * The expected closing balance is the remaining amount per installment only applicable for interest only equal installment products.
     */
    expectedClosingBalance?: number | undefined
    fee?: InstallmentFee | undefined
    /**
     * The breakdown of the fee amounts that have been applied to the loan account.
     */
    feeDetails?: InstallmentFeeDetails[] | undefined
    interest?: InstallmentAllocationElementTaxableAmount | undefined
    /**
     * The interest accrued calculated on previous repayment closing balance only applicable interest only equal installment products.
     */
    interestAccrued?: number | undefined
    /**
     * `TRUE` if a payment holiday is offered for the installment, `FALSE` otherwise.
     */
    isPaymentHoliday?: boolean | undefined
    /**
     * The installment last paid date.
     */
    lastPaidDate?: string | undefined
    /**
     * The order number of an installment among all the installments generated for a loan. Loan installments are put in ascending order by due date. The order number only applies to the content of a particular JSON response therefore it is not unique.
     */
    number?: string | undefined
    /**
     * The parent account key of the installment.
     */
    parentAccountKey?: string | undefined
    penalty?: InstallmentAllocationElementTaxableAmount | undefined
    principal?: InstallmentAllocationElementAmount | undefined
    /**
     * The installment repaid date.
     */
    repaidDate?: string | undefined
    /**
     * The installment state.
     */
    state?: 'PENDING' | 'LATE' | 'PAID' | 'PARTIALLY_PAID' | 'GRACE' | undefined
}

/**
 * Represents an installment allocation element amount structure.
 */
export interface InstallmentAllocationElementAmount {
    amount?: Amount | undefined
}

/**
 * Represents an installment allocation element taxable amount structure.
 */
export interface InstallmentAllocationElementTaxableAmount {
    amount?: Amount | undefined
    tax?: Amount | undefined
}

/**
 * Represents an installment fee structure.
 */
export interface InstallmentFee {
    amount?: FeeAmount | undefined
    tax?: Amount | undefined
}

/**
 * Represents fee details for an installment.
 */
export interface InstallmentFeeDetails {
    amount?: AmountWithReduced | undefined
    /**
     * The encoded key of the predefined fee, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * The id of the fee, provided by the client
     */
    id?: string | undefined
    /**
     * The name of the fee
     */
    name?: string | undefined
    tax?: AmountWithReduced | undefined
}

/**
 * Decimal integer, like min/max/default.
 */
export interface IntegerInterval {
    /**
     * The default value, will be used in case no other value was filled in by the user.
     */
    defaultValue?: number | undefined
    /**
     * The maximum value.
     */
    maxValue?: number | undefined
    /**
     * The minimum value.
     */
    minValue?: number | undefined
}

/**
 * Decimal integer, like min/max/default.
 */
export interface IntegerIntervalConstraints {
    /**
     * The default value, will be used in case no other value was filled in by the user.
     */
    defaultValue?: number | undefined
    /**
     * The encoded key of the integer constraint, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * The maximum value.
     */
    maxValue?: number | undefined
    /**
     * The minimum value.
     */
    minValue?: number | undefined
}

/**
 * Interest Availability of a Deposit Account
 */
export interface InterestAccountSettingsAvailability {
    /**
     * The encoded key of the Interest Availability, auto generated, unique.
     */
    encodedKey?: string | undefined
    interestRateSettings: DepositAccountInterestAvailabilitySettings
    /**
     * Start date of the Interest Availability.
     */
    startDate: string
    /**
     * Type of the interest.
     */
    type: 'INTEREST' | 'OVERDRAFT' | 'TECHNICAL_OVERDRAFT'
}

export const InterestAccountSettingsAvailability = {
    validate: InterestAccountSettingsAvailabilityValidator as ValidateFunction<InterestAccountSettingsAvailability>,
    get schema() {
        return InterestAccountSettingsAvailability.validate.schema
    },
    get errors() {
        return InterestAccountSettingsAvailability.validate.errors ?? undefined
    },
    is: (o: unknown): o is InterestAccountSettingsAvailability => InterestAccountSettingsAvailability.validate(o) === true,
    parse: (o: unknown): { right: InterestAccountSettingsAvailability } | { left: DefinedError[] } => {
        if (InterestAccountSettingsAvailability.is(o)) {
            return { right: o }
        }
        return { left: (InterestAccountSettingsAvailability.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Interest Availability of a Deposit Account
 */
export interface InterestAccountSettingsAvailabilityResponse {
    /**
     * The encoded key of the Interest Availability, auto generated, unique.
     */
    encodedKey?: string | undefined
    interestRateSettings?: DepositAccountInterestRateSettings | undefined
    /**
     * Start date of the Interest Availability.
     */
    startDate?: string | undefined
    /**
     * Type of the interest.
     */
    type?: 'INTEREST' | 'OVERDRAFT' | 'TECHNICAL_OVERDRAFT' | undefined
}

export const InterestAccountSettingsAvailabilityResponse = {
    validate:
        InterestAccountSettingsAvailabilityResponseValidator as ValidateFunction<InterestAccountSettingsAvailabilityResponse>,
    get schema() {
        return InterestAccountSettingsAvailabilityResponse.validate.schema
    },
    get errors() {
        return InterestAccountSettingsAvailabilityResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is InterestAccountSettingsAvailabilityResponse =>
        InterestAccountSettingsAvailabilityResponse.validate(o) === true,
    parse: (o: unknown): { right: InterestAccountSettingsAvailabilityResponse } | { left: DefinedError[] } => {
        if (InterestAccountSettingsAvailabilityResponse.is(o)) {
            return { right: o }
        }
        return { left: (InterestAccountSettingsAvailabilityResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Interest Availability of a Deposit Account
 */
export interface InterestAccountSettingsAvailabilityUpdate {
    /**
     * The encoded key of the Interest Availability, auto generated, unique.
     */
    encodedKey?: string | undefined
    interestRateSettings: DepositAccountInterestAvailabilitySettings
}

export const InterestAccountSettingsAvailabilityUpdate = {
    validate: InterestAccountSettingsAvailabilityUpdateValidator as ValidateFunction<InterestAccountSettingsAvailabilityUpdate>,
    get schema() {
        return InterestAccountSettingsAvailabilityUpdate.validate.schema
    },
    get errors() {
        return InterestAccountSettingsAvailabilityUpdate.validate.errors ?? undefined
    },
    is: (o: unknown): o is InterestAccountSettingsAvailabilityUpdate =>
        InterestAccountSettingsAvailabilityUpdate.validate(o) === true,
    parse: (o: unknown): { right: InterestAccountSettingsAvailabilityUpdate } | { left: DefinedError[] } => {
        if (InterestAccountSettingsAvailabilityUpdate.is(o)) {
            return { right: o }
        }
        return { left: (InterestAccountSettingsAvailabilityUpdate.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents an interest accrual breakdown entry.
 */
export interface InterestAccrualBreakdown {
    /**
     * The loan or deposit account ID for which interest is accrued.
     */
    accountId?: string | undefined
    /**
     * The encoded key of the loan or deposit account for which interest is accrued.
     */
    accountKey?: string | undefined
    /**
     * The interest accrued amount for the account in this entry.
     */
    amount?: number | undefined
    /**
     * The booking date in the organization's timezone.
     */
    bookingDate?: string | undefined
    /**
     * The encoded key of the account's branch.
     */
    branchKey?: string | undefined
    /**
     * The name of the account's branch
     */
    branchName?: string | undefined
    /**
     * The creation date and time of the entry in UTC.
     */
    creationDate?: string | undefined
    /**
     * The generated ID of the interest accrual per account entry.
     */
    entryId?: number | undefined
    /**
     * Debit or Credit.
     */
    entryType?: string | undefined
    foreignAmount?: ForeignAmount | undefined
    /**
     * The ID of the general ledger account.
     */
    glAccountId?: string | undefined
    /**
     * The encoded key of the general ledger account used for logging the interest accrual.
     */
    glAccountKey?: string | undefined
    /**
     * The name of the general ledger account.
     */
    glAccountName?: string | undefined
    /**
     * The general ledger account type, which can be: `ASSET`, `LIABILITY`, `EQUITY`, `INCOME`, or `EXPENSE`.
     */
    glAccountType?: string | undefined
    /**
     * The ID of the general ledger journal entry that logged the interest accrual sum for all accounts of the same product.
     */
    parentEntryId?: number | undefined
    /**
     * The ID of the account's product.
     */
    productId?: string | undefined
    /**
     * The encoded key of the account's product.
     */
    productKey?: string | undefined
    /**
     * The product type.
     */
    productType?: string | undefined
    /**
     * The journal entry transaction ID.
     */
    transactionId?: string | undefined
}

/**
 * Represents the filter criteria used for searching interest accrual entries.
 */
export interface InterestAccrualFilterCriteria {
    field:
        | 'entryId'
        | 'glAccountKey'
        | 'parentEntryId'
        | 'productType'
        | 'bookingDate'
        | 'creationDate'
        | 'transactionId'
        | 'glAccountId'
        | 'glAccountType'
        | 'debit'
        | 'credit'
        | 'branchKey'
        | 'accountKey'
        | 'productKey'
        | 'accountId'
        | 'foreignCredit'
        | 'foreignDebit'
        | 'foreignCurrencyCode'
        | string
    /**
     * | **Operator**                | **Affected values**  | **Available for**                                                    |
     * |---------------               |----------------------|----------------------------------------------------------------------|
     * | EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |
     * | EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |
     * | MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |
     * | ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | STARTS_WITH                  | ONE_VALUE            | STRING                                                               |
     * | STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |
     * | IN                           | LIST                 | ENUM,KEY                                                             |
     * | TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |
     * | EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     * | NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     */
    operator:
        | 'EQUALS'
        | 'EQUALS_CASE_SENSITIVE'
        | 'DIFFERENT_THAN'
        | 'MORE_THAN'
        | 'LESS_THAN'
        | 'BETWEEN'
        | 'ON'
        | 'AFTER'
        | 'AFTER_INCLUSIVE'
        | 'BEFORE'
        | 'BEFORE_INCLUSIVE'
        | 'STARTS_WITH'
        | 'STARTS_WITH_CASE_SENSITIVE'
        | 'IN'
        | 'TODAY'
        | 'THIS_WEEK'
        | 'THIS_MONTH'
        | 'THIS_YEAR'
        | 'LAST_DAYS'
        | 'EMPTY'
        | 'NOT_EMPTY'
    /**
     * The second value to match the searching criteria, when the `BETWEEN` operator is used.
     */
    secondValue?: string | undefined
    /**
     * The value to match the searching criteria.
     */
    value?: string | undefined
    /**
     * List of values when the `IN` operator is used.
     */
    values?: string[] | undefined
}

/**
 * Represents the filtering criteria list and sorting criteria for searching interest accrual entries.
 */
export interface InterestAccrualSearchCriteria {
    /**
     * The list of filtering criteria.
     */
    filterCriteria?: InterestAccrualFilterCriteria[] | undefined
    sortingCriteria?: InterestAccrualSortingCriteria | undefined
}

export const InterestAccrualSearchCriteria = {
    validate: InterestAccrualSearchCriteriaValidator as ValidateFunction<InterestAccrualSearchCriteria>,
    get schema() {
        return InterestAccrualSearchCriteria.validate.schema
    },
    get errors() {
        return InterestAccrualSearchCriteria.validate.errors ?? undefined
    },
    is: (o: unknown): o is InterestAccrualSearchCriteria => InterestAccrualSearchCriteria.validate(o) === true,
    parse: (o: unknown): { right: InterestAccrualSearchCriteria } | { left: DefinedError[] } => {
        if (InterestAccrualSearchCriteria.is(o)) {
            return { right: o }
        }
        return { left: (InterestAccrualSearchCriteria.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The sorting criteria used for sorting interest accrual entries.
 */
export interface InterestAccrualSortingCriteria {
    /**
     * The field to use as the sorting criteria.
     */
    field:
        | 'entryId'
        | 'parentEntryId'
        | 'bookingDate'
        | 'creationDate'
        | 'transactionId'
        | 'glAccountType'
        | 'debit'
        | 'credit'
        | 'accountId'
        | 'foreignCredit'
        | 'foreignDebit'
        | 'foreignCurrencyCode'
    /**
     * The sorting order: `ASC` or `DESC`. The default order is `DESC`.
     */
    order?: 'ASC' | 'DESC' | undefined
}

/**
 * Defines the interest payment settings for the deposit product and for deposits created based on this product
 */
export interface InterestPaymentSettings {
    /**
     * List of all dates on which the interest is payed into deposit account
     */
    interestPaymentDates?: MonthAndDay[] | undefined
    /**
     * Specifies when the interest should be paid to the deposit account
     */
    interestPaymentPoint?:
        | 'FIRST_DAY_OF_MONTH'
        | 'EVERY_WEEK'
        | 'EVERY_OTHER_WEEK'
        | 'EVERY_MONTH'
        | 'EVERY_3_MONTHS'
        | 'ON_FIXED_DATES'
        | 'DAILY'
        | 'ANNUALLY'
        | 'BI_ANNUALLY'
        | 'ON_ACCOUNT_MATURITY'
        | undefined
}

/**
 * The interest settings, defines constraints regarding interest that will be used on the loan account created based on this product.
 */
export interface InterestProductSettings {
    /**
     * If the product supports this option, specify if the interest should be accrued after the account maturity date
     */
    accrueInterestAfterMaturity?: boolean | undefined
    /**
     * Indicator whether the loan product allows negative values for interest rate or interest spread
     */
    allowNegativeInterestRate?: boolean | undefined
    /**
     * The encoded key of the interest rate tier, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * Index rate source key.
     */
    indexSourceKey?: string | undefined
    /**
     * The interval used for determining how often is interest charged
     */
    interestChargeFrequency?:
        | 'ANNUALIZED'
        | 'EVERY_MONTH'
        | 'EVERY_FOUR_WEEKS'
        | 'EVERY_WEEK'
        | 'EVERY_DAY'
        | 'EVERY_X_DAYS'
        | undefined
    /**
     * the count of units to apply over the interval
     */
    interestChargeFrequencyCount?: number | undefined
    interestRate?: DecimalInterval | undefined
    /**
     * Interest spread + index interest rate can't be more than this amount (valid only for index interest rate products).
     */
    interestRateCeilingValue?: number | undefined
    /**
     * Interest spread + index interest rate can't be less than this amount (valid only for index interest rate products).
     */
    interestRateFloorValue?: number | undefined
    /**
     * Interest rate review frequency unit count
     */
    interestRateReviewCount?: number | undefined
    /**
     * Interest rate review frequency measurement unit
     */
    interestRateReviewUnit?: 'DAYS' | 'WEEKS' | 'MONTHS' | undefined
    /**
     * Interest calculation method: fixed or (interest spread + active organization index interest rate)
     */
    interestRateSource?: 'FIXED_INTEREST_RATE' | 'INDEX_INTEREST_RATE' | undefined
    /**
     * The option for how is the interest rate determined when being accrued for an account
     */
    interestRateTerms?: 'FIXED' | 'TIERED' | 'TIERED_PERIOD' | 'TIERED_BAND' | undefined
    /**
     * The list of interest rate tiers available for the current settings instance
     */
    interestRateTiers?: InterestRateTier[] | undefined
}

/**
 * Used or TIERED interest rates, holds the values to define how the interest is computed
 */
export interface InterestRateTier {
    /**
     * The encoded key of the interest rate tier, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * The top-limit value for the account balance in order to determine if this tier is used or not
     */
    endingBalance?: number | undefined
    /**
     * The rate used for computing the interest for an account which has the balance less than the ending balance
     */
    interestRate: number
}

/**
 * The interest settings, holds all the properties regarding interests for the loan account.
 */
export interface InterestSettings {
    /**
     * Adjustable interest rates settings for loan account
     */
    accountInterestRateSettings?: AccountInterestRateSettings[] | undefined
    /**
     * The accrue interest after maturity. If the product support this option, specify if the interest should be accrued after the account maturity date.
     */
    accrueInterestAfterMaturity?: boolean | undefined
    /**
     * Indicates whether late interest is accrued for this loan account
     */
    accrueLateInterest?: boolean | undefined
    /**
     * The effective interest rate. Represents the interest rate for the loan accounts with semi-annually compounding product.
     */
    effectiveInterestRate?: number | undefined
    interestApplicationDays?: DaysInMonth | undefined
    /**
     * The interest application method. Represents the interest application method that determines whether the interest gets applied on the account's disbursement or on each repayment.
     */
    interestApplicationMethod?: 'AFTER_DISBURSEMENT' | 'REPAYMENT_DUE_DATE' | 'FIXED_DAYS_OF_MONTH' | undefined
    /**
     * The interest balance calculation method. Represents the option which determines the way the balance for the account's interest is computed.
     */
    interestBalanceCalculationMethod?: 'ONLY_PRINCIPAL' | 'PRINCIPAL_AND_INTEREST' | undefined
    /**
     * The interest calculation method. Holds the type of interest calculation method.
     */
    interestCalculationMethod?: 'FLAT' | 'DECLINING_BALANCE' | 'DECLINING_BALANCE_DISCOUNTED' | 'EQUAL_INSTALLMENTS' | undefined
    /**
     * The interest change frequency. Holds the possible values for how often is interest charged on loan or deposit accounts
     */
    interestChargeFrequency?:
        | 'ANNUALIZED'
        | 'EVERY_MONTH'
        | 'EVERY_FOUR_WEEKS'
        | 'EVERY_WEEK'
        | 'EVERY_DAY'
        | 'EVERY_X_DAYS'
        | undefined
    /**
     * The interest rate. Represents the interest rate for the loan account. The interest on loans is accrued on a daily basis, which allows charging the clients only for the days they actually used the loan amount.
     */
    interestRate?: number | undefined
    /**
     * Interest rate update frequency unit count.
     */
    interestRateReviewCount?: number | undefined
    /**
     * The interest rate review unit. Defines the interest rate update frequency measurement unit.
     */
    interestRateReviewUnit?: 'DAYS' | 'WEEKS' | 'MONTHS' | undefined
    /**
     * The interest rate source. Represents the interest calculation method: fixed or (interest spread + active organization index interest rate)
     */
    interestRateSource?: 'FIXED_INTEREST_RATE' | 'INDEX_INTEREST_RATE' | undefined
    /**
     * Interest to be added to active organization index interest rate in order to find out actual interest rate
     */
    interestSpread?: number | undefined
    /**
     * The possible values for how we compute and apply the interest
     */
    interestType?: 'SIMPLE_INTEREST' | 'CAPITALIZED_INTEREST' | 'COMPOUNDING_INTEREST' | undefined
    pmtAdjustmentThreshold?: PMTAdjustmentThreshold | undefined
}

/**
 * The interest settings, holds all the properties regarding interests for the loan account.
 */
export interface InterestSettingsForSchedulePreview {
    /**
     * The interest settings details for schedule preview.
     */
    accountInterestRateSettings?: AccountInterestRateSettings[] | undefined
    /**
     * The interest rate. Represents the interest rate for the loan account. The interest on loans is accrued on a daily basis, which allows charging the clients only for the days they actually used the loan amount.
     */
    interestRate?: number | undefined
    /**
     * Interest to be added to active organization index interest rate in order to find out actual interest rate
     */
    interestSpread?: number | undefined
}

/**
 * Constraints and automated actions and that will be applied on the accounts.
 */
export interface InternalControls {
    /**
     * Specifies the number of days for an account to be fully paid in order to auto close it.
     */
    dormancyPeriodDays?: number | undefined
    fourEyesPrinciple?: FourEyesPrinciple | undefined
    lockSettings?: LockSettings | undefined
}

/**
 * Contains the details about an investor fund including fields like encoded key, guarantor type, amount and guarantor key
 */
export interface InvestorFund {
    /**
     * The amount used by the client for the guaranty
     */
    amount: number
    /**
     * The name of a value the client guarantees with (populated when the guaranty type is ASSET)
     */
    assetName?: string | undefined
    /**
     * The key of the deposit account used by the guarantor (populated when the guaranty type is GUARANTOR). It can be null.
     */
    depositAccountKey?: string | undefined
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The key of the client/group used as the guarantor.
     */
    guarantorKey: string
    /**
     * The type of the guarantor (client/group)
     */
    guarantorType: 'CLIENT' | 'GROUP'
    /**
     * Investor fund unique identifier. All versions of an investor fund will have same id.
     */
    id?: string | undefined
    /**
     * The constraint minimum value
     */
    interestCommission?: number | undefined
    /**
     * Percentage of loan shares this investor owns
     */
    sharePercentage?: number | undefined
}

/**
 * The details of the linked financial transaction triggered by the card transaction.
 */
export interface LinkedTransaction {
    /**
     * The encodedKey of the linked financial transaction.
     */
    linkedTransactionKey?: string | undefined
    /**
     * The type of the linked transaction (Deposit / Loan).
     */
    linkedTransactionType?: 'LOAN' | 'DEPOSIT' | undefined
}

/**
 * Represents a loan account. A loan account defines the amount that your organization lends to a client. The terms and conditions of a loan account are defined by a loan product. In a loan account, Mambu stores all the information related to disbursements, repayments, interest rates, and withdrawals.
 */
export interface LoanAccount {
    accountArrearsSettings?: AccountArrearsSettings | undefined
    /**
     * The encoded key of the account holder.
     */
    accountHolderKey: string
    /**
     * The type of the account holder.
     */
    accountHolderType: 'CLIENT' | 'GROUP'
    /**
     * The state of the loan account.
     */
    accountState?: 'PARTIAL_APPLICATION' | 'PENDING_APPROVAL' | 'APPROVED' | 'ACTIVE' | 'ACTIVE_IN_ARREARS' | 'CLOSED' | undefined
    /**
     * A second state for the loan account. Beside the account state, a second substate is sometimes necessary to provide more information about the exact lifecycle state of a loan account.For example, even if the account state of a loan account is `ACTIVE`, it can also have a substate of `LOCKED`.
     */
    accountSubState?:
        | 'PARTIALLY_DISBURSED'
        | 'LOCKED'
        | 'LOCKED_CAPPING'
        | 'REFINANCED'
        | 'RESCHEDULED'
        | 'WITHDRAWN'
        | 'REPAID'
        | 'REJECTED'
        | 'WRITTEN_OFF'
        | 'TERMINATED'
        | undefined
    /**
     * The amount of interest that has been accrued in the loan account.
     */
    accruedInterest?: number | undefined
    /**
     * The accrued penalty, represents the amount of penalty that has been accrued in the loan account.
     */
    accruedPenalty?: number | undefined
    /**
     * The encoded key of the transaction that activated the loan account.
     */
    activationTransactionKey?: string | undefined
    /**
     * DEPRECATED - Will always be false.
     */
    allowOffset?: boolean | undefined
    /**
     * The date the loan account was approved.
     */
    approvedDate?: string | undefined
    /**
     * The arrears tolerance (period or day of month) depending on the product settings.
     */
    arrearsTolerancePeriod?: number | undefined
    /**
     * The list of assets associated with the current loan account.
     */
    assets?: Asset[] | undefined
    /**
     * The key of the branch this loan account is assigned to. The branch is set to unassigned if no branch field is set.
     */
    assignedBranchKey?: string | undefined
    /**
     * The key of the centre this account is assigned to.
     */
    assignedCentreKey?: string | undefined
    /**
     * The key of the user this loan account is assigned to.
     */
    assignedUserKey?: string | undefined
    balances?: Balances | undefined
    /**
     * The date the loan was closed.
     */
    closedDate?: string | undefined
    /**
     * The date the loan account was created.
     */
    creationDate?: string | undefined
    /**
     * The key to the line of credit where this account is registered to.
     */
    creditArrangementKey?: string | undefined
    currency?: Currency | undefined
    /**
     * The number of days the loan account is in arrears.
     */
    daysInArrears?: number | undefined
    /**
     * The number of days a repayment for the loan account is late.
     */
    daysLate?: number | undefined
    disbursementDetails?: DisbursementDetails | undefined
    /**
     * The encoded key of the loan account, it is auto generated, and must be unique.
     */
    encodedKey?: string | undefined
    /**
     * The list of funds associated with the loan account.
     */
    fundingSources?: InvestorFund[] | undefined
    /**
     * Shows whether the repayment transactions with entry date set in the future are allowed or not for this loan account.
     */
    futurePaymentsAcceptance?: 'NO_FUTURE_PAYMENTS' | 'ACCEPT_FUTURE_PAYMENTS' | 'ACCEPT_OVERPAYMENTS' | undefined
    /**
     * The list of guarantees associated with the loan account.
     */
    guarantors?: Guarantor[] | undefined
    /**
     * The ID of the loan account, it can be generated and customized, and must be unique.
     */
    id?: string | undefined
    /**
     * The interest that is accrued in the current billing cycle.
     */
    interestAccruedInBillingCycle?: number | undefined
    /**
     * The value of the interest booked by the organization from the accounts funded by investors. Null if the funds are not enabled.
     */
    interestCommission?: number | undefined
    /**
     * The amount of interest from arrears that has been accrued in the loan account.
     */
    interestFromArrearsAccrued?: number | undefined
    interestSettings?: InterestSettings | undefined
    /**
     * The date the loan account has last been evaluated for interest, principal, fees, and penalties calculations expressed in the organization time format and time zone.
     */
    lastAccountAppraisalDate?: string | undefined
    /**
     * The date of the last time the loan account had interest applied (stored to interest balance), expressed in the organization time format and time zone.
     */
    lastInterestAppliedDate?: string | undefined
    /**
     * The date the interest was reviewed last time, stored in the organization time format and time zone.
     */
    lastInterestReviewDate?: string | undefined
    /**
     * The date when the loan account was set for the last time in the `LOCKED` state expressed in the organization time format and time zone. If null, the account is not locked anymore.
     */
    lastLockedDate?: string | undefined
    /**
     * The last date the loan was updated.
     */
    lastModifiedDate?: string | undefined
    /**
     * The date when the loan account was set to last standing or null; if never set, it is expressed in your organization time format and time zone.
     */
    lastSetToArrearsDate?: string | undefined
    /**
     * The date the tax rate on the loan account was last checked, expressed in the organization time format and time zone.
     */
    lastTaxRateReviewDate?: string | undefined
    /**
     * The overdue payments recalculation method inherited from the loan product on which this loan account is based.
     */
    latePaymentsRecalculationMethod?:
        | 'OVERDUE_INSTALLMENTS_INCREASE'
        | 'LAST_INSTALLMENT_INCREASE'
        | 'NO_RECALCULATION'
        | undefined
    /**
     * The loan amount.
     */
    loanAmount: number
    /**
     * The name of the loan account.
     */
    loanName?: string | undefined
    /**
     * The locked account total due type.
     */
    lockedAccountTotalDueType?: 'BALANCE_AMOUNT' | 'DUE_AMOUNT_ON_LATE_INSTALLMENTS' | undefined
    /**
     * A list with operations which are locked when the account is in the AccountState.LOCKED substate.
     */
    lockedOperations?: ('APPLY_INTEREST' | 'APPLY_FEES' | 'APPLY_PENALTIES')[] | undefined
    /**
     * The migration event encoded key associated with this loan account. If this account was imported, track which 'migration event' they came from.
     */
    migrationEventKey?: string | undefined
    /**
     * Adjust the interest for the first repayment when the first repayment period is different than the repayment frequency
     */
    modifyInterestForFirstInstallment?: boolean | undefined
    /**
     * The notes about this loan account.
     */
    notes?: string | undefined
    /**
     * The key of the original rescheduled or refinanced loan account.
     */
    originalAccountKey?: string | undefined
    /**
     * The amount of interest that has been accrued during payment holidays in the loan account.
     */
    paymentHolidaysAccruedInterest?: number | undefined
    /**
     * The interest payment method that determines whether the payments are made horizontally (on the repayments) or vertically (on the loan account).
     */
    paymentMethod?: 'HORIZONTAL' | 'VERTICAL' | undefined
    penaltySettings?: PenaltySettings | undefined
    /**
     * The list with manual fees planned on the installments of the loan account.
     */
    plannedInstallmentFees?: PlannedInstallmentFee[] | undefined
    prepaymentSettings?: PrepaymentSettings | undefined
    principalPaymentSettings?: PrincipalPaymentAccountSettings | undefined
    /**
     * The key for the type of loan product that this loan account is based on.
     */
    productTypeKey: string
    redrawSettings?: LoanAccountRedrawSettings | undefined
    /**
     * The key pointing to where this loan account was rescheduled or refinanced to. This value is only not null if rescheduled.
     */
    rescheduledAccountKey?: string | undefined
    scheduleSettings: ScheduleSettings
    /**
     * The encoded key of the settlement account.
     */
    settlementAccountKey?: string | undefined
    /**
     * The tax rate.
     */
    taxRate?: number | undefined
    /**
     * The date this loan account was terminated.
     */
    terminationDate?: string | undefined
    /**
     * The list of disbursement tranches available for the loan account.
     */
    tranches?: LoanTranche[] | undefined
}

export const LoanAccount = {
    validate: LoanAccountValidator as ValidateFunction<LoanAccount>,
    get schema() {
        return LoanAccount.validate.schema
    },
    get errors() {
        return LoanAccount.validate.errors ?? undefined
    },
    is: (o: unknown): o is LoanAccount => LoanAccount.validate(o) === true,
    parse: (o: unknown): { right: LoanAccount } | { left: DefinedError[] } => {
        if (LoanAccount.is(o)) {
            return { right: o }
        }
        return { left: (LoanAccount.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents information for an action to perform on a loan account.
 */
export interface LoanAccountAction {
    /**
     * The action type to be applied.
     */
    action:
        | 'REQUEST_APPROVAL'
        | 'SET_INCOMPLETE'
        | 'APPROVE'
        | 'UNDO_APPROVE'
        | 'REJECT'
        | 'WITHDRAW'
        | 'CLOSE'
        | 'UNDO_REJECT'
        | 'UNDO_WITHDRAW'
        | 'UNDO_CLOSE'
    /**
     * The notes related to the action performed.
     */
    notes?: string | undefined
}

export const LoanAccountAction = {
    validate: LoanAccountActionValidator as ValidateFunction<LoanAccountAction>,
    get schema() {
        return LoanAccountAction.validate.schema
    },
    get errors() {
        return LoanAccountAction.validate.errors ?? undefined
    },
    is: (o: unknown): o is LoanAccountAction => LoanAccountAction.validate(o) === true,
    parse: (o: unknown): { right: LoanAccountAction } | { left: DefinedError[] } => {
        if (LoanAccountAction.is(o)) {
            return { right: o }
        }
        return { left: (LoanAccountAction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Wrapper that holds a list of filtering criteria and a sorting criteria for Loan account directed query
 */
export interface LoanAccountFilterCriteria {
    field:
        | 'accountHolderKey'
        | 'productTypeKey'
        | 'loanRiskLevelKey'
        | 'encodedKey'
        | 'loanName'
        | 'id'
        | 'accountHolderId'
        | 'recipient'
        | 'creationDate'
        | 'approvedDate'
        | 'lastModifiedDate'
        | 'lastSetToArrearsDate'
        | 'lastLockedDate'
        | 'closedDate'
        | 'daysInArrears'
        | 'daysLate'
        | 'accountSubState'
        | 'accountState'
        | 'loanAmount'
        | 'numInstallments'
        | 'balances.principalDue'
        | 'balances.principalPaid'
        | 'balances.principalBalance'
        | 'balances.interestDue'
        | 'balances.interestPaid'
        | 'balance.interestBalance'
        | 'accruedInterest'
        | 'balances.feesDue'
        | 'balances.feesBalance'
        | 'balances.feesPaid'
        | 'penaltySettings.loanPenaltyCalculationMethod'
        | 'balances.penaltyDue'
        | 'balances.penaltyPaid'
        | 'balances.penaltyBalance'
        | 'accruedPenalty'
        | 'penaltySettings.penaltyRate'
        | 'arrearsTolerancePeriod'
        | 'interestSettings.interestRate'
        | 'interestSettings.interestSpread'
        | 'totalPaid'
        | 'totalBalance'
        | 'totalDue'
        | 'firstRepaymentDate'
        | 'lastPaymentDate'
        | 'lastPaymentAmount'
        | 'expectedMaturityDate'
        | 'rescheduledAccountKey'
        | 'refinancedAccountId'
        | 'originalAccountKey'
        | 'taxRate'
        | 'taxPaid'
        | 'taxDue'
        | 'settlementAccountKey'
        | 'interestCommission'
        | 'fundingSources.amount'
        | 'fundingSources.sharePercentage'
        | 'numberOfFunds'
        | 'fundsEnabled'
        | 'availableAmount'
        | 'wasRescheduled'
        | 'wasRefinanced'
        | 'prepaymentSettings.prepaymentRecalculationMethod'
        | 'prepaymentSettings.applyInterestOnPrepaymentMethod'
        | 'latePaymentsRecalculationMethod'
        | 'balances.redrawBalance'
        | 'expectedPrincipalRedraw'
        | 'tranches.parentAccountKey'
        | 'tranches.disbursementDetails.disbursementTransactionKey'
        | 'tranches.amount'
        | 'tranches.disbursementDetails.expectedDisbursementDate'
        | 'disbursementDetails.expectedDisbursementDate'
        | 'disbursementDetails.disbursementDate'
        | 'lastAccountAppraisalDate'
        | string
    /**
     * | **Operator**                | **Affected values**  | **Available for**                                                    |
     * |---------------               |----------------------|----------------------------------------------------------------------|
     * | EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |
     * | EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |
     * | MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |
     * | ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | STARTS_WITH                  | ONE_VALUE            | STRING                                                               |
     * | STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |
     * | IN                           | LIST                 | ENUM,KEY                                                             |
     * | TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |
     * | EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     * | NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     */
    operator:
        | 'EQUALS'
        | 'EQUALS_CASE_SENSITIVE'
        | 'DIFFERENT_THAN'
        | 'MORE_THAN'
        | 'LESS_THAN'
        | 'BETWEEN'
        | 'ON'
        | 'AFTER'
        | 'AFTER_INCLUSIVE'
        | 'BEFORE'
        | 'BEFORE_INCLUSIVE'
        | 'STARTS_WITH'
        | 'STARTS_WITH_CASE_SENSITIVE'
        | 'IN'
        | 'TODAY'
        | 'THIS_WEEK'
        | 'THIS_MONTH'
        | 'THIS_YEAR'
        | 'LAST_DAYS'
        | 'EMPTY'
        | 'NOT_EMPTY'
    /**
     * The second value to match the searching criteria, when the `BETWEEN` operator is used.
     */
    secondValue?: string | undefined
    /**
     * The value to match the searching criteria.
     */
    value?: string | undefined
    /**
     * List of values when the `IN` operator is used.
     */
    values?: string[] | undefined
}

/**
 * Represents the information for loan account pay off action.
 */
export interface LoanAccountPayOffInput {
    /**
     * The external ID for the repayment transaction.
     */
    externalId?: string | undefined
    /**
     * The notes for the repayment transaction logged for the pay off action.
     */
    notes?: string | undefined
    payOffAdjustableAmounts?: PayOffAdjustableAmounts | undefined
    transactionDetails?: TransactionDetails | undefined
}

export const LoanAccountPayOffInput = {
    validate: LoanAccountPayOffInputValidator as ValidateFunction<LoanAccountPayOffInput>,
    get schema() {
        return LoanAccountPayOffInput.validate.schema
    },
    get errors() {
        return LoanAccountPayOffInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is LoanAccountPayOffInput => LoanAccountPayOffInput.validate(o) === true,
    parse: (o: unknown): { right: LoanAccountPayOffInput } | { left: DefinedError[] } => {
        if (LoanAccountPayOffInput.is(o)) {
            return { right: o }
        }
        return { left: (LoanAccountPayOffInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Payload structure to preview the schedules of a loan account when processing PMT transactionally.
 */
export interface LoanAccountPreviewProcessPMTTransactionally {
    /**
     * The error code of the request.
     */
    error?: string | undefined
    /**
     * Additional information about the request.
     */
    info?: string | undefined
    result?: LoanAccountSchedulesPreviewProcessPMTTransactionally | undefined
    /**
     * The status of the request.
     */
    status?: string | undefined
}

export const LoanAccountPreviewProcessPMTTransactionally = {
    validate:
        LoanAccountPreviewProcessPMTTransactionallyValidator as ValidateFunction<LoanAccountPreviewProcessPMTTransactionally>,
    get schema() {
        return LoanAccountPreviewProcessPMTTransactionally.validate.schema
    },
    get errors() {
        return LoanAccountPreviewProcessPMTTransactionally.validate.errors ?? undefined
    },
    is: (o: unknown): o is LoanAccountPreviewProcessPMTTransactionally =>
        LoanAccountPreviewProcessPMTTransactionally.validate(o) === true,
    parse: (o: unknown): { right: LoanAccountPreviewProcessPMTTransactionally } | { left: DefinedError[] } => {
        if (LoanAccountPreviewProcessPMTTransactionally.is(o)) {
            return { right: o }
        }
        return { left: (LoanAccountPreviewProcessPMTTransactionally.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the redraw settings for a loan account.
 */
export interface LoanAccountRedrawSettings {
    /**
     * `TRUE` if withdrawing amounts that reduce the next due instalment repayment is restricted, `FALSE` otherwise.
     */
    restrictNextDueWithdrawal: boolean
}

/**
 * Represents a single repayment versioning details structure.
 */
export interface LoanAccountRepaymentScheduleVersioning {
    /**
     * The encoded key of the versioning.
     */
    encodedKey?: string | undefined
    /**
     * The repayment schedule versioning ID.
     */
    id?: number | undefined
    /**
     * The loan account event which triggered the versioning.
     */
    loanAccountChangedEventKey?: string | undefined
    /**
     * The loan transaction key which triggered the versioning.
     */
    loanTransactionKey?: string | undefined
    /**
     * The loan account repayment schedule versioning list.
     */
    versioningContent?: Installment[] | undefined
}

/**
 * Represents a single loan account schedule structure.
 */
export interface LoanAccountSchedule {
    currency?: Currency | undefined
    /**
     * The loan account schedule installments list.
     */
    installments?: Installment[] | undefined
}

export const LoanAccountSchedule = {
    validate: LoanAccountScheduleValidator as ValidateFunction<LoanAccountSchedule>,
    get schema() {
        return LoanAccountSchedule.validate.schema
    },
    get errors() {
        return LoanAccountSchedule.validate.errors ?? undefined
    },
    is: (o: unknown): o is LoanAccountSchedule => LoanAccountSchedule.validate(o) === true,
    parse: (o: unknown): { right: LoanAccountSchedule } | { left: DefinedError[] } => {
        if (LoanAccountSchedule.is(o)) {
            return { right: o }
        }
        return { left: (LoanAccountSchedule.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Payload structure to preview the loan account schedule differences when processing PMT transactionally.
 */
export interface LoanAccountSchedulesPreviewProcessPMTTransactionally {
    /**
     * Whether there differences on schedule or not.
     */
    differences?: boolean | undefined
    /**
     * The loan account existing schedule installments list.
     */
    existingSchedule?: Installment[] | undefined
    /**
     * The loan account new schedule installments list.
     */
    schedule?: Installment[] | undefined
}

/**
 * Wrapper that holds a list of filtering criteria and a sorting criteria for Loan account directed query
 */
export interface LoanAccountSearchCriteria {
    /**
     * The list of filtering criteria
     */
    filterCriteria?: LoanAccountFilterCriteria[] | undefined
    sortingCriteria?: LoanAccountSortingCriteria | undefined
}

export const LoanAccountSearchCriteria = {
    validate: LoanAccountSearchCriteriaValidator as ValidateFunction<LoanAccountSearchCriteria>,
    get schema() {
        return LoanAccountSearchCriteria.validate.schema
    },
    get errors() {
        return LoanAccountSearchCriteria.validate.errors ?? undefined
    },
    is: (o: unknown): o is LoanAccountSearchCriteria => LoanAccountSearchCriteria.validate(o) === true,
    parse: (o: unknown): { right: LoanAccountSearchCriteria } | { left: DefinedError[] } => {
        if (LoanAccountSearchCriteria.is(o)) {
            return { right: o }
        }
        return { left: (LoanAccountSearchCriteria.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the sorting criteria used for loan account searches.
 */
export interface LoanAccountSortingCriteria {
    /**
     * Contains the field that can be used as sorting selection. Can be native (one from the provided list) or otherwise can specify a custom field definition using the format [customFieldSetId].[customFieldId].
     */
    field:
        | 'encodedKey'
        | 'loanName'
        | 'id'
        | 'accountHolderId'
        | 'recipient'
        | 'creationDate'
        | 'approvedDate'
        | 'lastModifiedDate'
        | 'lastSetToArrearsDate'
        | 'lastLockedDate'
        | 'closedDate'
        | 'daysInArrears'
        | 'daysLate'
        | 'loanAmount'
        | 'tranches.amount'
        | 'numInstallments'
        | 'accruedInterest'
        | 'accruedPenalty'
        | 'penaltySettings.penaltyRate'
        | 'arrearsTolerancePeriod'
        | 'interestSettings.interestSpread'
        | 'totalPaid'
        | 'totalBalance'
        | 'totalDue'
        | 'firstRepaymentDate'
        | 'lastPaymentDate'
        | 'lastPaymentAmount'
        | 'expectedMaturity'
        | 'rescheduledAccountKey'
        | 'refinancedAccountId'
        | 'originalAccountKey'
        | 'taxRate'
        | 'taxPaid'
        | 'taxDue'
        | 'settlementAccountKey'
        | 'interestCommission'
        | 'numberOfFunds'
        | 'fundsEnabled'
        | 'availableAmount'
        | 'wasRescheduled'
        | 'wasRefinanced'
        | 'expectedPrincipalRedraw'
        | 'balances.principalDue'
        | 'balances.principalPaid'
        | 'balances.principalBalance'
        | 'balances.interestDue'
        | 'balances.interestPaid'
        | 'balance.interestBalance'
        | 'balances.redrawBalance'
        | 'balances.feesDue'
        | 'balances.feesBalance'
        | 'balances.feesPaid'
        | 'balances.penaltyDue'
        | 'balances.penaltyPaid'
        | 'balances.penaltyBalance'
        | 'fundingSources.amount'
        | 'fundingSources.sharePercentage'
    /**
     * The sorting order: `ASC` or `DESC`. The default order is `DESC`.
     */
    order?: 'ASC' | 'DESC' | undefined
}

/**
 * Represents details about an action performed on a loan account.
 */
export interface LoanActionDetails {
    /**
     * The notes for the action performed on a loan account.
     */
    notes?: string | undefined
}

export const LoanActionDetails = {
    validate: LoanActionDetailsValidator as ValidateFunction<LoanActionDetails>,
    get schema() {
        return LoanActionDetails.validate.schema
    },
    get errors() {
        return LoanActionDetails.validate.errors ?? undefined
    },
    is: (o: unknown): o is LoanActionDetails => LoanActionDetails.validate(o) === true,
    parse: (o: unknown): { right: LoanActionDetails } | { left: DefinedError[] } => {
        if (LoanActionDetails.is(o)) {
            return { right: o }
        }
        return { left: (LoanActionDetails.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The amounts affected after completing the loan transaction
 */
export interface LoanAffectedAmounts {
    /**
     * How much interest pre-paid was added/removed in account, within this transaction (including taxes).
     */
    deferredInterestAmount?: number | undefined
    /**
     * How much fees was added/removed in account, within this transaction.
     */
    feesAmount?: number | undefined
    /**
     * How much interest is given to the investors, within this transaction (only for p2p products)
     */
    fundersInterestAmount?: number | undefined
    /**
     * How much interest was added/removed in account, within this transaction (including taxes). If there is any deferred interest amount set in this transaction, that amount should be included in this field.
     */
    interestAmount?: number | undefined
    /**
     * How much interest from arrears was added/removed in account, within this transaction (including taxes).
     */
    interestFromArrearsAmount?: number | undefined
    /**
     * How much interest is given to the organization, within this transaction (only for p2p products)
     */
    organizationCommissionAmount?: number | undefined
    /**
     * How much Payment Holidays interest was added/removed in account, within this transaction (including taxes).
     */
    paymentHolidaysInterestAmount?: number | undefined
    /**
     * How much penalties was added/removed in account, within this transaction.
     */
    penaltyAmount?: number | undefined
    /**
     * How much principal was added/removed in account, within this transaction.
     */
    principalAmount?: number | undefined
}

/**
 * The amount settings, holds all amount properties.
 */
export interface LoanAmountSettings {
    loanAmount?: AmountDecimalConstraints | undefined
    trancheSettings?: TrancheSettings | undefined
}

/**
 * Represents a loan product.
 */
export interface LoanProduct {
    accountingSettings?: AccountingSettings | undefined
    accountLinkSettings?: AccountLinkSettings | undefined
    /**
     * `TRUE` if it is possible to adjust the interest for the first repayment when the first repayment period is different than the repayment frequency, `FALSE` otherwise.
     */
    adjustInterestForFirstInstallment?: boolean | undefined
    /**
     * `TRUE` if an additional payment may be allocated on the account, ignoring the default repayment allocation order, `FALSE` otherwise.
     */
    allowCustomRepaymentAllocation?: boolean | undefined
    arrearsSettings?: ProductArrearsSettings | undefined
    availabilitySettings?: ProductAvailabilitySettings | undefined
    /**
     * The category of the loan product.
     */
    category?:
        | 'PERSONAL_LENDING'
        | 'PURCHASE_FINANCING'
        | 'RETAIL_MORTGAGES'
        | 'SME_LENDING'
        | 'COMMERCIAL'
        | 'UNCATEGORIZED'
        | undefined
    /**
     * The date the loan product was created.
     */
    creationDate?: string | undefined
    creditArrangementSettings: CreditArrangementSettings
    currency?: Currency | undefined
    /**
     * The encoded key of the loan product, it is auto generated, and unique.
     */
    encodedKey?: string | undefined
    feesSettings?: FeesSettings | undefined
    fundingSettings?: FundingSettings | undefined
    gracePeriodSettings?: GracePeriodSettings | undefined
    /**
     * The ID of the loan product, can be generated and customized, and must be unique.
     */
    id: string
    interestSettings?: ProductInterestSettings | undefined
    internalControls?: InternalControls | undefined
    /**
     * The last date the loan product was updated.
     */
    lastModifiedDate?: string | undefined
    loanAmountSettings?: LoanAmountSettings | undefined
    /**
     * The name of the loan product.
     */
    name: string
    newAccountSettings?: NewAccountSettings | undefined
    /**
     * The notes or description of the loan product.
     */
    notes?: string | undefined
    offsetSettings?: OffsetSettings | undefined
    paymentSettings?: PaymentSettings | undefined
    penaltySettings?: ProductPenaltySettings | undefined
    redrawSettings?: ProductRedrawSettings | undefined
    scheduleSettings?: LoanProductScheduleSettings | undefined
    securitySettings?: SecuritySettings | undefined
    /**
     * The current state of the loan product.
     */
    state?: 'ACTIVE' | 'INACTIVE' | undefined
    taxSettings?: TaxSettings | undefined
    /**
     * The template documents of the loan product.
     */
    templates?: DocumentTemplate[] | undefined
    /**
     * The type of the loan product.
     */
    type:
        | 'FIXED_TERM_LOAN'
        | 'DYNAMIC_TERM_LOAN'
        | 'INTEREST_FREE_LOAN'
        | 'TRANCHED_LOAN'
        | 'REVOLVING_CREDIT'
        | 'INTEREST_ONLY_EQUAL_INSTALLMENTS'
}

export const LoanProduct = {
    validate: LoanProductValidator as ValidateFunction<LoanProduct>,
    get schema() {
        return LoanProduct.validate.schema
    },
    get errors() {
        return LoanProduct.validate.errors ?? undefined
    },
    is: (o: unknown): o is LoanProduct => LoanProduct.validate(o) === true,
    parse: (o: unknown): { right: LoanProduct } | { left: DefinedError[] } => {
        if (LoanProduct.is(o)) {
            return { right: o }
        }
        return { left: (LoanProduct.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Defines the settings and constraints for schedule for the loans that are created based on this product.
 */
export interface LoanProductScheduleSettings {
    amortizationPeriod?: ProductAmortizationPeriod | undefined
    billingCycles?: BillingCyclesProductSettings | undefined
    /**
     * Interval Repayment Methodology Settings.
     */
    defaultRepaymentPeriodCount?: number | undefined
    firstRepaymentDueDateOffset?: IntegerIntervalConstraints | undefined
    /**
     * Specifies the days of the month when the repayment due dates should be. Only available if the Repayment Methodology is ScheduleDueDatesMethodDTO#FIXED_DAYS_OF_MONTH.
     */
    fixedDaysOfMonth?: number[] | undefined
    /**
     * Represents the moment the interest will start getting accrued.
     */
    interestAccrualSince?: 'DISBURSEMENT' | 'DUE_DATE' | undefined
    /**
     * For optimized payments only, indicates whether the installments should remain equal when the first period is long
     */
    keepInstallmentsEqualIfLongFirstPeriod?: boolean | undefined
    numInstallments?: IntegerIntervalConstraints | undefined
    previewSchedule?: PreviewScheduleSettings | undefined
    /**
     * The repayment method value
     */
    repaymentMethod?: 'AMOUNT' | 'INSTALLMENTS' | undefined
    /**
     * The frequency of the loan repayment.
     */
    repaymentPeriodUnit?: 'DAYS' | 'WEEKS' | 'MONTHS' | 'YEARS' | undefined
    /**
     * The repayment rescheduling method used in calculations.
     */
    repaymentReschedulingMethod: 'NONE' | 'NEXT_WORKING_DAY' | 'PREVIOUS_WORKING_DAY' | 'EXTEND_SCHEDULE'
    /**
     * Shows the properties from the repayment schedule can be edited.
     */
    repaymentScheduleEditOptions?: RepaymentScheduleEditOptions[] | undefined
    /**
     * The repayment schedule method. Represents the method that determines whether the schedule will be fixed all over the loan account's life cycle or will be dynamically recomputed when required.
     */
    repaymentScheduleMethod: 'NONE' | 'FIXED' | 'DYNAMIC'
    roundingSettings?: RoundingSettings | undefined
    /**
     * The methodology used by this product to compute the due dates of the repayments.
     */
    scheduleDueDatesMethod: 'INTERVAL' | 'FIXED_DAYS_OF_MONTH'
    scheduleEditOptionDetails?: RepaymentScheduleEditOptionDetails | undefined
    /**
     * Determines how to handle the short months, if they select a fixed day of month > 28. Will be null if no such date is selected and also for the Interval methodology. Only available if the Schedule Due Dates Method is ScheduleDueDatesMethodDTO#FIXED_DAYS_OF_MONTHs.
     */
    shortMonthHandlingMethod?: 'LAST_DAY_IN_MONTH' | 'FIRST_DAY_OF_NEXT_MONTH' | undefined
}

/**
 * The loan transaction terms
 */
export interface LoanTerms {
    interestSettings?: TransactionInterestSettings | undefined
    /**
     * The periodic payment value logged when changing it for a Balloon Payments account
     */
    periodicPayment?: number | undefined
    /**
     * The principal payment flat amount logged when changing it for a Revolving Credit account
     */
    principalPaymentAmount?: number | undefined
    /**
     * The principal payment percentage value logged when changing it for a Revolving Credit account
     */
    principalPaymentPercentage?: number | undefined
}

/**
 * In some cases organizations may approve loans but not disburse the full amount initially. They would like to spread the disbursement (and risk) over time. Likewise for the client, they may not need the full loan amount up front. They may want to have a loan to buy some equipment for their business but will make one purchase today and another purchase in a few months.  In these cases, they don't need the full amount and wouldn't want to pay interest on cash they don't need yet. A solution for this matter is the usage of disbursement in tranches. This class holds the information required for one of this tranche.
 */
export interface LoanTranche {
    /**
     * The amount this tranche has available for disburse
     */
    amount: number
    disbursementDetails?: TrancheDisbursementDetails | undefined
    /**
     * The encoded key of the transaction details , auto generated, unique.
     */
    encodedKey?: string | undefined
    /**
     * Fees that are associated with this tranche
     */
    fees?: CustomPredefinedFee[] | undefined
    /**
     * Index indicating the tranche number
     */
    trancheNumber?: number | undefined
}

/**
 * Represents the action performed on a loan account after which the account's amount changes its value.
 */
export interface LoanTransaction {
    accountBalances?: TransactionBalances | undefined
    /**
     * The key of the loan transaction where the adjustment for the transaction was made (if any adjustment was involved).
     */
    adjustmentTransactionKey?: string | undefined
    affectedAmounts?: LoanAffectedAmounts | undefined
    /**
     * The amount that was added or removed on the loan account.
     */
    amount?: number | undefined
    /**
     * The date when the corresponding journal entry is booked.
     */
    bookingDate?: string | undefined
    /**
     * The branch where the transaction was performed.
     */
    branchKey?: string | undefined
    cardTransaction?: CardTransaction | undefined
    /**
     * The center where the transaction was performed.
     */
    centreKey?: string | undefined
    /**
     * The date when this loan transaction was created.
     */
    creationDate?: string | undefined
    currency?: Currency | undefined
    /**
     * The list of custom amounts which the user has paid as part of this transaction.
     */
    customPaymentAmounts?: CustomPaymentAmount[] | undefined
    /**
     * The encoded key of the loan transaction, which is auto generated, and must be unique.
     */
    encodedKey?: string | undefined
    /**
     * The external ID of the loan transaction, it is customizable, and must be unique.
     */
    externalId?: string | undefined
    /**
     * The amounts that have been applied or paid as part of this transaction and involved predefined fees.
     */
    fees?: Fee[] | undefined
    /**
     * The ID of the loan transaction, can be generated and customized, and must be unique.
     */
    id?: string | undefined
    /**
     * The specific installment encoded key associated to the loan transaction.
     */
    installmentEncodedKey?: string | undefined
    /**
     * The migration event encoded key associated with the loan account. If the account was imported, track which 'migration event' it came from.
     */
    migrationEventKey?: string | undefined
    /**
     * The notes or description for the loan transaction.
     */
    notes?: string | undefined
    /**
     * The amount that was posted in a foreign currency. This amount was converted using the exchange rate available at entry date and set into the amount field.
     */
    originalAmount?: number | undefined
    /**
     * The currency in which this transaction was posted. The amounts are stored in the base currency, but the user may enter it in a foreign currency.
     */
    originalCurrencyCode?: string | undefined
    /**
     * The encoded key of the transaction that was adjusted as part of this one. Available only for adjustment transactions.
     */
    originalTransactionKey?: string | undefined
    /**
     * The key of the parent loan account.
     */
    parentAccountKey?: string | undefined
    /**
     * The key of the parent loan transaction.
     */
    parentLoanTransactionKey?: string | undefined
    /**
     * The prepayment recalculation method of the loan transaction.
     */
    prepaymentRecalculationMethod?:
        | 'NO_RECALCULATION'
        | 'RESCHEDULE_REMAINING_REPAYMENTS'
        | 'RECALCULATE_SCHEDULE_KEEP_SAME_NUMBER_OF_TERMS'
        | 'RECALCULATE_SCHEDULE_KEEP_SAME_PRINCIPAL_AMOUNT'
        | 'RECALCULATE_SCHEDULE_KEEP_SAME_TOTAL_REPAYMENT_AMOUNT'
        | 'REDUCE_AMOUNT_PER_INSTALLMENT'
        | 'REDUCE_NUMBER_OF_INSTALLMENTS'
        | 'REDUCE_NUMBER_OF_INSTALLMENTS_NEW'
        | undefined
    taxes?: Taxes | undefined
    terms?: LoanTerms | undefined
    /**
     * The till key associated with the transaction.
     */
    tillKey?: string | undefined
    transactionDetails?: TransactionDetails | undefined
    transferDetails?: TransferDetails | undefined
    /**
     * The type of loan transaction.
     */
    type?:
        | 'IMPORT'
        | 'DISBURSEMENT'
        | 'DISBURSEMENT_ADJUSTMENT'
        | 'WRITE_OFF'
        | 'WRITE_OFF_ADJUSTMENT'
        | 'REPAYMENT'
        | 'PAYMENT_MADE'
        | 'WITHDRAWAL_REDRAW'
        | 'WITHDRAWAL_REDRAW_ADJUSTMENT'
        | 'FEE_APPLIED'
        | 'FEE_CHARGED'
        | 'FEE_CAPITALISED'
        | 'SCHEDULE_FIX_APPLIED'
        | 'FEES_DUE_REDUCED'
        | 'FEE_REFUND'
        | 'FEE_REFUND_ADJUSTMENT'
        | 'FEE_ADJUSTMENT'
        | 'PENALTY_APPLIED'
        | 'PENALTY_ADJUSTMENT'
        | 'PENALTIES_DUE_REDUCED'
        | 'REPAYMENT_ADJUSTMENT'
        | 'FEE_CAPITALISED_ADJUSTMENT'
        | 'PAYMENT_MADE_ADJUSTMENT'
        | 'INTEREST_RATE_CHANGED'
        | 'TAX_RATE_CHANGED'
        | 'PENALTY_RATE_CHANGED'
        | 'INTEREST_APPLIED'
        | 'INTEREST_APPLIED_ADJUSTMENT'
        | 'INTEREST_DUE_REDUCED'
        | 'PENALTY_REDUCTION_ADJUSTMENT'
        | 'FEE_REDUCTION_ADJUSTMENT'
        | 'INTEREST_REDUCTION_ADJUSTMENT'
        | 'DEFERRED_INTEREST_APPLIED'
        | 'DEFERRED_INTEREST_APPLIED_ADJUSTMENT'
        | 'DEFERRED_INTEREST_PAID'
        | 'DEFERRED_INTEREST_PAID_ADJUSTMENT'
        | 'INTEREST_LOCKED'
        | 'FEE_LOCKED'
        | 'PENALTY_LOCKED'
        | 'INTEREST_UNLOCKED'
        | 'FEE_UNLOCKED'
        | 'PENALTY_UNLOCKED'
        | 'REDRAW_TRANSFER'
        | 'REDRAW_REPAYMENT'
        | 'REDRAW_TRANSFER_ADJUSTMENT'
        | 'REDRAW_REPAYMENT_ADJUSTMENT'
        | 'TRANSFER'
        | 'TRANSFER_ADJUSTMENT'
        | 'BRANCH_CHANGED'
        | 'TERMS_CHANGED'
        | 'CARD_TRANSACTION_REVERSAL'
        | 'CARD_TRANSACTION_REVERSAL_ADJUSTMENT'
        | 'DUE_DATE_CHANGED'
        | 'DUE_DATE_CHANGED_ADJUSTMENT'
        | 'ACCOUNT_TERMINATED'
        | 'ACCOUNT_TERMINATED_ADJUSTMENT'
        | 'REFUND'
        | 'REFUND_ADJUSTMENT'
        | undefined
    /**
     * The user that performed the transaction.
     */
    userKey?: string | undefined
    /**
     * The date of the entry in the organization time format and timezone.
     */
    valueDate?: string | undefined
}

export const LoanTransaction = {
    validate: LoanTransactionValidator as ValidateFunction<LoanTransaction>,
    get schema() {
        return LoanTransaction.validate.schema
    },
    get errors() {
        return LoanTransaction.validate.errors ?? undefined
    },
    is: (o: unknown): o is LoanTransaction => LoanTransaction.validate(o) === true,
    parse: (o: unknown): { right: LoanTransaction } | { left: DefinedError[] } => {
        if (LoanTransaction.is(o)) {
            return { right: o }
        }
        return { left: (LoanTransaction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Contains the details of the transaction adjustment
 */
export interface LoanTransactionAdjustmentDetails {
    /**
     * Date when the adjustment transaction is logged into accounting. Can be null. Available only for REPAYMENT, PAYMENT_MADE and FEE
     */
    bookingDate?: string | undefined
    /**
     * Details of installments with their corresponding amounts to be added to the reduced fee/penalty
     */
    installments?: AdjustTransactionInstallmentDetailsDTO[] | undefined
    /**
     * Notes detailing why the transaction is adjusted
     */
    notes: string
}

export const LoanTransactionAdjustmentDetails = {
    validate: LoanTransactionAdjustmentDetailsValidator as ValidateFunction<LoanTransactionAdjustmentDetails>,
    get schema() {
        return LoanTransactionAdjustmentDetails.validate.schema
    },
    get errors() {
        return LoanTransactionAdjustmentDetails.validate.errors ?? undefined
    },
    is: (o: unknown): o is LoanTransactionAdjustmentDetails => LoanTransactionAdjustmentDetails.validate(o) === true,
    parse: (o: unknown): { right: LoanTransactionAdjustmentDetails } | { left: DefinedError[] } => {
        if (LoanTransactionAdjustmentDetails.is(o)) {
            return { right: o }
        }
        return { left: (LoanTransactionAdjustmentDetails.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the loan transaction details.
 */
export interface LoanTransactionDetails {
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * Whether the transaction was transferred between loans or deposit accounts
     */
    internalTransfer?: boolean | undefined
    /**
     * In case of a transaction to a deposit account this represent the deposit account key to which the transaction was made.
     */
    targetDepositAccountKey?: string | undefined
    /**
     * The ID of the transaction channel associated with the transaction details.
     */
    transactionChannelId?: string | undefined
    /**
     * The encoded key of the transaction channel associated with the transaction details.
     */
    transactionChannelKey?: string | undefined
}

/**
 * Contains the details about transaction including fields like transaction channel key and channel ID
 */
export interface LoanTransactionDetailsInput {
    /**
     * The id of the transaction channel associated with the transaction details input.
     */
    transactionChannelId?: string | undefined
    /**
     * The encoded key of the transaction channel associated with the transaction details input.
     */
    transactionChannelKey?: string | undefined
}

/**
 * The unit that composes the list used for Loan transaction client directed queries searching
 */
export interface LoanTransactionFilterCriteria {
    field:
        | 'encodedKey'
        | 'id'
        | 'externalId'
        | 'creationDate'
        | 'valueDate'
        | 'parentAccountKey'
        | 'parentAccountHolderKey'
        | 'productTypeKey'
        | 'productID'
        | 'type'
        | 'amount'
        | 'originalAmount'
        | 'originalCurrencyCode'
        | 'affectedAmounts.principalAmount'
        | 'affectedAmounts.interestAmount'
        | 'affectedAmounts.fundersInterestAmount'
        | 'affectedAmounts.organizationCommissionAmount'
        | 'affectedAmounts.deferredInterestAmount'
        | 'affectedAmounts.feesAmount'
        | 'affectedAmounts.penaltyAmount'
        | 'taxes.taxRate'
        | 'accountBalances.totalBalance'
        | 'accountBalances.advancePosition'
        | 'accountBalances.arrearsPosition'
        | 'accountBalances.expectedPrincipalRedraw'
        | 'accountBalances.redrawBalance'
        | 'accountBalances.principalBalance'
        | 'userKey'
        | 'branchKey'
        | 'branchID'
        | 'centreKey'
        | 'centreID'
        | 'tillKey'
        | 'tillID'
        | 'adjustmentTransactionKey'
        | 'originalTransactionKey'
        | 'terms.interestSettings.interestRate'
        | 'transactionDetails.transactionChannelKey'
        | 'transactionDetails.transactionChannelId'
        | 'wasAdjusted'
        | 'typeIsAdjustment'
        | 'fees.predefinedFeeKey'
        | 'fees.trigger'
        | 'fees.name'
        | 'parentAccountID'
        | 'adjustmentTransactionID'
        | 'originalTransactionID'
        | string
    /**
     * | **Operator**                | **Affected values**  | **Available for**                                                    |
     * |---------------               |----------------------|----------------------------------------------------------------------|
     * | EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |
     * | EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |
     * | MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |
     * | BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |
     * | ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |
     * | STARTS_WITH                  | ONE_VALUE            | STRING                                                               |
     * | STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |
     * | IN                           | LIST                 | ENUM,KEY                                                             |
     * | TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |
     * | LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |
     * | EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     * | NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |
     */
    operator:
        | 'EQUALS'
        | 'EQUALS_CASE_SENSITIVE'
        | 'DIFFERENT_THAN'
        | 'MORE_THAN'
        | 'LESS_THAN'
        | 'BETWEEN'
        | 'ON'
        | 'AFTER'
        | 'AFTER_INCLUSIVE'
        | 'BEFORE'
        | 'BEFORE_INCLUSIVE'
        | 'STARTS_WITH'
        | 'STARTS_WITH_CASE_SENSITIVE'
        | 'IN'
        | 'TODAY'
        | 'THIS_WEEK'
        | 'THIS_MONTH'
        | 'THIS_YEAR'
        | 'LAST_DAYS'
        | 'EMPTY'
        | 'NOT_EMPTY'
    /**
     * The second value to match the searching criteria, when the `BETWEEN` operator is used.
     */
    secondValue?: string | undefined
    /**
     * The value to match the searching criteria.
     */
    value?: string | undefined
    /**
     * List of values when the `IN` operator is used.
     */
    values?: string[] | undefined
}

/**
 * Represents the filtering and sorting criteria when searching loan transactions.
 */
export interface LoanTransactionSearchCriteria {
    /**
     * The list of filtering criteria.
     */
    filterCriteria?: LoanTransactionFilterCriteria[] | undefined
    sortingCriteria?: LoanTransactionSortingCriteria | undefined
}

export const LoanTransactionSearchCriteria = {
    validate: LoanTransactionSearchCriteriaValidator as ValidateFunction<LoanTransactionSearchCriteria>,
    get schema() {
        return LoanTransactionSearchCriteria.validate.schema
    },
    get errors() {
        return LoanTransactionSearchCriteria.validate.errors ?? undefined
    },
    is: (o: unknown): o is LoanTransactionSearchCriteria => LoanTransactionSearchCriteria.validate(o) === true,
    parse: (o: unknown): { right: LoanTransactionSearchCriteria } | { left: DefinedError[] } => {
        if (LoanTransactionSearchCriteria.is(o)) {
            return { right: o }
        }
        return { left: (LoanTransactionSearchCriteria.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The sorting criteria used for when searching loan transactions.
 */
export interface LoanTransactionSortingCriteria {
    /**
     * Contains the field that can be used as sorting selection. Can be native (one from the provided list) or otherwise can specify a custom field using the format [customFieldSetId].[customFieldId].
     */
    field:
        | 'id'
        | 'externalId'
        | 'creationDate'
        | 'valueDate'
        | 'parentAccountId'
        | 'productId'
        | 'amount'
        | 'originalAmount'
        | 'originalCurrencyCode'
        | 'branchId'
        | 'centreId'
        | 'tillId'
        | 'terms.interestSettings.interestRate'
        | 'transactionDetails.transactionChannelId'
        | 'fees.name'
        | 'accountBalances.totalBalance'
        | 'accountBalances.principalBalance'
        | 'accountBalances.redrawBalance'
        | 'accountBalances.expectedPrincipalRedraw'
        | 'accountBalances.advancePosition'
        | 'accountBalances.arrearsPosition'
        | 'affectedAmounts.principalAmount'
        | 'affectedAmounts.interestAmount'
        | 'affectedAmounts.interestFromArrearsAmount'
        | 'affectedAmounts.deferredInterestAmount'
        | 'affectedAmounts.feesAmount'
        | 'affectedAmounts.penaltyAmount'
        | 'affectedAmounts.organizationCommissionAmount'
        | 'affectedAmounts.fundersInterestAmount'
        | 'taxes.taxRate'
    /**
     * The sorting order: `ASC` or `DESC`. The default order is `DESC`.
     */
    order?: 'ASC' | 'DESC' | undefined
}

/**
 * Represents the information for locking an account.
 */
export interface LockLoanAccountInput {
    /**
     * The locked account total due type.
     */
    lockedAccountTotalDueType?: 'BALANCE_AMOUNT' | 'DUE_AMOUNT_ON_LATE_INSTALLMENTS' | undefined
    /**
     * A list with operations which are locked when the account is in substate AccountState.LOCKED. Allowed options are `APPLY_INTEREST`, `APPLY_PENALTIES`, and `APPLY_FEES`.
     */
    lockedOperations?: ('APPLY_INTEREST' | 'APPLY_FEES' | 'APPLY_PENALTIES')[] | undefined
    /**
     * The notes about the account locking operation.
     */
    notes?: string | undefined
}

export const LockLoanAccountInput = {
    validate: LockLoanAccountInputValidator as ValidateFunction<LockLoanAccountInput>,
    get schema() {
        return LockLoanAccountInput.validate.schema
    },
    get errors() {
        return LockLoanAccountInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is LockLoanAccountInput => LockLoanAccountInput.validate(o) === true,
    parse: (o: unknown): { right: LockLoanAccountInput } | { left: DefinedError[] } => {
        if (LockLoanAccountInput.is(o)) {
            return { right: o }
        }
        return { left: (LockLoanAccountInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents a wrapper over a list of loan transactions, to be used when locking and unlocking an account.
 */
export interface LockLoanTransactionsWrapper {
    /**
     * The list of loan transactions
     */
    loanTransactions?: LoanTransaction[] | undefined
}

export const LockLoanTransactionsWrapper = {
    validate: LockLoanTransactionsWrapperValidator as ValidateFunction<LockLoanTransactionsWrapper>,
    get schema() {
        return LockLoanTransactionsWrapper.validate.schema
    },
    get errors() {
        return LockLoanTransactionsWrapper.validate.errors ?? undefined
    },
    is: (o: unknown): o is LockLoanTransactionsWrapper => LockLoanTransactionsWrapper.validate(o) === true,
    parse: (o: unknown): { right: LockLoanTransactionsWrapper } | { left: DefinedError[] } => {
        if (LockLoanTransactionsWrapper.is(o)) {
            return { right: o }
        }
        return { left: (LockLoanTransactionsWrapper.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Settings applied when transitioning accounts to Locked state
 */
export interface LockSettings {
    /**
     * Specifies constraint types for capping charges.
     */
    cappingConstraintType?: 'SOFT_CAP' | 'HARD_CAP' | undefined
    /**
     * Specifies how principal will be used when calculating capping charges.
     */
    cappingMethod?: 'OUTSTANDING_PRINCIPAL_PERCENTAGE' | 'ORIGINAL_PRINCIPAL_PERCENTAGE' | undefined
    /**
     * Specifies the percentage of principal that cannot be exceeded by the sum of interest, fees and penalty balances.
     */
    cappingPercentage?: number | undefined
    /**
     * Specifies the number of days for in which the account will be locked if it stays in arrears.
     */
    lockPeriodDays?: number | undefined
}

/**
 * Wrapper for month and day for instances where the year isn't needed
 */
export interface MonthAndDay {
    /**
     * The day in the month
     */
    day?: number | undefined
    /**
     * The month of the year
     */
    month?: number | undefined
}

/**
 * Represents the request payload for creating multiple transactions atomically in groups.
 */
export interface MultipleAtomicGroupsInput {
    /**
     * Atomic Groups list
     */
    atomicGroups?: AtomicGroup[] | undefined
}

export const MultipleAtomicGroupsInput = {
    validate: MultipleAtomicGroupsInputValidator as ValidateFunction<MultipleAtomicGroupsInput>,
    get schema() {
        return MultipleAtomicGroupsInput.validate.schema
    },
    get errors() {
        return MultipleAtomicGroupsInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is MultipleAtomicGroupsInput => MultipleAtomicGroupsInput.validate(o) === true,
    parse: (o: unknown): { right: MultipleAtomicGroupsInput } | { left: DefinedError[] } => {
        if (MultipleAtomicGroupsInput.is(o)) {
            return { right: o }
        }
        return { left: (MultipleAtomicGroupsInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the response for accepting multiple transactions atomically in groups.
 */
export interface MultipleAtomicGroupsResponse {
    /**
     * Ordered unique ids for processing accepted atomic groups
     */
    atomicGroups?: string[] | undefined
    /**
     * Unique id for the accepted async request
     */
    requestId?: string | undefined
}

export const MultipleAtomicGroupsResponse = {
    validate: MultipleAtomicGroupsResponseValidator as ValidateFunction<MultipleAtomicGroupsResponse>,
    get schema() {
        return MultipleAtomicGroupsResponse.validate.schema
    },
    get errors() {
        return MultipleAtomicGroupsResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is MultipleAtomicGroupsResponse => MultipleAtomicGroupsResponse.validate(o) === true,
    parse: (o: unknown): { right: MultipleAtomicGroupsResponse } | { left: DefinedError[] } => {
        if (MultipleAtomicGroupsResponse.is(o)) {
            return { right: o }
        }
        return { left: (MultipleAtomicGroupsResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The new account settings, defines the settings and constraints used by new loan account created based on this product.
 */
export interface NewAccountSettings {
    /**
     * The initial state of the account when is created.
     */
    accountInitialState: 'PARTIAL_APPLICATION' | 'PENDING_APPROVAL' | 'APPROVED' | 'ACTIVE' | 'ACTIVE_IN_ARREARS' | 'CLOSED'
    /**
     * The type of generator used for IDs creation.
     */
    idGeneratorType: 'INCREMENTAL_NUMBER' | 'RANDOM_PATTERN'
    /**
     * The pattern that will be used for ID validation (as referred to as an input mask).
     */
    idPattern: string
}

type NonWorkingDays3 = 'MONDAY' | 'TUESDAY' | 'WEDNESDAY' | 'THURSDAY' | 'FRIDAY' | 'SATURDAY' | 'SUNDAY'

type NonWorkingDays2 = 'MONDAY' | 'TUESDAY' | 'WEDNESDAY' | 'THURSDAY' | 'FRIDAY' | 'SATURDAY' | 'SUNDAY'

/**
 * Represents the non-working days of the organization.
 */
export interface NonWorkingDays {
    /**
     * The non-working days of the organization.
     */
    nonWorkingDays: NonWorkingDays3[]
}

export const NonWorkingDays = {
    validate: NonWorkingDaysValidator as ValidateFunction<NonWorkingDays>,
    get schema() {
        return NonWorkingDays.validate.schema
    },
    get errors() {
        return NonWorkingDays.validate.errors ?? undefined
    },
    is: (o: unknown): o is NonWorkingDays => NonWorkingDays.validate(o) === true,
    parse: (o: unknown): { right: NonWorkingDays } | { left: DefinedError[] } => {
        if (NonWorkingDays.is(o)) {
            return { right: o }
        }
        return { left: (NonWorkingDays.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The offset settings, holds information about offset.
 */
export interface OffsetSettings {
    /**
     * Indicates whether the product supports offset
     */
    allowOffset?: boolean | undefined
}

/**
 * Response representation of the organization setup details
 */
export interface OrganizationSetup {
    address?: Address | undefined
    /**
     * The creation date of the organization
     */
    creationDate?: string | undefined
    /**
     * The currency of the organization, must be the same as the existing one
     */
    currency?: string | undefined
    /**
     * The format used to represent the date
     */
    dateFormat: string
    /**
     * The format used to represent the time and date
     */
    dateTimeFormat: string
    /**
     * Symbol used to mark the border between the integral and the fractional parts of a decimal numeral
     */
    decimalSeparator: 'COMMA' | 'POINT'
    /**
     * The email address of the organization
     */
    emailAddress?: string | undefined
    /**
     * The name of the organization
     */
    institutionName: string
    /**
     * The last modified date of the organization
     */
    lastModifiedDate?: string | undefined
    /**
     * The phone number of the organization
     */
    phoneNumber?: string | undefined
    /**
     * The timezone id, must be the same as the existing one
     */
    timeZoneID?: string | undefined
}

export const OrganizationSetup = {
    validate: OrganizationSetupValidator as ValidateFunction<OrganizationSetup>,
    get schema() {
        return OrganizationSetup.validate.schema
    },
    get errors() {
        return OrganizationSetup.validate.errors ?? undefined
    },
    is: (o: unknown): o is OrganizationSetup => OrganizationSetup.validate(o) === true,
    parse: (o: unknown): { right: OrganizationSetup } | { left: DefinedError[] } => {
        if (OrganizationSetup.is(o)) {
            return { right: o }
        }
        return { left: (OrganizationSetup.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents other way of identification for the account.
 */
export interface OtherAccountIdentification {
    /**
     * The identification of the payer/payee
     */
    identification?: string | undefined
    /**
     * The identification scheme
     */
    scheme?: string | undefined
}

/**
 * Overdraft settings for the product
 */
export interface OverdraftInterestSettings {
    /**
     * How many days in a year should be used for interest calculations
     */
    daysInYear?: 'ACTUAL_365_FIXED' | 'ACTUAL_360' | 'ACTUAL_ACTUAL_ISDA' | 'E30_360' | 'E30_42_365' | 'BUS_252' | undefined
    /**
     * The balance which is used for the overdraft interest calculation. Default value is MINIMUM. If set to null on a PUT call and the product allows overdrafts, the null value is ignored and not changed.
     */
    interestCalculationBalance?:
        | 'MINIMUM'
        | 'AVERAGE'
        | 'END_OF_DAY'
        | 'MINIMUM_TO_END_OF_DAY'
        | 'FRENCH_INTEREST_ACCRUAL'
        | undefined
    interestRateSettings?: DepositProductOverdraftInterestRateSettings | undefined
}

/**
 * The details of the party for a transaction
 */
export interface Party {
    /**
     * The name of the party
     */
    name?: string | undefined
}

export type Patch10Request = PatchOperation[]

export const Patch10Request = {
    validate: Patch10RequestValidator as ValidateFunction<Patch10Request>,
    get schema() {
        return Patch10Request.validate.schema
    },
    get errors() {
        return Patch10Request.validate.errors ?? undefined
    },
    is: (o: unknown): o is Patch10Request => Patch10Request.validate(o) === true,
    parse: (o: unknown): { right: Patch10Request } | { left: DefinedError[] } => {
        if (Patch10Request.is(o)) {
            return { right: o }
        }
        return { left: (Patch10Request.errors ?? []) as DefinedError[] }
    },
} as const

export type Patch11Request = PatchOperation[]

export const Patch11Request = {
    validate: Patch11RequestValidator as ValidateFunction<Patch11Request>,
    get schema() {
        return Patch11Request.validate.schema
    },
    get errors() {
        return Patch11Request.validate.errors ?? undefined
    },
    is: (o: unknown): o is Patch11Request => Patch11Request.validate(o) === true,
    parse: (o: unknown): { right: Patch11Request } | { left: DefinedError[] } => {
        if (Patch11Request.is(o)) {
            return { right: o }
        }
        return { left: (Patch11Request.errors ?? []) as DefinedError[] }
    },
} as const

export type Patch1Request = PatchOperation[]

export const Patch1Request = {
    validate: Patch1RequestValidator as ValidateFunction<Patch1Request>,
    get schema() {
        return Patch1Request.validate.schema
    },
    get errors() {
        return Patch1Request.validate.errors ?? undefined
    },
    is: (o: unknown): o is Patch1Request => Patch1Request.validate(o) === true,
    parse: (o: unknown): { right: Patch1Request } | { left: DefinedError[] } => {
        if (Patch1Request.is(o)) {
            return { right: o }
        }
        return { left: (Patch1Request.errors ?? []) as DefinedError[] }
    },
} as const

export type Patch2Request = PatchOperation[]

export const Patch2Request = {
    validate: Patch2RequestValidator as ValidateFunction<Patch2Request>,
    get schema() {
        return Patch2Request.validate.schema
    },
    get errors() {
        return Patch2Request.validate.errors ?? undefined
    },
    is: (o: unknown): o is Patch2Request => Patch2Request.validate(o) === true,
    parse: (o: unknown): { right: Patch2Request } | { left: DefinedError[] } => {
        if (Patch2Request.is(o)) {
            return { right: o }
        }
        return { left: (Patch2Request.errors ?? []) as DefinedError[] }
    },
} as const

export type Patch3Request = PatchOperation[]

export const Patch3Request = {
    validate: Patch3RequestValidator as ValidateFunction<Patch3Request>,
    get schema() {
        return Patch3Request.validate.schema
    },
    get errors() {
        return Patch3Request.validate.errors ?? undefined
    },
    is: (o: unknown): o is Patch3Request => Patch3Request.validate(o) === true,
    parse: (o: unknown): { right: Patch3Request } | { left: DefinedError[] } => {
        if (Patch3Request.is(o)) {
            return { right: o }
        }
        return { left: (Patch3Request.errors ?? []) as DefinedError[] }
    },
} as const

export type Patch4Request = PatchOperation[]

export const Patch4Request = {
    validate: Patch4RequestValidator as ValidateFunction<Patch4Request>,
    get schema() {
        return Patch4Request.validate.schema
    },
    get errors() {
        return Patch4Request.validate.errors ?? undefined
    },
    is: (o: unknown): o is Patch4Request => Patch4Request.validate(o) === true,
    parse: (o: unknown): { right: Patch4Request } | { left: DefinedError[] } => {
        if (Patch4Request.is(o)) {
            return { right: o }
        }
        return { left: (Patch4Request.errors ?? []) as DefinedError[] }
    },
} as const

export type Patch5Request = PatchOperation[]

export const Patch5Request = {
    validate: Patch5RequestValidator as ValidateFunction<Patch5Request>,
    get schema() {
        return Patch5Request.validate.schema
    },
    get errors() {
        return Patch5Request.validate.errors ?? undefined
    },
    is: (o: unknown): o is Patch5Request => Patch5Request.validate(o) === true,
    parse: (o: unknown): { right: Patch5Request } | { left: DefinedError[] } => {
        if (Patch5Request.is(o)) {
            return { right: o }
        }
        return { left: (Patch5Request.errors ?? []) as DefinedError[] }
    },
} as const

export type Patch6Request = PatchOperation[]

export const Patch6Request = {
    validate: Patch6RequestValidator as ValidateFunction<Patch6Request>,
    get schema() {
        return Patch6Request.validate.schema
    },
    get errors() {
        return Patch6Request.validate.errors ?? undefined
    },
    is: (o: unknown): o is Patch6Request => Patch6Request.validate(o) === true,
    parse: (o: unknown): { right: Patch6Request } | { left: DefinedError[] } => {
        if (Patch6Request.is(o)) {
            return { right: o }
        }
        return { left: (Patch6Request.errors ?? []) as DefinedError[] }
    },
} as const

export type Patch7Request = PatchOperation[]

export const Patch7Request = {
    validate: Patch7RequestValidator as ValidateFunction<Patch7Request>,
    get schema() {
        return Patch7Request.validate.schema
    },
    get errors() {
        return Patch7Request.validate.errors ?? undefined
    },
    is: (o: unknown): o is Patch7Request => Patch7Request.validate(o) === true,
    parse: (o: unknown): { right: Patch7Request } | { left: DefinedError[] } => {
        if (Patch7Request.is(o)) {
            return { right: o }
        }
        return { left: (Patch7Request.errors ?? []) as DefinedError[] }
    },
} as const

export type Patch8Request = PatchOperation[]

export const Patch8Request = {
    validate: Patch8RequestValidator as ValidateFunction<Patch8Request>,
    get schema() {
        return Patch8Request.validate.schema
    },
    get errors() {
        return Patch8Request.validate.errors ?? undefined
    },
    is: (o: unknown): o is Patch8Request => Patch8Request.validate(o) === true,
    parse: (o: unknown): { right: Patch8Request } | { left: DefinedError[] } => {
        if (Patch8Request.is(o)) {
            return { right: o }
        }
        return { left: (Patch8Request.errors ?? []) as DefinedError[] }
    },
} as const

export type Patch9Request = PatchOperation[]

export const Patch9Request = {
    validate: Patch9RequestValidator as ValidateFunction<Patch9Request>,
    get schema() {
        return Patch9Request.validate.schema
    },
    get errors() {
        return Patch9Request.validate.errors ?? undefined
    },
    is: (o: unknown): o is Patch9Request => Patch9Request.validate(o) === true,
    parse: (o: unknown): { right: Patch9Request } | { left: DefinedError[] } => {
        if (Patch9Request.is(o)) {
            return { right: o }
        }
        return { left: (Patch9Request.errors ?? []) as DefinedError[] }
    },
} as const

export type PatchAuthorizationHoldRequest = PatchOperation[]

export const PatchAuthorizationHoldRequest = {
    validate: PatchAuthorizationHoldRequestValidator as ValidateFunction<PatchAuthorizationHoldRequest>,
    get schema() {
        return PatchAuthorizationHoldRequest.validate.schema
    },
    get errors() {
        return PatchAuthorizationHoldRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is PatchAuthorizationHoldRequest => PatchAuthorizationHoldRequest.validate(o) === true,
    parse: (o: unknown): { right: PatchAuthorizationHoldRequest } | { left: DefinedError[] } => {
        if (PatchAuthorizationHoldRequest.is(o)) {
            return { right: o }
        }
        return { left: (PatchAuthorizationHoldRequest.errors ?? []) as DefinedError[] }
    },
} as const

export type PatchBlockFundRequest = PatchOperation[]

export const PatchBlockFundRequest = {
    validate: PatchBlockFundRequestValidator as ValidateFunction<PatchBlockFundRequest>,
    get schema() {
        return PatchBlockFundRequest.validate.schema
    },
    get errors() {
        return PatchBlockFundRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is PatchBlockFundRequest => PatchBlockFundRequest.validate(o) === true,
    parse: (o: unknown): { right: PatchBlockFundRequest } | { left: DefinedError[] } => {
        if (PatchBlockFundRequest.is(o)) {
            return { right: o }
        }
        return { left: (PatchBlockFundRequest.errors ?? []) as DefinedError[] }
    },
} as const

export type PatchFundingSourceRequest = PatchOperation[]

export const PatchFundingSourceRequest = {
    validate: PatchFundingSourceRequestValidator as ValidateFunction<PatchFundingSourceRequest>,
    get schema() {
        return PatchFundingSourceRequest.validate.schema
    },
    get errors() {
        return PatchFundingSourceRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is PatchFundingSourceRequest => PatchFundingSourceRequest.validate(o) === true,
    parse: (o: unknown): { right: PatchFundingSourceRequest } | { left: DefinedError[] } => {
        if (PatchFundingSourceRequest.is(o)) {
            return { right: o }
        }
        return { left: (PatchFundingSourceRequest.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * A single change that needs to be made to a resource
 */
export interface PatchOperation {
    /**
     * The field from where a value should be moved, when using move
     */
    from?: string | undefined
    /**
     * The change to perform
     */
    op: 'ADD' | 'REPLACE' | 'REMOVE' | 'MOVE'
    /**
     * The field to perform the operation on
     */
    path: string
    /**
     * The value of the field, can be null
     */
    value?: unknown
}

export type PatchRequest = PatchOperation[]

export const PatchRequest = {
    validate: PatchRequestValidator as ValidateFunction<PatchRequest>,
    get schema() {
        return PatchRequest.validate.schema
    },
    get errors() {
        return PatchRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is PatchRequest => PatchRequest.validate(o) === true,
    parse: (o: unknown): { right: PatchRequest } | { left: DefinedError[] } => {
        if (PatchRequest.is(o)) {
            return { right: o }
        }
        return { left: (PatchRequest.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The payment information including account identification details
 */
export interface PaymentDetails {
    creditor?: Party | undefined
    creditorAccount?: AccountDetails | undefined
    creditorAgent?: Agent | undefined
    debtor?: Party | undefined
    debtorAccount?: AccountDetails | undefined
    debtorAgent?: Agent | undefined
    paymentIdentification?: PaymentIdentification | undefined
    paymentTypeInformation?: PaymentTypeInformation | undefined
    remittanceInformation?: RemittanceInformation | undefined
}

/**
 * Holds Payment Holidays Settings
 */
export interface PaymentHolidaysSettings {
    /**
     * payment holiday option
     */
    paymentHolidaysLoanTermOption?: 'EXTEND_LOAN_TERM' | 'KEEP_THE_SAME_LOAN_TERM' | undefined
}

/**
 * The payment identification details
 */
export interface PaymentIdentification {
    /**
     * Identifier assigned by the initiating party to the transaction
     */
    endToEndIdentification?: string | undefined
    /**
     * Identifier of a payment instruction
     */
    instructionIdentification?: string | undefined
    /**
     * Identifier unique for a period assigned by the first initiating party to the transaction
     */
    transactionIdentification?: string | undefined
}

/**
 * Represents the request payload for creating a transaction of type PAYMENT_MADE
 */
export interface PaymentMadeTransactionInput {
    /**
     * The amount of the payment
     */
    amount: number
    /**
     * The booking date of the payment made transaction (as Organization Time)
     */
    bookingDate?: string | undefined
    /**
     * The external id of the payment made transaction, customizable, unique
     */
    externalId?: string | undefined
    /**
     * Notes about the payment made transaction. The notes can have at most 255 characters in length.
     */
    notes?: string | undefined
    /**
     * The currency code for the payment made transaction
     */
    originalCurrencyCode?: string | undefined
    transactionDetails?: LoanTransactionDetailsInput | undefined
    /**
     * The entry date of the payment made transaction (as Organization Time)
     */
    valueDate?: string | undefined
}

export const PaymentMadeTransactionInput = {
    validate: PaymentMadeTransactionInputValidator as ValidateFunction<PaymentMadeTransactionInput>,
    get schema() {
        return PaymentMadeTransactionInput.validate.schema
    },
    get errors() {
        return PaymentMadeTransactionInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is PaymentMadeTransactionInput => PaymentMadeTransactionInput.validate(o) === true,
    parse: (o: unknown): { right: PaymentMadeTransactionInput } | { left: DefinedError[] } => {
        if (PaymentMadeTransactionInput.is(o)) {
            return { right: o }
        }
        return { left: (PaymentMadeTransactionInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Defines the payment settings for the loan product and for loans crated based on this product.
 */
export interface PaymentSettings {
    /**
     * Payments Method used by loan accounts for repayments schedule generation.
     */
    amortizationMethod?: 'STANDARD_PAYMENTS' | 'BALLOON_PAYMENTS' | 'OPTIMIZED_PAYMENTS' | 'PAYMENT_PLAN' | undefined
    /**
     * Recalculate the schedule when late payments are posted on dynamic Equal Installments loans.
     */
    latePaymentsRecalculationMethod: 'OVERDUE_INSTALLMENTS_INCREASE' | 'LAST_INSTALLMENT_INCREASE' | 'NO_RECALCULATION'
    /**
     * The payment method. Represents the interest payment method that determines whether the payments are made Horizontally (on the Repayments) or Vertically (on the Loan Account)
     */
    paymentMethod: 'HORIZONTAL' | 'VERTICAL'
    prepaymentSettings?: ProductPrepaymentSettings | undefined
    principalPaymentSettings?: PrincipalPaymentProductSettings | undefined
    /**
     * A list of basic repayment allocation elements such as the principal, interest & fees.
     */
    repaymentAllocationOrder: ('PRINCIPAL' | 'INTEREST' | 'FEE' | 'PENALTY')[]
}

/**
 * The information specifying the type of transaction
 */
export interface PaymentTypeInformation {
    serviceLevel?: ServiceLevel | undefined
}

/**
 * Adjustable amounts to be paid for Pay Off action
 */
export interface PayOffAdjustableAmounts {
    /**
     * The fee amount to be paid for Pay Off action
     */
    feesPaid?: number | undefined
    /**
     * The interest from arrears amount to be paid for Pay Off action
     */
    interestFromArrearsPaid?: number | undefined
    /**
     * The interest amount to be paid for Pay Off action
     */
    interestPaid?: number | undefined
    /**
     * The penalty amount to be paid for Pay Off action
     */
    penaltyPaid?: number | undefined
}

/**
 * The penalty settings, holds all the fields regarding penalties
 */
export interface PenaltySettings {
    /**
     * The last penalty calculation method, represents on what amount are the penalties calculated.
     */
    loanPenaltyCalculationMethod?:
        | 'NONE'
        | 'OVERDUE_BALANCE'
        | 'OVERDUE_BALANCE_AND_INTEREST'
        | 'OUTSTANDING_PRINCIPAL'
        | undefined
    /**
     * The penalty rate, represents the rate (in percent) which is charged as a penalty.
     */
    penaltyRate?: number | undefined
}

/**
 * For fixed term loans there is the possibility to define a payment plan. A payment plan consists of multiple periodic payments. This class holds information about a periodic payment.
 */
export interface PeriodicPayment {
    /**
     * The PMT value used in periodic payment
     */
    amount: number
    /**
     * The encoded key of the periodic payment, auto generated, unique.
     */
    encodedKey?: string | undefined
    /**
     * The installment's position up to which the PMT will be used
     */
    toInstallment: number
}

/**
 * For fixed term loans there is the possibility to define a payment plan. A payment plan consists of multiple periodic payments. This class holds information about a periodic payment for schedule preview.
 */
export interface PeriodicPaymentForSchedulePreview {
    /**
     * The PMT value used in periodic payment
     */
    amount: number
    /**
     * The installment's position up to which the PMT will be used
     */
    toInstallment: number
}

/**
 * The settings for defining period intervals.
 */
export interface PeriodIntervalSettings {
    /**
     * Type of amortization profile used for fee
     */
    amortizationProfile?: 'NONE' | 'SUM_OF_YEARS_DIGITS' | 'STRAIGHT_LINE' | 'EFFECTIVE_INTEREST_RATE' | undefined
    /**
     * The encoded key of the period interval settings, auto generated, unique.
     */
    encodedKey?: string | undefined
    /**
     * Flag for signaling if fee amortization should be continued or finished at account reschedule/refinance
     */
    feeAmortizationUponRescheduleRefinanceOption?:
        | 'END_AMORTIZATION_ON_THE_ORIGINAL_ACCOUNT'
        | 'CONTINUE_AMORTIZATION_ON_THE_RESCHEDULED_REFINANCED_ACCOUNT'
        | undefined
    /**
     * Frequency settings of the fee amortization
     */
    frequency?: 'ACCOUNT_INSTALLMENTS_DUE_DATES' | 'ACCOUNT_INSTALLMENTS_DUE_DATES_DAILY_BOOKING' | 'CUSTOM_INTERVAL' | undefined
    /**
     * Total number of intervals
     */
    intervalCount?: number | undefined
    /**
     * Defines the options for an interval
     */
    intervalType?: 'PREDEFINED_INTERVALS' | 'FULL_TERM' | undefined
    /**
     * Period count used in conjunction with periodUnit to determine the next date of the interval
     */
    periodCount?: number | undefined
    /**
     * Amortization unit to determine the interval between amortizations
     */
    periodUnit?: 'DAYS' | 'WEEKS' | 'MONTHS' | 'YEARS' | undefined
}

type Permissions3 =
    | 'AUDIT_TRANSACTIONS'
    | 'VIEW_COMMENTS'
    | 'CREATE_COMMENTS'
    | 'EDIT_COMMENTS'
    | 'DELETE_COMMENTS'
    | 'CREATE_INDEX_RATE'
    | 'DOWNLOAD_BACKUPS'
    | 'IMPORT_DATA'
    | 'VIEW_BACKGROUND_TASKS'
    | 'VIEW_EXCHANGE_RATES'
    | 'CREATE_EXCHANGE_RATE'
    | 'VIEW_CENTRE_DETAILS'
    | 'CREATE_CENTRE'
    | 'EDIT_CENTRE'
    | 'DELETE_CENTRE'
    | 'MANAGE_CONFIGURATION_AS_CODE'
    | 'GET_MANAGE_CONFIGURATION_AS_CODE'
    | 'PUT_MANAGE_CONFIGURATION_AS_CODE'
    | 'VIEW_BRANCH_DETAILS'
    | 'CREATE_BRANCH'
    | 'EDIT_BRANCH'
    | 'CREATE_COMMUNICATION_TEMPLATES'
    | 'EDIT_COMMUNICATION_TEMPLATES'
    | 'SEND_MANUAL_SMS'
    | 'SEND_MANUAL_EMAIL'
    | 'VIEW_COMMUNICATION_HISTORY'
    | 'RESEND_FAILED_MESSAGES'
    | 'VIEW_TRANSACTION_CHANNELS'
    | 'CREATE_TRANSACTION_CHANNELS'
    | 'EDIT_TRANSACTION_CHANNELS'
    | 'DELETE_TRANSACTION_CHANNELS'
    | 'MANAGE_HOLIDAYS'
    | 'MANAGE_INDEX_RATES'
    | 'MANAGE_EOD_PROCESSING'
    | 'MANAGE_INTERNAL_CONTROLS'
    | 'MANAGE_CURRENCIES'
    | 'MANAGE_AUTHORIZATION_HOLDS_SETUP'
    | 'MANAGE_RISK_LEVELS'
    | 'VIEW_LOAN_PRODUCT_DETAILS'
    | 'CREATE_LOAN_PRODUCT'
    | 'EDIT_LOAN_PRODUCT'
    | 'DELETE_LOAN_PRODUCTS'
    | 'VIEW_SAVINGS_PRODUCT_DETAILS'
    | 'CREATE_SAVINGS_PRODUCT'
    | 'EDIT_SAVINGS_PRODUCT'
    | 'DELETE_SAVINGS_PRODUCT'
    | 'CREATE_PRODUCT_DOCUMENT_TEMPLATES'
    | 'EDIT_PRODUCT_DOCUMENT_TEMPLATES'
    | 'DELETE_PRODUCT_DOCUMENT_TEMPLATES'
    | 'VIEW_CLIENT_DETAILS'
    | 'CREATE_CLIENT'
    | 'EDIT_CLIENT'
    | 'DELETE_CLIENTS'
    | 'APPROVE_CLIENT'
    | 'REJECT_CLIENT'
    | 'EXIT_CLIENT'
    | 'ANONYMIZE_CLIENT'
    | 'BLACKLIST_CLIENT'
    | 'UNDO_CLIENT_STATE_CHANGED'
    | 'EDIT_CLIENT_ID'
    | 'EDIT_BLACKLISTED_CLIENT_CFV'
    | 'EDIT_GROUP_ID'
    | 'CHANGE_CLIENT_TYPE'
    | 'VIEW_GROUP_DETAILS'
    | 'CREATE_GROUP'
    | 'EDIT_GROUP'
    | 'DELETE_GROUP'
    | 'CHANGE_GROUP_TYPE'
    | 'VIEW_LINE_OF_CREDIT_DETAILS'
    | 'CREATE_LINES_OF_CREDIT'
    | 'EDIT_LINES_OF_CREDIT'
    | 'ADD_ACCOUNTS_TO_LINE_OF_CREDIT'
    | 'REMOVE_ACCOUNTS_FROM_LINE_OF_CREDIT'
    | 'APPROVE_LINE_OF_CREDIT'
    | 'UNDO_APPROVE_LINE_OF_CREDIT'
    | 'WITHDRAW_LINE_OF_CREDIT'
    | 'UNDO_WITHDRAW_LINE_OF_CREDIT'
    | 'REJECT_LINE_OF_CREDIT'
    | 'UNDO_REJECT_LINE_OF_CREDIT'
    | 'CLOSE_LINES_OF_CREDIT'
    | 'DELETE_LINES_OF_CREDIT'
    | 'VIEW_LOAN_ACCOUNT_DETAILS'
    | 'CREATE_LOAN_ACCOUNT'
    | 'EDIT_LOAN_ACCOUNT'
    | 'DELETE_LOAN_ACCOUNT'
    | 'ENTER_REPAYMENT'
    | 'EDIT_REPAYMENT_SCHEDULE'
    | 'APPROVE_LOANS'
    | 'REQUEST_LOAN_APPROVAL'
    | 'DIBURSE_LOANS'
    | 'WITHDRAW_LOAN_ACCOUNTS'
    | 'UNDO_WITHDRAW_LOAN_ACCOUNTS'
    | 'SET_LOAN_INCOMPLETE'
    | 'REJECT_LOANS'
    | 'UNDO_REJECT_LOANS'
    | 'CLOSE_LOAN_ACCOUNTS'
    | 'WRITE_OFF_LOAN_ACCOUNTS'
    | 'TERMINATE_LOAN_ACCOUNTS'
    | 'PAY_OFF_LOAN'
    | 'UNDO_LOAN_ACCOUNT_CLOSURE'
    | 'REVERSE_LOAN_ACCOUNT_WRITE_OFF'
    | 'REFINANCE_LOAN_ACCOUNT'
    | 'RESCHEDULE_LOAN_ACCOUNT'
    | 'APPLY_ACCRUED_LOAN_INTEREST'
    | 'APPLY_LOAN_FEES'
    | 'APPLY_LOAN_ADJUSTMENTS'
    | 'EDIT_PLANNED_FEES'
    | 'BACKDATE_LOAN_TRANSACTIONS'
    | 'LINK_ACCOUNTS'
    | 'COLLECT_GUARANTIES'
    | 'VIEW_SECURITIES_DETAILS'
    | 'CREATE_SECURITIES'
    | 'EDIT_SECURITIES'
    | 'DELETE_SECURITIES'
    | 'LOCK_LOAN_ACCOUNTS'
    | 'POST_TRANSACTIONS_ON_LOCKED_LOAN_ACCOUNTS'
    | 'EDIT_LOAN_TRANCHES'
    | 'EDIT_PENALTY_RATE'
    | 'SET_DISBURSEMENT_CONDITIONS'
    | 'EDIT_LOAN_TRANSACTIONS'
    | 'BULK_LOAN_CORRECTIONS'
    | 'EDIT_INTEREST_RATE'
    | 'EDIT_REPAYMENT_METHOD_VALUE'
    | 'EDIT_PERIODIC_PAYMENT_FOR_ACTIVE_ACCOUNT'
    | 'MANAGE_LOAN_ASSOCIATION'
    | 'MAKE_WITHDRAWAL_REDRAW'
    | 'ENTER_REFUND'
    | 'VIEW_SAVINGS_ACCOUNT_DETAILS'
    | 'CREATE_SAVINGS_ACCOUNT'
    | 'EDIT_SAVINGS_ACCOUNT'
    | 'DELETE_SAVINGS_ACCOUNT'
    | 'MAKE_DEPOSIT'
    | 'MAKE_BULK_DEPOSITS'
    | 'MAKE_WITHDRAWAL'
    | 'MAKE_EARLY_WITHDRAWALS'
    | 'APPROVE_SAVINGS'
    | 'ACTIVATE_MATURITY'
    | 'UNDO_MATURITY'
    | 'CLOSE_SAVINGS_ACCOUNTS'
    | 'APPLY_SAVINGS_FEES'
    | 'REOPEN_SAVINGS_ACCOUNT'
    | 'APPLY_SAVINGS_ADJUSTMENTS'
    | 'LOCK_SAVINGS_ACCOUNT'
    | 'UNLOCK_SAVINGS_ACCOUNT'
    | 'REVERSE_SAVINGS_ACCOUNT_WRITE_OFF'
    | 'BACKDATE_SAVINGS_TRANSACTIONS'
    | 'MAKE_TRANSFER'
    | 'MAKE_INTER_CLIENTS_TRANSFERS'
    | 'POST_TRANSACTIONS_ON_DORMANT_ACCOUNTS'
    | 'APPLY_ACCRUED_SAVINGS_INTEREST'
    | 'EDIT_SAVINGS_TRANSACTIONS'
    | 'BULK_DEPOSIT_CORRECTIONS'
    | 'BLOCK_AND_SEIZE_FUNDS'
    | 'WITHDRAW_BLOCKED_FUNDS'
    | 'MANAGE_DEPOSIT_ACCOUNT_RECIPIENT'
    | 'MANAGE_DEPOSIT_ASSOCIATION'
    | 'BYPASS_ACCOUNT_OWNERSHIP_TRANSFER_VIEW_RESTRICTION'
    | 'CREATE_CARDS'
    | 'VIEW_CARDS'
    | 'DELETE_CARDS'
    | 'REVERSE_CARD_WITHDRAWAL_TRANSACTION'
    | 'REVERSE_CARD_TRANSACTION'
    | 'CARD_BALANCE_INQUIRY'
    | 'CREATE_AUTHORIZATION_HOLD'
    | 'UPDATE_AUTHORIZATION_HOLD'
    | 'VIEW_AUTHORIZATION_HOLD'
    | 'CREATE_CARD_TRANSACTION'
    | 'CREATE_ACCOUNT_HOLD'
    | 'UPDATE_ACCOUNT_HOLD'
    | 'VIEW_ACCOUNT_HOLD'
    | 'VIEW_DOCUMENTS'
    | 'CREATE_DOCUMENTS'
    | 'EDIT_DOCUMENTS'
    | 'DELETE_DOCUMENTS'
    | 'VIEW_TASK'
    | 'CREATE_TASK'
    | 'EDIT_TASK'
    | 'DELETE_TASK'
    | 'VIEW_INTELLIGENCE'
    | 'VIEW_REPORTS'
    | 'CREATE_REPORTS'
    | 'EDIT_REPORTS'
    | 'DELETE_REPORTS'
    | 'VIEW_JASPER_REPORTS'
    | 'CREATE_JASPER_REPORTS'
    | 'EDIT_JASPER_REPORTS'
    | 'DELETE_JASPER_REPORTS'
    | 'VIEW_CHART_OF_ACCOUNTS'
    | 'MANAGE_ACCOUNTS'
    | 'VIEW_JOURNAL_ENTRIES'
    | 'LOG_JOURNAL_ENTRIES'
    | 'VIEW_ACCOUNTING_REPORTS'
    | 'MAKE_ACCOUNTING_CLOSURE'
    | 'APPLY_ACCOUNTING_ADJUSTMENTS'
    | 'BOOKING_DATE_LOANS_GL'
    | 'BOOKING_DATE_SAVINGS_GL'
    | 'RECTIFY_ADJUSTMENT'
    | 'MANAGE_INTERBRANCH_GLACCOUNT_RULES'
    | 'VIEW_ACCOUNTING_RATES'
    | 'CREATE_ACCOUNTING_RATES'
    | 'OPEN_TILL'
    | 'CLOSE_TILL'
    | 'ADD_CASH'
    | 'REMOVE_CASH'
    | 'POST_TRANSACTIONS_WITHOUT_OPENED_TILL'
    | 'VIEW_INVESTOR_FUNDS_DETAILS'
    | 'CREATE_INVESTOR_FUNDS'
    | 'EDIT_INVESTOR_FUNDS'
    | 'DELETE_INVESTOR_FUNDS'
    | 'SELL_LOAN_FRACTION'
    | 'CREATE_USER'
    | 'EDIT_USER'
    | 'VIEW_USER_DETAILS'
    | 'DELETE_USER'
    | 'MANAGE_TWO_FACTOR_AUTHENTICATION'
    | 'MANAGE_CLIENT_ASSOCIATION'
    | 'MANAGE_GROUP_ASSOCIATION'
    | 'EDIT_PRINCIPAL_PAYMENT_ACTIVE_REVOLVING_CREDIT'
    | 'PERFORM_REPAYMENTS_WITH_CUSTOM_AMOUNTS_ALLOCATION'
    | 'EXPORT_TO_EXCEL'
    | 'VIEW_ADMINISTRATION_DETAILS'
    | 'MANAGE_EVENTS_STREAMING'
    | 'MANAGE_PAYMENTS'
    | 'MANAGE_AUDIT_TRAIL'
    | 'MANAGE_APPS'
    | 'MANAGE_CARDS_CAPABILITY'
    | 'MANAGE_NOTIFICATIONS'
    | 'ADMIN'
    | 'CREATE_ROLE'
    | 'EDIT_ROLE'
    | 'DELETE_ROLE'
    | 'VIEW_ROLE'
    | 'MANAGE_FEDERATED_AUTHENTICATION'
    | 'MANAGE_ACCESS_PREFERENCES'
    | 'VIEW_API_CONSUMERS_AND_KEYS'
    | 'CREATE_API_CONSUMERS_AND_KEYS'
    | 'EDIT_API_CONSUMERS_AND_KEYS'
    | 'DELETE_API_CONSUMERS_AND_KEYS'
    | 'VIEW_CUSTOM_FIELD'
    | 'CREATE_CUSTOM_FIELD'
    | 'EDIT_CUSTOM_FIELD'
    | 'DELETE_CUSTOM_FIELD'
    | 'VIEW_MAMBU_FUNCTIONS'
    | 'CREATE_MAMBU_FUNCTIONS'
    | 'EDIT_MAMBU_FUNCTIONS'
    | 'DELETE_MAMBU_FUNCTIONS'
    | 'VIEW_MAMBU_FUNCTIONS_SECRETS'
    | 'CREATE_MAMBU_FUNCTIONS_SECRETS'
    | 'EDIT_MAMBU_FUNCTIONS_SECRETS'
    | 'DELETE_MAMBU_FUNCTIONS_SECRETS'
    | 'VIEW_PROFIT_SHARING_PROPOSALS'
    | 'CREATE_PROFIT_SHARING_CASH_FLOWS'
    | 'VIEW_PROFIT_SHARING_CASH_FLOWS'
    | 'EDIT_PROFIT_SHARING_CASH_FLOWS'
    | 'DELETE_PROFIT_SHARING_CASH_FLOWS'
    | 'CREATE_PROFIT_SHARING_POOLS'
    | 'VIEW_PROFIT_SHARING_POOLS'
    | 'EDIT_PROFIT_SHARING_POOLS'
    | 'DELETE_PROFIT_SHARING_POOLS'
    | 'CREATE_PROFIT_SHARING_PRODUCT_SETTINGS'
    | 'VIEW_PROFIT_SHARING_PRODUCT_SETTINGS'
    | 'EDIT_PROFIT_SHARING_PRODUCT_SETTINGS'
    | 'DELETE_PROFIT_SHARING_PRODUCT_SETTINGS'
    | 'MAKE_BULK_CHANGE_INTEREST_AVAILABILITY'

type Permissions2 =
    | 'AUDIT_TRANSACTIONS'
    | 'VIEW_COMMENTS'
    | 'CREATE_COMMENTS'
    | 'EDIT_COMMENTS'
    | 'DELETE_COMMENTS'
    | 'CREATE_INDEX_RATE'
    | 'DOWNLOAD_BACKUPS'
    | 'IMPORT_DATA'
    | 'VIEW_BACKGROUND_TASKS'
    | 'VIEW_EXCHANGE_RATES'
    | 'CREATE_EXCHANGE_RATE'
    | 'VIEW_CENTRE_DETAILS'
    | 'CREATE_CENTRE'
    | 'EDIT_CENTRE'
    | 'DELETE_CENTRE'
    | 'MANAGE_CONFIGURATION_AS_CODE'
    | 'GET_MANAGE_CONFIGURATION_AS_CODE'
    | 'PUT_MANAGE_CONFIGURATION_AS_CODE'
    | 'VIEW_BRANCH_DETAILS'
    | 'CREATE_BRANCH'
    | 'EDIT_BRANCH'
    | 'CREATE_COMMUNICATION_TEMPLATES'
    | 'EDIT_COMMUNICATION_TEMPLATES'
    | 'SEND_MANUAL_SMS'
    | 'SEND_MANUAL_EMAIL'
    | 'VIEW_COMMUNICATION_HISTORY'
    | 'RESEND_FAILED_MESSAGES'
    | 'VIEW_TRANSACTION_CHANNELS'
    | 'CREATE_TRANSACTION_CHANNELS'
    | 'EDIT_TRANSACTION_CHANNELS'
    | 'DELETE_TRANSACTION_CHANNELS'
    | 'MANAGE_HOLIDAYS'
    | 'MANAGE_INDEX_RATES'
    | 'MANAGE_EOD_PROCESSING'
    | 'MANAGE_INTERNAL_CONTROLS'
    | 'MANAGE_CURRENCIES'
    | 'MANAGE_AUTHORIZATION_HOLDS_SETUP'
    | 'MANAGE_RISK_LEVELS'
    | 'VIEW_LOAN_PRODUCT_DETAILS'
    | 'CREATE_LOAN_PRODUCT'
    | 'EDIT_LOAN_PRODUCT'
    | 'DELETE_LOAN_PRODUCTS'
    | 'VIEW_SAVINGS_PRODUCT_DETAILS'
    | 'CREATE_SAVINGS_PRODUCT'
    | 'EDIT_SAVINGS_PRODUCT'
    | 'DELETE_SAVINGS_PRODUCT'
    | 'CREATE_PRODUCT_DOCUMENT_TEMPLATES'
    | 'EDIT_PRODUCT_DOCUMENT_TEMPLATES'
    | 'DELETE_PRODUCT_DOCUMENT_TEMPLATES'
    | 'VIEW_CLIENT_DETAILS'
    | 'CREATE_CLIENT'
    | 'EDIT_CLIENT'
    | 'DELETE_CLIENTS'
    | 'APPROVE_CLIENT'
    | 'REJECT_CLIENT'
    | 'EXIT_CLIENT'
    | 'ANONYMIZE_CLIENT'
    | 'BLACKLIST_CLIENT'
    | 'UNDO_CLIENT_STATE_CHANGED'
    | 'EDIT_CLIENT_ID'
    | 'EDIT_BLACKLISTED_CLIENT_CFV'
    | 'EDIT_GROUP_ID'
    | 'CHANGE_CLIENT_TYPE'
    | 'VIEW_GROUP_DETAILS'
    | 'CREATE_GROUP'
    | 'EDIT_GROUP'
    | 'DELETE_GROUP'
    | 'CHANGE_GROUP_TYPE'
    | 'VIEW_LINE_OF_CREDIT_DETAILS'
    | 'CREATE_LINES_OF_CREDIT'
    | 'EDIT_LINES_OF_CREDIT'
    | 'ADD_ACCOUNTS_TO_LINE_OF_CREDIT'
    | 'REMOVE_ACCOUNTS_FROM_LINE_OF_CREDIT'
    | 'APPROVE_LINE_OF_CREDIT'
    | 'UNDO_APPROVE_LINE_OF_CREDIT'
    | 'WITHDRAW_LINE_OF_CREDIT'
    | 'UNDO_WITHDRAW_LINE_OF_CREDIT'
    | 'REJECT_LINE_OF_CREDIT'
    | 'UNDO_REJECT_LINE_OF_CREDIT'
    | 'CLOSE_LINES_OF_CREDIT'
    | 'DELETE_LINES_OF_CREDIT'
    | 'VIEW_LOAN_ACCOUNT_DETAILS'
    | 'CREATE_LOAN_ACCOUNT'
    | 'EDIT_LOAN_ACCOUNT'
    | 'DELETE_LOAN_ACCOUNT'
    | 'ENTER_REPAYMENT'
    | 'EDIT_REPAYMENT_SCHEDULE'
    | 'APPROVE_LOANS'
    | 'REQUEST_LOAN_APPROVAL'
    | 'DIBURSE_LOANS'
    | 'WITHDRAW_LOAN_ACCOUNTS'
    | 'UNDO_WITHDRAW_LOAN_ACCOUNTS'
    | 'SET_LOAN_INCOMPLETE'
    | 'REJECT_LOANS'
    | 'UNDO_REJECT_LOANS'
    | 'CLOSE_LOAN_ACCOUNTS'
    | 'WRITE_OFF_LOAN_ACCOUNTS'
    | 'TERMINATE_LOAN_ACCOUNTS'
    | 'PAY_OFF_LOAN'
    | 'UNDO_LOAN_ACCOUNT_CLOSURE'
    | 'REVERSE_LOAN_ACCOUNT_WRITE_OFF'
    | 'REFINANCE_LOAN_ACCOUNT'
    | 'RESCHEDULE_LOAN_ACCOUNT'
    | 'APPLY_ACCRUED_LOAN_INTEREST'
    | 'APPLY_LOAN_FEES'
    | 'APPLY_LOAN_ADJUSTMENTS'
    | 'EDIT_PLANNED_FEES'
    | 'BACKDATE_LOAN_TRANSACTIONS'
    | 'LINK_ACCOUNTS'
    | 'COLLECT_GUARANTIES'
    | 'VIEW_SECURITIES_DETAILS'
    | 'CREATE_SECURITIES'
    | 'EDIT_SECURITIES'
    | 'DELETE_SECURITIES'
    | 'LOCK_LOAN_ACCOUNTS'
    | 'POST_TRANSACTIONS_ON_LOCKED_LOAN_ACCOUNTS'
    | 'EDIT_LOAN_TRANCHES'
    | 'EDIT_PENALTY_RATE'
    | 'SET_DISBURSEMENT_CONDITIONS'
    | 'EDIT_LOAN_TRANSACTIONS'
    | 'BULK_LOAN_CORRECTIONS'
    | 'EDIT_INTEREST_RATE'
    | 'EDIT_REPAYMENT_METHOD_VALUE'
    | 'EDIT_PERIODIC_PAYMENT_FOR_ACTIVE_ACCOUNT'
    | 'MANAGE_LOAN_ASSOCIATION'
    | 'MAKE_WITHDRAWAL_REDRAW'
    | 'ENTER_REFUND'
    | 'VIEW_SAVINGS_ACCOUNT_DETAILS'
    | 'CREATE_SAVINGS_ACCOUNT'
    | 'EDIT_SAVINGS_ACCOUNT'
    | 'DELETE_SAVINGS_ACCOUNT'
    | 'MAKE_DEPOSIT'
    | 'MAKE_BULK_DEPOSITS'
    | 'MAKE_WITHDRAWAL'
    | 'MAKE_EARLY_WITHDRAWALS'
    | 'APPROVE_SAVINGS'
    | 'ACTIVATE_MATURITY'
    | 'UNDO_MATURITY'
    | 'CLOSE_SAVINGS_ACCOUNTS'
    | 'APPLY_SAVINGS_FEES'
    | 'REOPEN_SAVINGS_ACCOUNT'
    | 'APPLY_SAVINGS_ADJUSTMENTS'
    | 'LOCK_SAVINGS_ACCOUNT'
    | 'UNLOCK_SAVINGS_ACCOUNT'
    | 'REVERSE_SAVINGS_ACCOUNT_WRITE_OFF'
    | 'BACKDATE_SAVINGS_TRANSACTIONS'
    | 'MAKE_TRANSFER'
    | 'MAKE_INTER_CLIENTS_TRANSFERS'
    | 'POST_TRANSACTIONS_ON_DORMANT_ACCOUNTS'
    | 'APPLY_ACCRUED_SAVINGS_INTEREST'
    | 'EDIT_SAVINGS_TRANSACTIONS'
    | 'BULK_DEPOSIT_CORRECTIONS'
    | 'BLOCK_AND_SEIZE_FUNDS'
    | 'WITHDRAW_BLOCKED_FUNDS'
    | 'MANAGE_DEPOSIT_ACCOUNT_RECIPIENT'
    | 'MANAGE_DEPOSIT_ASSOCIATION'
    | 'BYPASS_ACCOUNT_OWNERSHIP_TRANSFER_VIEW_RESTRICTION'
    | 'CREATE_CARDS'
    | 'VIEW_CARDS'
    | 'DELETE_CARDS'
    | 'REVERSE_CARD_WITHDRAWAL_TRANSACTION'
    | 'REVERSE_CARD_TRANSACTION'
    | 'CARD_BALANCE_INQUIRY'
    | 'CREATE_AUTHORIZATION_HOLD'
    | 'UPDATE_AUTHORIZATION_HOLD'
    | 'VIEW_AUTHORIZATION_HOLD'
    | 'CREATE_CARD_TRANSACTION'
    | 'CREATE_ACCOUNT_HOLD'
    | 'UPDATE_ACCOUNT_HOLD'
    | 'VIEW_ACCOUNT_HOLD'
    | 'VIEW_DOCUMENTS'
    | 'CREATE_DOCUMENTS'
    | 'EDIT_DOCUMENTS'
    | 'DELETE_DOCUMENTS'
    | 'VIEW_TASK'
    | 'CREATE_TASK'
    | 'EDIT_TASK'
    | 'DELETE_TASK'
    | 'VIEW_INTELLIGENCE'
    | 'VIEW_REPORTS'
    | 'CREATE_REPORTS'
    | 'EDIT_REPORTS'
    | 'DELETE_REPORTS'
    | 'VIEW_JASPER_REPORTS'
    | 'CREATE_JASPER_REPORTS'
    | 'EDIT_JASPER_REPORTS'
    | 'DELETE_JASPER_REPORTS'
    | 'VIEW_CHART_OF_ACCOUNTS'
    | 'MANAGE_ACCOUNTS'
    | 'VIEW_JOURNAL_ENTRIES'
    | 'LOG_JOURNAL_ENTRIES'
    | 'VIEW_ACCOUNTING_REPORTS'
    | 'MAKE_ACCOUNTING_CLOSURE'
    | 'APPLY_ACCOUNTING_ADJUSTMENTS'
    | 'BOOKING_DATE_LOANS_GL'
    | 'BOOKING_DATE_SAVINGS_GL'
    | 'RECTIFY_ADJUSTMENT'
    | 'MANAGE_INTERBRANCH_GLACCOUNT_RULES'
    | 'VIEW_ACCOUNTING_RATES'
    | 'CREATE_ACCOUNTING_RATES'
    | 'OPEN_TILL'
    | 'CLOSE_TILL'
    | 'ADD_CASH'
    | 'REMOVE_CASH'
    | 'POST_TRANSACTIONS_WITHOUT_OPENED_TILL'
    | 'VIEW_INVESTOR_FUNDS_DETAILS'
    | 'CREATE_INVESTOR_FUNDS'
    | 'EDIT_INVESTOR_FUNDS'
    | 'DELETE_INVESTOR_FUNDS'
    | 'SELL_LOAN_FRACTION'
    | 'CREATE_USER'
    | 'EDIT_USER'
    | 'VIEW_USER_DETAILS'
    | 'DELETE_USER'
    | 'MANAGE_TWO_FACTOR_AUTHENTICATION'
    | 'MANAGE_CLIENT_ASSOCIATION'
    | 'MANAGE_GROUP_ASSOCIATION'
    | 'EDIT_PRINCIPAL_PAYMENT_ACTIVE_REVOLVING_CREDIT'
    | 'PERFORM_REPAYMENTS_WITH_CUSTOM_AMOUNTS_ALLOCATION'
    | 'EXPORT_TO_EXCEL'
    | 'VIEW_ADMINISTRATION_DETAILS'
    | 'MANAGE_EVENTS_STREAMING'
    | 'MANAGE_PAYMENTS'
    | 'MANAGE_AUDIT_TRAIL'
    | 'MANAGE_APPS'
    | 'MANAGE_CARDS_CAPABILITY'
    | 'MANAGE_NOTIFICATIONS'
    | 'ADMIN'
    | 'CREATE_ROLE'
    | 'EDIT_ROLE'
    | 'DELETE_ROLE'
    | 'VIEW_ROLE'
    | 'MANAGE_FEDERATED_AUTHENTICATION'
    | 'MANAGE_ACCESS_PREFERENCES'
    | 'VIEW_API_CONSUMERS_AND_KEYS'
    | 'CREATE_API_CONSUMERS_AND_KEYS'
    | 'EDIT_API_CONSUMERS_AND_KEYS'
    | 'DELETE_API_CONSUMERS_AND_KEYS'
    | 'VIEW_CUSTOM_FIELD'
    | 'CREATE_CUSTOM_FIELD'
    | 'EDIT_CUSTOM_FIELD'
    | 'DELETE_CUSTOM_FIELD'
    | 'VIEW_MAMBU_FUNCTIONS'
    | 'CREATE_MAMBU_FUNCTIONS'
    | 'EDIT_MAMBU_FUNCTIONS'
    | 'DELETE_MAMBU_FUNCTIONS'
    | 'VIEW_MAMBU_FUNCTIONS_SECRETS'
    | 'CREATE_MAMBU_FUNCTIONS_SECRETS'
    | 'EDIT_MAMBU_FUNCTIONS_SECRETS'
    | 'DELETE_MAMBU_FUNCTIONS_SECRETS'
    | 'VIEW_PROFIT_SHARING_PROPOSALS'
    | 'CREATE_PROFIT_SHARING_CASH_FLOWS'
    | 'VIEW_PROFIT_SHARING_CASH_FLOWS'
    | 'EDIT_PROFIT_SHARING_CASH_FLOWS'
    | 'DELETE_PROFIT_SHARING_CASH_FLOWS'
    | 'CREATE_PROFIT_SHARING_POOLS'
    | 'VIEW_PROFIT_SHARING_POOLS'
    | 'EDIT_PROFIT_SHARING_POOLS'
    | 'DELETE_PROFIT_SHARING_POOLS'
    | 'CREATE_PROFIT_SHARING_PRODUCT_SETTINGS'
    | 'VIEW_PROFIT_SHARING_PRODUCT_SETTINGS'
    | 'EDIT_PROFIT_SHARING_PRODUCT_SETTINGS'
    | 'DELETE_PROFIT_SHARING_PRODUCT_SETTINGS'
    | 'MAKE_BULK_CHANGE_INTEREST_AVAILABILITY'

type Permissions =
    | 'AUDIT_TRANSACTIONS'
    | 'VIEW_EXCHANGE_RATES'
    | 'CREATE_EXCHANGE_RATE'
    | 'VIEW_LOAN_ACCOUNT_DETAILS'
    | 'CREATE_LOAN_ACCOUNT'
    | 'EDIT_LOAN_ACCOUNT'
    | 'APPROVE_LOANS'
    | 'DIBURSE_LOANS'
    | 'APPLY_LOAN_FEES'
    | 'ENTER_REPAYMENT'
    | 'EDIT_PLANNED_FEES'
    | 'EDIT_REPAYMENT_SCHEDULE'
    | 'APPLY_LOAN_ADJUSTMENTS'
    | 'BACKDATE_LOAN_TRANSACTIONS'
    | 'APPLY_ACCRUED_LOAN_INTEREST'
    | 'POST_TRANSACTIONS_ON_LOCKED_LOAN_ACCOUNTS'
    | 'EDIT_PENALTY_RATE'
    | 'VIEW_INVESTOR_FUNDS_DETAILS'
    | 'CREATE_INVESTOR_FUNDS'
    | 'EDIT_INVESTOR_FUNDS'
    | 'DELETE_INVESTOR_FUNDS'
    | 'SELL_LOAN_FRACTION'
    | 'REQUEST_LOAN_APPROVAL'
    | 'EDIT_LOAN_TRANCHES'
    | 'REJECT_LOANS'
    | 'WRITE_OFF_LOAN_ACCOUNTS'
    | 'PAY_OFF_LOAN'
    | 'REVERSE_LOAN_ACCOUNT_WRITE_OFF'
    | 'CLOSE_LOAN_ACCOUNTS'
    | 'LOCK_LOAN_ACCOUNTS'
    | 'WITHDRAW_LOAN_ACCOUNTS'
    | 'DELETE_LOAN_ACCOUNT'
    | 'SET_DISBURSEMENT_CONDITIONS'
    | 'RESCHEDULE_LOAN_ACCOUNT'
    | 'REFINANCE_LOAN_ACCOUNT'
    | 'EDIT_LOAN_TRANSACTIONS'
    | 'BULK_LOAN_CORRECTIONS'
    | 'EDIT_INTEREST_RATE'
    | 'EDIT_REPAYMENT_METHOD_VALUE'
    | 'EDIT_PERIODIC_PAYMENT_FOR_ACTIVE_ACCOUNT'
    | 'UNDO_LOAN_ACCOUNT_CLOSURE'
    | 'UNDO_REJECT_LOANS'
    | 'UNDO_WITHDRAW_LOAN_ACCOUNTS'
    | 'LINK_ACCOUNTS'
    | 'EDIT_PRINCIPAL_PAYMENT_ACTIVE_REVOLVING_CREDIT'
    | 'PERFORM_REPAYMENTS_WITH_CUSTOM_AMOUNTS_ALLOCATION'
    | 'MANAGE_LOAN_ASSOCIATION'
    | 'MAKE_WITHDRAWAL_REDRAW'
    | 'ENTER_REFUND'
    | 'VIEW_SAVINGS_ACCOUNT_DETAILS'
    | 'CREATE_SAVINGS_ACCOUNT'
    | 'EDIT_SAVINGS_ACCOUNT'
    | 'APPROVE_SAVINGS'
    | 'MAKE_DEPOSIT'
    | 'MAKE_BULK_DEPOSITS'
    | 'MAKE_WITHDRAWAL'
    | 'BACKDATE_SAVINGS_TRANSACTIONS'
    | 'APPLY_SAVINGS_ADJUSTMENTS'
    | 'MAKE_TRANSFER'
    | 'MAKE_INTER_CLIENTS_TRANSFERS'
    | 'CLOSE_SAVINGS_ACCOUNTS'
    | 'REOPEN_SAVINGS_ACCOUNT'
    | 'APPLY_SAVINGS_FEES'
    | 'DELETE_SAVINGS_ACCOUNT'
    | 'POST_TRANSACTIONS_ON_DORMANT_ACCOUNTS'
    | 'EDIT_SAVINGS_TRANSACTIONS'
    | 'BULK_DEPOSIT_CORRECTIONS'
    | 'ACTIVATE_MATURITY'
    | 'APPLY_ACCRUED_SAVINGS_INTEREST'
    | 'LOCK_SAVINGS_ACCOUNT'
    | 'UNLOCK_SAVINGS_ACCOUNT'
    | 'UNDO_MATURITY'
    | 'MAKE_EARLY_WITHDRAWALS'
    | 'BLOCK_AND_SEIZE_FUNDS'
    | 'WITHDRAW_BLOCKED_FUNDS'
    | 'MAKE_BULK_CHANGE_INTEREST_AVAILABILITY'
    | 'MANAGE_DEPOSIT_ACCOUNT_RECIPIENT'
    | 'MANAGE_DEPOSIT_ASSOCIATION'
    | 'BYPASS_ACCOUNT_OWNERSHIP_TRANSFER_VIEW_RESTRICTION'
    | 'CREATE_CARDS'
    | 'VIEW_CARDS'
    | 'DELETE_CARDS'
    | 'REVERSE_CARD_WITHDRAWAL_TRANSACTION'
    | 'CARD_BALANCE_INQUIRY'
    | 'CREATE_AUTHORIZATION_HOLD'
    | 'UPDATE_AUTHORIZATION_HOLD'
    | 'VIEW_AUTHORIZATION_HOLD'
    | 'CREATE_CARD_TRANSACTION'
    | 'CREATE_ACCOUNT_HOLD'
    | 'UPDATE_ACCOUNT_HOLD'
    | 'VIEW_ACCOUNT_HOLD'
    | 'VIEW_SECURITIES_DETAILS'
    | 'CREATE_SECURITIES'
    | 'EDIT_SECURITIES'
    | 'DELETE_SECURITIES'
    | 'CREATE_LINES_OF_CREDIT'
    | 'EDIT_LINES_OF_CREDIT'
    | 'VIEW_LINE_OF_CREDIT_DETAILS'
    | 'ADD_ACCOUNTS_TO_LINE_OF_CREDIT'
    | 'REMOVE_ACCOUNTS_FROM_LINE_OF_CREDIT'
    | 'APPROVE_LINE_OF_CREDIT'
    | 'UNDO_APPROVE_LINE_OF_CREDIT'
    | 'WITHDRAW_LINE_OF_CREDIT'
    | 'UNDO_WITHDRAW_LINE_OF_CREDIT'
    | 'REJECT_LINE_OF_CREDIT'
    | 'UNDO_REJECT_LINE_OF_CREDIT'
    | 'CLOSE_LINES_OF_CREDIT'
    | 'DELETE_LINES_OF_CREDIT'
    | 'VIEW_LOAN_PRODUCT_DETAILS'
    | 'CREATE_LOAN_PRODUCT'
    | 'DELETE_LOAN_PRODUCTS'
    | 'EDIT_LOAN_PRODUCT'
    | 'VIEW_SAVINGS_PRODUCT_DETAILS'
    | 'CREATE_SAVINGS_PRODUCT'
    | 'EDIT_SAVINGS_PRODUCT'
    | 'DELETE_SAVINGS_PRODUCT'
    | 'VIEW_CLIENT_DETAILS'
    | 'CREATE_CLIENT'
    | 'EDIT_CLIENT'
    | 'DELETE_CLIENTS'
    | 'VIEW_GROUP_DETAILS'
    | 'CREATE_GROUP'
    | 'EDIT_GROUP'
    | 'DELETE_GROUP'
    | 'CHANGE_CLIENT_TYPE'
    | 'CHANGE_GROUP_TYPE'
    | 'APPROVE_CLIENT'
    | 'REJECT_CLIENT'
    | 'EXIT_CLIENT'
    | 'BLACKLIST_CLIENT'
    | 'UNDO_CLIENT_STATE_CHANGED'
    | 'ANONYMIZE_CLIENT'
    | 'MANAGE_CLIENT_ASSOCIATION'
    | 'MANAGE_GROUP_ASSOCIATION'
    | 'EDIT_CLIENT_ID'
    | 'EDIT_GROUP_ID'
    | 'EDIT_BLACKLISTED_CLIENT_CFV'
    | 'VIEW_ACCOUNTING_REPORTS'
    | 'LOG_JOURNAL_ENTRIES'
    | 'BOOKING_DATE_LOANS_GL'
    | 'BOOKING_DATE_SAVINGS_GL'
    | 'RECTIFY_ADJUSTMENT'
    | 'VIEW_ACCOUNTING_RATES'
    | 'CREATE_ACCOUNTING_RATES'
    | 'VIEW_DOCUMENTS'
    | 'CREATE_DOCUMENTS'
    | 'EDIT_DOCUMENTS'
    | 'DELETE_DOCUMENTS'
    | 'VIEW_TASK'
    | 'CREATE_TASK'
    | 'EDIT_TASK'
    | 'DELETE_TASK'
    | 'VIEW_USER_DETAILS'
    | 'CREATE_USER'
    | 'EDIT_USER'
    | 'DELETE_USER'
    | 'VIEW_ROLE'
    | 'CREATE_ROLE'
    | 'EDIT_ROLE'
    | 'DELETE_ROLE'
    | 'RESEND_FAILED_MESSAGES'
    | 'SEND_MANUAL_SMS'
    | 'SEND_MANUAL_EMAIL'
    | 'GET_MANAGE_CONFIGURATION_AS_CODE'
    | 'PUT_MANAGE_CONFIGURATION_AS_CODE'
    | 'MANAGE_RISK_LEVELS'
    | 'MANAGE_EOD_PROCESSING'
    | 'MANAGE_CURRENCIES'
    | 'VIEW_INTELLIGENCE'
    | 'CREATE_INDEX_RATE'
    | 'VIEW_COMMENTS'
    | 'CREATE_COMMENTS'
    | 'EDIT_COMMENTS'
    | 'VIEW_COMMUNICATION_HISTORY'
    | 'DOWNLOAD_BACKUPS'
    | 'IMPORT_DATA'
    | 'VIEW_TRANSACTION_CHANNELS'
    | 'CREATE_TRANSACTION_CHANNELS'
    | 'EDIT_TRANSACTION_CHANNELS'
    | 'DELETE_TRANSACTION_CHANNELS'
    | 'POST_TRANSACTIONS_WITHOUT_OPENED_TILL'
    | 'VIEW_CUSTOM_FIELD'
    | 'VIEW_BRANCH_DETAILS'
    | 'CREATE_BRANCH'
    | 'EDIT_BRANCH'
    | 'VIEW_CENTRE_DETAILS'
    | 'CREATE_CENTRE'
    | 'EDIT_CENTRE'
    | 'DELETE_CENTRE'
    | 'MANAGE_HOLIDAYS'
    | 'MANAGE_INDEX_RATES'
    | 'MANAGE_EVENTS_STREAMING'
    | 'MANAGE_AUDIT_TRAIL'
    | 'MANAGE_PAYMENTS'
    | 'MANAGE_CARDS_CAPABILITY'
    | 'CREATE_API_CONSUMERS_AND_KEYS'
    | 'DELETE_API_CONSUMERS_AND_KEYS'
    | 'EDIT_API_CONSUMERS_AND_KEYS'
    | 'VIEW_API_CONSUMERS_AND_KEYS'
    | 'MANAGE_NOTIFICATIONS'
    | 'VIEW_MAMBU_FUNCTIONS'
    | 'CREATE_MAMBU_FUNCTIONS'
    | 'EDIT_MAMBU_FUNCTIONS'
    | 'DELETE_MAMBU_FUNCTIONS'
    | 'VIEW_MAMBU_FUNCTIONS_SECRETS'
    | 'CREATE_MAMBU_FUNCTIONS_SECRETS'
    | 'EDIT_MAMBU_FUNCTIONS_SECRETS'
    | 'DELETE_MAMBU_FUNCTIONS_SECRETS'
    | 'VIEW_PROFIT_SHARING_PROPOSALS'
    | 'CREATE_PROFIT_SHARING_CASH_FLOWS'
    | 'VIEW_PROFIT_SHARING_CASH_FLOWS'
    | 'EDIT_PROFIT_SHARING_CASH_FLOWS'
    | 'DELETE_PROFIT_SHARING_CASH_FLOWS'
    | 'CREATE_PROFIT_SHARING_POOLS'
    | 'VIEW_PROFIT_SHARING_POOLS'
    | 'EDIT_PROFIT_SHARING_POOLS'
    | 'DELETE_PROFIT_SHARING_POOLS'
    | 'CREATE_PROFIT_SHARING_PRODUCT_SETTINGS'
    | 'VIEW_PROFIT_SHARING_PRODUCT_SETTINGS'
    | 'EDIT_PROFIT_SHARING_PRODUCT_SETTINGS'
    | 'DELETE_PROFIT_SHARING_PRODUCT_SETTINGS'

/**
 * The planned installment fees encoded keys list
 */
export interface PlannedFeeKeys {
    /**
     * The list of encoded keys of the planned installment fees.
     */
    encodedKeys: string[]
}

export const PlannedFeeKeys = {
    validate: PlannedFeeKeysValidator as ValidateFunction<PlannedFeeKeys>,
    get schema() {
        return PlannedFeeKeys.validate.schema
    },
    get errors() {
        return PlannedFeeKeys.validate.errors ?? undefined
    },
    is: (o: unknown): o is PlannedFeeKeys => PlannedFeeKeys.validate(o) === true,
    parse: (o: unknown): { right: PlannedFeeKeys } | { left: DefinedError[] } => {
        if (PlannedFeeKeys.is(o)) {
            return { right: o }
        }
        return { left: (PlannedFeeKeys.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The planned fee details holds the information related to the installment key, predefined fee key and amount
 */
export interface PlannedInstallmentFee {
    /**
     * The amount of the planned fee.
     */
    amount?: number | undefined
    /**
     * The date when a planned fee should be applied, overriding installment's due date. It should match the interval of the installment. If it belong to first installment, it should be between disbursement date and installment due date.
     */
    applyOnDate?: string | undefined
    /**
     * The encoded key of the planned installment fee, auto generated, unique.
     */
    encodedKey?: string | undefined
    /**
     * The encoded key of the installment on which the predefined fee is planned.
     */
    installmentKey?: string | undefined
    /**
     * The number of the installment on which the predefined fee is planned. It is used only in the case when fees are created at the same time with the loan account creation or during preview schedule, before account creation, otherwise this should be empty and installmentKey will be used to identify an installment.
     */
    installmentNumber?: number | undefined
    /**
     * The encoded key of the predefined fee which is planned.
     */
    predefinedFeeKey: string
}

/**
 * Represents PMT Adjustment threshold settings for loan accounts and loan products.
 */
export interface PMTAdjustmentThreshold {
    /**
     * The method used to calculate the PMT Adjustment threshold. Supported value is CALENDAR_DAYS
     */
    method?: 'WORKING_DAYS' | 'CALENDAR_DAYS' | undefined
    /**
     * The number of days that trigger a PMT Adjustment.
     */
    numberOfDays?: number | undefined
}

/**
 * Represents portal settings for an individual client.
 */
export interface PortalSettings {
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The last date the client logged in to the portal.
     */
    lastLoggedInDate?: string | undefined
    /**
     * The state of the client's portal preferences.
     */
    portalState?: 'ENABLED' | 'DISABLED' | undefined
}

/**
 * The representation of a payload for creating Accounting Rate
 */
export interface PostAccountingRateDTO {
    /**
     * Value of conversions rate used in accounting to convert amounts from one currency to organisation currency
     */
    rate: number
    /**
     * The start date from which the accounting rate will be applied (as Organization time)
     */
    startDate?: string | undefined
}

export const PostAccountingRateDTO = {
    validate: PostAccountingRateDTOValidator as ValidateFunction<PostAccountingRateDTO>,
    get schema() {
        return PostAccountingRateDTO.validate.schema
    },
    get errors() {
        return PostAccountingRateDTO.validate.errors ?? undefined
    },
    is: (o: unknown): o is PostAccountingRateDTO => PostAccountingRateDTO.validate(o) === true,
    parse: (o: unknown): { right: PostAccountingRateDTO } | { left: DefinedError[] } => {
        if (PostAccountingRateDTO.is(o)) {
            return { right: o }
        }
        return { left: (PostAccountingRateDTO.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the information to create general ledger journal entries.
 */
export interface PostGLJournalEntriesDTO {
    /**
     * The ID of the assigned branch for the journal entries.
     */
    branchId?: string | undefined
    /**
     * The list of general ledger accounts to be credited with corresponding amounts.
     */
    credits?: GLAccountAmount[] | undefined
    /**
     * The date and time when the general ledger journal entries were recorded, also known as the booking date.
     */
    date: string
    /**
     * The list of general ledger accounts to be debited with corresponding amounts.
     */
    debits?: GLAccountAmount[] | undefined
    /**
     * The notes entered when the journal entry was posted.
     */
    notes?: string | undefined
    /**
     * A non-unique trasanction ID. This will be autogenerated if an ID is not provided.
     */
    transactionId?: string | undefined
}

export const PostGLJournalEntriesDTO = {
    validate: PostGLJournalEntriesDTOValidator as ValidateFunction<PostGLJournalEntriesDTO>,
    get schema() {
        return PostGLJournalEntriesDTO.validate.schema
    },
    get errors() {
        return PostGLJournalEntriesDTO.validate.errors ?? undefined
    },
    is: (o: unknown): o is PostGLJournalEntriesDTO => PostGLJournalEntriesDTO.validate(o) === true,
    parse: (o: unknown): { right: PostGLJournalEntriesDTO } | { left: DefinedError[] } => {
        if (PostGLJournalEntriesDTO.is(o)) {
            return { right: o }
        }
        return { left: (PostGLJournalEntriesDTO.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The response representation of the PredefinedFee. Represents a fee with a defined name and a fixed value.
 */
export interface PredefinedFee {
    /**
     * A list of accounting rules defined for this fee. If null, product default rules are selected.
     */
    accountingRules?: GLAccountingRule[] | undefined
    amortizationSettings?: PeriodIntervalSettings | undefined
    /**
     * The amount of the fee
     */
    amount?: number | undefined
    /**
     * Mambu Function name used for the fee calculation
     */
    amountCalculationFunctionName?: string | undefined
    /**
     * The amount from which the fee is calculated using percentageAmount
     */
    amountCalculationMethod?:
        | 'FLAT'
        | 'LOAN_AMOUNT_PERCENTAGE'
        | 'REPAYMENT_PRINCIPAL_AMOUNT_PERCENTAGE'
        | 'LOAN_AMOUNT_PERCENTAGE_NUMBER_OF_INSTALLMENTS'
        | 'FLAT_NUMBER_OF_INSTALLMENTS'
        | 'IOF_PERCENTAGE_OF_DISBURSED_AMOUNT'
        | 'IOF_PERCENTAGE_OF_INSTALLMENT_PRINCIPAL'
        | 'IOF_PERCENTAGE_OF_LATE_INSTALLMENT_PRINCIPAL'
        | 'MAMBU_FUNCTION'
        | undefined
    /**
     * Shows when a fee should be applied; to be used with monthly deposit fees
     */
    applyDateMethod?: 'MONTHLY_FROM_ACTIVATION' | 'FIRST_OF_EVERY_MONTH' | undefined
    /**
     * Shows the creation date of the fee
     */
    creationDate?: string | undefined
    /**
     * The encoded key of the predefined fee, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * The type of fee application when disbursement is applied
     */
    feeApplication: 'REQUIRED' | 'OPTIONAL'
    /**
     * The id of the fee
     */
    id?: string | undefined
    /**
     * Shows the last modified date of the fee
     */
    lastModifiedDate?: string | undefined
    /**
     * The name of the fee
     */
    name?: string | undefined
    /**
     * The amount of the fee in percents applied to percentSource
     */
    percentageAmount?: number | undefined
    /**
     * Indicates the state of the fee
     */
    state: 'ACTIVE' | 'INACTIVE'
    taxSettings?: FeeTaxSettings | undefined
    /**
     * Shows the event that will trigger a fee
     */
    trigger:
        | 'MANUAL'
        | 'MANUAL_PLANNED'
        | 'DISBURSEMENT'
        | 'CAPITALIZED_DISBURSEMENT'
        | 'UPFRONT_DISBURSEMENT'
        | 'LATE_REPAYMENT'
        | 'PAYMENT_DUE'
        | 'PAYMENT_DUE_APPLIED_ON_DUE_DATES'
        | 'ARBITRARY'
        | 'IOF'
        | 'EARLY_REPAYMENT_CHARGE'
}

/**
 * The prepayment settings, holds all prepayment properties.
 */
export interface PrepaymentSettings {
    /**
     * Apply interest on prepayment method copied from loan product on which this account is based.
     */
    applyInterestOnPrepaymentMethod?: 'AUTOMATIC' | 'MANUAL' | undefined
    /**
     * The elements recalculation method, indicates how the declining balance with equal installments repayments are recalculated.
     */
    elementsRecalculationMethod?: 'PRINCIPAL_EXPECTED_FIXED' | 'TOTAL_EXPECTED_FIXED' | undefined
    ercFreeAllowanceAmount?: number | undefined
    /**
     * Early repayment charge fee free allowance in percentage per year
     */
    ercFreeAllowancePercentage?: number | undefined
    /**
     * Prepayment recalculation method copied from the loan product on which this account is based.
     */
    prepaymentRecalculationMethod?:
        | 'NO_RECALCULATION'
        | 'RESCHEDULE_REMAINING_REPAYMENTS'
        | 'RECALCULATE_SCHEDULE_KEEP_SAME_NUMBER_OF_TERMS'
        | 'RECALCULATE_SCHEDULE_KEEP_SAME_PRINCIPAL_AMOUNT'
        | 'RECALCULATE_SCHEDULE_KEEP_SAME_TOTAL_REPAYMENT_AMOUNT'
        | 'REDUCE_AMOUNT_PER_INSTALLMENT'
        | 'REDUCE_NUMBER_OF_INSTALLMENTS'
        | 'REDUCE_NUMBER_OF_INSTALLMENTS_NEW'
        | undefined
    /**
     * Installment status for the case when principal is paid off (copied from loan product).
     */
    principalPaidInstallmentStatus?: 'PARTIALLY_PAID' | 'PAID' | 'ORIGINAL_TOTAL_EXPECTED_PAID' | undefined
}

/**
 * Payload structure to preview loan account schedule.
 */
export interface PreviewLoanAccountSchedule {
    disbursementDetails?: DisbursementDetailsForSchedulePreview | undefined
    /**
     * The value of the interest booked by the organization from the accounts funded by investors. Null if the funds are not enable
     */
    interestCommission?: number | undefined
    interestSettings?: InterestSettingsForSchedulePreview | undefined
    /**
     * The loan amount
     */
    loanAmount: number
    /**
     * A list with planned manual fees to be applied on the installments for schedule preview.
     */
    plannedInstallmentFees?: PlannedInstallmentFee[] | undefined
    /**
     * The key to the type of product that this account is based on.
     */
    productTypeKey: string
    scheduleSettings?: ScheduleSettingsForSchedulePreview | undefined
    /**
     * The top up amount in case of a refinanced account
     */
    topUpAmount?: number | undefined
    /**
     * List of tranches to be considered for schedule preview.
     */
    tranches?: LoanTranche[] | undefined
}

export const PreviewLoanAccountSchedule = {
    validate: PreviewLoanAccountScheduleValidator as ValidateFunction<PreviewLoanAccountSchedule>,
    get schema() {
        return PreviewLoanAccountSchedule.validate.schema
    },
    get errors() {
        return PreviewLoanAccountSchedule.validate.errors ?? undefined
    },
    is: (o: unknown): o is PreviewLoanAccountSchedule => PreviewLoanAccountSchedule.validate(o) === true,
    parse: (o: unknown): { right: PreviewLoanAccountSchedule } | { left: DefinedError[] } => {
        if (PreviewLoanAccountSchedule.is(o)) {
            return { right: o }
        }
        return { left: (PreviewLoanAccountSchedule.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the information to preview the pay off due amounts in a future date.
 */
export interface PreviewPayOffDueAmountsInAFutureDateInput {
    /**
     * The date until which the amounts due for pay off should be calculated
     */
    valueDate: string
}

export const PreviewPayOffDueAmountsInAFutureDateInput = {
    validate: PreviewPayOffDueAmountsInAFutureDateInputValidator as ValidateFunction<PreviewPayOffDueAmountsInAFutureDateInput>,
    get schema() {
        return PreviewPayOffDueAmountsInAFutureDateInput.validate.schema
    },
    get errors() {
        return PreviewPayOffDueAmountsInAFutureDateInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is PreviewPayOffDueAmountsInAFutureDateInput =>
        PreviewPayOffDueAmountsInAFutureDateInput.validate(o) === true,
    parse: (o: unknown): { right: PreviewPayOffDueAmountsInAFutureDateInput } | { left: DefinedError[] } => {
        if (PreviewPayOffDueAmountsInAFutureDateInput.is(o)) {
            return { right: o }
        }
        return { left: (PreviewPayOffDueAmountsInAFutureDateInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents a wrapper over a set of due amounts representing pay off due amounts in a future date
 */
export interface PreviewPayOffDueAmountsInAFutureDateWrapper {
    /**
     * The early repayment charge balance due when pay off the account in a future date
     */
    earlyRepaymentCharge?: number | undefined
    /**
     * The fee balance due when pay off the account in a future date
     */
    feeBalance?: number | undefined
    /**
     * The interest balance due when pay off the account in a future date
     */
    interestBalance?: number | undefined
    /**
     * The interest from arrears balance due when pay off the account in a future date
     */
    interestFromArrearsBalance?: number | undefined
    /**
     * The penalty balance due when pay off the account in a future date
     */
    penaltyBalance?: number | undefined
    /**
     * The principal balance due when pay off the account in a future date
     */
    principalBalance?: number | undefined
    /**
     * The total balance due when pay off the account in a future date
     */
    totalBalance?: number | undefined
}

export const PreviewPayOffDueAmountsInAFutureDateWrapper = {
    validate:
        PreviewPayOffDueAmountsInAFutureDateWrapperValidator as ValidateFunction<PreviewPayOffDueAmountsInAFutureDateWrapper>,
    get schema() {
        return PreviewPayOffDueAmountsInAFutureDateWrapper.validate.schema
    },
    get errors() {
        return PreviewPayOffDueAmountsInAFutureDateWrapper.validate.errors ?? undefined
    },
    is: (o: unknown): o is PreviewPayOffDueAmountsInAFutureDateWrapper =>
        PreviewPayOffDueAmountsInAFutureDateWrapper.validate(o) === true,
    parse: (o: unknown): { right: PreviewPayOffDueAmountsInAFutureDateWrapper } | { left: DefinedError[] } => {
        if (PreviewPayOffDueAmountsInAFutureDateWrapper.is(o)) {
            return { right: o }
        }
        return { left: (PreviewPayOffDueAmountsInAFutureDateWrapper.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Defines the Preview Schedule settings for revolving products
 */
export interface PreviewScheduleSettings {
    /**
     * Number of Previewed Instalments.
     */
    numberOfPreviewedInstalments?: number | undefined
    /**
     * Preview Schedule status.
     */
    previewScheduleEnabled?: boolean | undefined
}

export type PreviewTranchesOnScheduleRequest = LoanTranche[]

export const PreviewTranchesOnScheduleRequest = {
    validate: PreviewTranchesOnScheduleRequestValidator as ValidateFunction<PreviewTranchesOnScheduleRequest>,
    get schema() {
        return PreviewTranchesOnScheduleRequest.validate.schema
    },
    get errors() {
        return PreviewTranchesOnScheduleRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is PreviewTranchesOnScheduleRequest => PreviewTranchesOnScheduleRequest.validate(o) === true,
    parse: (o: unknown): { right: PreviewTranchesOnScheduleRequest } | { left: DefinedError[] } => {
        if (PreviewTranchesOnScheduleRequest.is(o)) {
            return { right: o }
        }
        return { left: (PreviewTranchesOnScheduleRequest.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The principal payment account settings, holds the required information for the principal payment process of an account.
 */
export interface PrincipalPaymentAccountSettings {
    /**
     * Fixed amount for being used for the repayments principal due.
     */
    amount?: number | undefined
    /**
     * The encoded key of the principal payment base settings, auto generated, unique.
     */
    encodedKey?: string | undefined
    /**
     * Boolean flag, if true, the fees will be included along with the principal in the repayment floor amount, for a revolving credit account
     */
    includeFeesInFloorAmount?: boolean | undefined
    /**
     * Boolean flag, if true, the interest will be included along with the principal in the repayment floor amount, for a revolving credit account
     */
    includeInterestInFloorAmount?: boolean | undefined
    /**
     * Percentage of principal amount used for the repayments principal due.
     */
    percentage?: number | undefined
    /**
     * The maximum principal due amount a repayment made with this settings can have
     */
    principalCeilingValue?: number | undefined
    /**
     * The minimum principal due amount a repayment made with this settings can have
     */
    principalFloorValue?: number | undefined
    /**
     * The method of principal payment for revolving credit.
     */
    principalPaymentMethod?:
        | 'FLAT'
        | 'OUTSTANDING_PRINCIPAL_PERCENTAGE'
        | 'PRINCIPAL_PERCENTAGE_LAST_DISB'
        | 'TOTAL_BALANCE_PERCENTAGE'
        | 'TOTAL_BALANCE_FLAT'
        | 'TOTAL_PRINCIPAL_PERCENTAGE'
        | undefined
    /**
     * The minimum total due amount a repayment made with this settings can have
     */
    totalDueAmountFloor?: number | undefined
    /**
     * The method of total due payment for revolving credit
     */
    totalDuePayment?:
        | 'FLAT'
        | 'OUTSTANDING_PRINCIPAL_PERCENTAGE'
        | 'PRINCIPAL_PERCENTAGE_LAST_DISB'
        | 'TOTAL_BALANCE_PERCENTAGE'
        | 'TOTAL_BALANCE_FLAT'
        | 'TOTAL_PRINCIPAL_PERCENTAGE'
        | undefined
}

/**
 * Defines the principal payment settings constraints for the loans that will be created based on this product.
 */
export interface PrincipalPaymentProductSettings {
    amount?: AmountDecimalConstraints | undefined
    /**
     * How many repayments the principal has to be paid
     */
    defaultPrincipalRepaymentInterval?: number | undefined
    /**
     * The encoded key of the settings, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * If true, the fees will be included along with the principal in the repayment floor amount, for a revolving credit account
     */
    includeFeesInFloorAmount?: boolean | undefined
    /**
     * If true, the interest will be included along with the principal in the repayment floor amount, for a revolving credit account
     */
    includeInterestInFloorAmount?: boolean | undefined
    percentage?: DecimalConstraints | undefined
    /**
     * The maximum principal due amount a repayment made with this settings can have
     */
    principalCeilingValue?: number | undefined
    /**
     * The minimum principal due amount a repayment made with this settings can have
     */
    principalFloorValue?: number | undefined
    /**
     * The method of principal payment for revolving credit
     */
    principalPaymentMethod?:
        | 'FLAT'
        | 'OUTSTANDING_PRINCIPAL_PERCENTAGE'
        | 'PRINCIPAL_PERCENTAGE_LAST_DISB'
        | 'TOTAL_BALANCE_PERCENTAGE'
        | 'TOTAL_BALANCE_FLAT'
        | 'TOTAL_PRINCIPAL_PERCENTAGE'
        | undefined
    /**
     * The minimum total due amount a repayment made with this settings can have
     */
    totalDueAmountFloor?: number | undefined
    /**
     * The method of total due payment for revolving credit
     */
    totalDuePayment?:
        | 'FLAT'
        | 'OUTSTANDING_PRINCIPAL_PERCENTAGE'
        | 'PRINCIPAL_PERCENTAGE_LAST_DISB'
        | 'TOTAL_BALANCE_PERCENTAGE'
        | 'TOTAL_BALANCE_FLAT'
        | 'TOTAL_PRINCIPAL_PERCENTAGE'
        | undefined
}

/**
 * It holds information about the loan product amortization period. The PMT is calculated as the loan would have [amortisationPeriod] instalments
 */
export interface ProductAmortizationPeriod {
    /**
     * default value
     */
    defaultValue?: number | undefined
    /**
     * max value
     */
    maxValue?: number | undefined
    /**
     * min value
     */
    minValue?: number | undefined
}

/**
 * The product arrears settings, shows whether the non working days are taken in consideration or not when applying penalties/late fees or when setting an account into arrears
 */
export interface ProductArrearsSettings {
    /**
     * The arrears date calculation method.
     */
    dateCalculationMethod?:
        | 'ACCOUNT_FIRST_WENT_TO_ARREARS'
        | 'LAST_LATE_REPAYMENT'
        | 'ACCOUNT_FIRST_BREACHED_MATERIALITY_THRESHOLD'
        | undefined
    /**
     * The encoded key of the arrears base settings, auto generated, unique.
     */
    encodedKey?: string | undefined
    /**
     * Defines the tolerance monthly date
     */
    monthlyToleranceDay?: number | undefined
    /**
     * Shows whether the non working days are taken in consideration or not when applying penaltees/late fees or when setting an account into arrears
     */
    nonWorkingDaysMethod?: 'INCLUDED' | 'EXCLUDED' | undefined
    /**
     * Defines the tolerance calculation method
     */
    toleranceCalculationMethod?: 'ARREARS_TOLERANCE_PERIOD' | 'MONTHLY_ARREARS_TOLERANCE_DAY' | undefined
    /**
     * The tolerance floor amount.
     */
    toleranceFloorAmount?: number | undefined
    tolerancePercentageOfOutstandingPrincipal?: DecimalInterval | undefined
    tolerancePeriod?: IntegerIntervalConstraints | undefined
}

/**
 * Holds information about product availability.
 */
export interface ProductAvailabilitySettings {
    /**
     * Holds the entities this product is available for. i.e Individuals
     */
    availableFor?: ('INDIVIDUALS' | 'PURE_GROUPS' | 'SOLIDARITY_GROUPS')[] | undefined
    branchSettings?: BranchSettings | undefined
}

/**
 * Adjustable interest rates settings
 */
export interface ProductInterestRateSettings {
    /**
     * The encoded key of the interest rate settings, auto generated, unique
     */
    encodedKey?: string | undefined
    /**
     * Index rate source key.
     */
    indexSourceKey?: string | undefined
    interestRate?: DecimalInterval | undefined
    /**
     * Maximum value allowed for index based interest rate. Valid only for index interest rate.
     */
    interestRateCeilingValue?: number | undefined
    /**
     * Minimum value allowed for index based interest rate. Valid only for index interest rate.
     */
    interestRateFloorValue?: number | undefined
    /**
     * Interest rate review frequency unit count. Valid only for index interest rate.
     */
    interestRateReviewCount?: number | undefined
    /**
     * Interest rate review frequency measurement unit. Valid only for index interest rate.
     */
    interestRateReviewUnit?: 'DAYS' | 'WEEKS' | 'MONTHS' | undefined
    /**
     * Interest calculation method: fixed or indexed(interest spread + active organization index interest rate)
     */
    interestRateSource: 'FIXED_INTEREST_RATE' | 'INDEX_INTEREST_RATE'
}

/**
 * The interest settings, defines constraints regarding interest that will be used on the loan account crated based on this product.
 */
export interface ProductInterestSettings {
    /**
     * Whether late interest should be accrued, applied and paid
     */
    accrueLateInterest?: boolean | undefined
    /**
     * The frequency on which the accrued interest will be added to the principal for interest calculation. It is used only for InterestType.COMPOUNDING_INTEREST
     */
    compoundingFrequency?: 'DAILY' | 'SEMI_ANNUALLY' | undefined
    /**
     * The days in year that should be used for loan calculations.
     */
    daysInYear: 'ACTUAL_365_FIXED' | 'ACTUAL_364' | 'ACTUAL_360' | 'ACTUAL_ACTUAL_ISDA' | 'E30_360' | 'BUS_252' | 'E30_42_365'
    /**
     * Whether interest from arrears is decoupled from regular interest. (Only accepted or returned if the feature is enabled.)
     */
    decoupleInterestFromArrears?: boolean | undefined
    indexRateSettings?: InterestProductSettings | undefined
    interestApplicationDays?: DaysInMonth | undefined
    /**
     * The interest application method. Represents the interest application method that determines whether the interest gets applied on the account's disbursement or on each repayment.
     */
    interestApplicationMethod?: 'AFTER_DISBURSEMENT' | 'REPAYMENT_DUE_DATE' | 'FIXED_DAYS_OF_MONTH' | undefined
    /**
     * The interest balance calculation method. Represents the option which determines the way the balance for the account's interest is computed.
     */
    interestBalanceCalculationMethod?: 'ONLY_PRINCIPAL' | 'PRINCIPAL_AND_INTEREST' | undefined
    /**
     * The interest calculation method. Holds the type of interest calculation method.
     */
    interestCalculationMethod: 'FLAT' | 'DECLINING_BALANCE' | 'DECLINING_BALANCE_DISCOUNTED' | 'EQUAL_INSTALLMENTS'
    /**
     * Adjustable interest rates settings
     */
    interestRateSettings?: ProductInterestRateSettings[] | undefined
    /**
     * The possible values for how we compute and apply the interest
     */
    interestType?: 'SIMPLE_INTEREST' | 'CAPITALIZED_INTEREST' | 'COMPOUNDING_INTEREST' | undefined
    pmtAdjustmentThreshold?: PMTAdjustmentThreshold | undefined
    /**
     * Shows  whether all the installments should compute the interest based on the actual number of days or based on the defined repayment periodicity.
     */
    scheduleInterestDaysCountMethod: 'REPAYMENT_PERIODICITY' | 'ACTUAL_DAYS_COUNT'
}

/**
 * Defines the penalty settings for the product that will be used by the loan accounts based on this product
 */
export interface ProductPenaltySettings {
    /**
     * The penalty calculation method
     */
    loanPenaltyCalculationMethod: 'NONE' | 'OVERDUE_BALANCE' | 'OVERDUE_BALANCE_AND_INTEREST' | 'OUTSTANDING_PRINCIPAL'
    /**
     * Number of days to wait before applying the loan penalty amounts
     */
    loanPenaltyGracePeriod?: number | undefined
    penaltyRate?: DecimalConstraints | undefined
}

/**
 * Defines the prepayment settings for the product
 */
export interface ProductPrepaymentSettings {
    /**
     * Whether the interest on prepayment is applied manual or automatic.
     */
    applyInterestOnPrepaymentMethod?: 'AUTOMATIC' | 'MANUAL' | undefined
    /**
     * The elements recalculation method, indicates how the declining balance with equal installments repayments are recalculated
     */
    elementsRecalculationMethod?: 'PRINCIPAL_EXPECTED_FIXED' | 'TOTAL_EXPECTED_FIXED' | undefined
    /**
     * ERC free allowance in percentage
     */
    ercFreeAllowance?: number | undefined
    /**
     * Shows whether the future payments are allowed or not for this product (repayment transactions with entry date set in the future)
     */
    futurePaymentsAcceptance: 'NO_FUTURE_PAYMENTS' | 'ACCEPT_FUTURE_PAYMENTS' | 'ACCEPT_OVERPAYMENTS'
    /**
     * Shows whether the pre-payments are allowed or not for this product.
     */
    prepaymentAcceptance?: 'ACCEPT_PREPAYMENTS' | 'NO_PREPAYMENTS' | undefined
    /**
     * Prepayment recalculation method copied from the loan product on which this account is based
     */
    prepaymentRecalculationMethod?:
        | 'NO_RECALCULATION'
        | 'RESCHEDULE_REMAINING_REPAYMENTS'
        | 'RECALCULATE_SCHEDULE_KEEP_SAME_NUMBER_OF_TERMS'
        | 'RECALCULATE_SCHEDULE_KEEP_SAME_PRINCIPAL_AMOUNT'
        | 'RECALCULATE_SCHEDULE_KEEP_SAME_TOTAL_REPAYMENT_AMOUNT'
        | 'REDUCE_AMOUNT_PER_INSTALLMENT'
        | 'REDUCE_NUMBER_OF_INSTALLMENTS'
        | 'REDUCE_NUMBER_OF_INSTALLMENTS_NEW'
        | undefined
    /**
     * Installment status for the case when principal is paid off (copied from loan product)
     */
    principalPaidInstallmentStatus?: 'PARTIALLY_PAID' | 'PAID' | 'ORIGINAL_TOTAL_EXPECTED_PAID' | undefined
}

/**
 * The redraw settings for the product.
 */
export interface ProductRedrawSettings {
    /**
     * Indicates whether the product support redraw (prepayments which are stored at loan account level as a Redrawable balance)
     */
    allowRedraw: boolean
}

/**
 * Represents the request payload for creating a transaction of type REDRAW_REPAYMENT
 */
export interface RedrawRepaymentTransactionInputDTO {
    /**
     * The amount of the redraw repayment
     */
    amount?: number | undefined
    /**
     * The booking date of the repayment (as Organization Time)
     */
    bookingDate?: string | undefined
    /**
     * Extra notes about the redraw repayment transaction. Notes can have at most 255 characters in length.
     */
    notes?: string | undefined
    /**
     * The entry date of the repayment (as Organization Time)
     */
    valueDate?: string | undefined
}

export const RedrawRepaymentTransactionInputDTO = {
    validate: RedrawRepaymentTransactionInputDTOValidator as ValidateFunction<RedrawRepaymentTransactionInputDTO>,
    get schema() {
        return RedrawRepaymentTransactionInputDTO.validate.schema
    },
    get errors() {
        return RedrawRepaymentTransactionInputDTO.validate.errors ?? undefined
    },
    is: (o: unknown): o is RedrawRepaymentTransactionInputDTO => RedrawRepaymentTransactionInputDTO.validate(o) === true,
    parse: (o: unknown): { right: RedrawRepaymentTransactionInputDTO } | { left: DefinedError[] } => {
        if (RedrawRepaymentTransactionInputDTO.is(o)) {
            return { right: o }
        }
        return { left: (RedrawRepaymentTransactionInputDTO.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The disbursement details, allowed on the loan account refinance
 */
export interface RefinanceDisbursementDetails {
    /**
     * The date of the expected disbursement
     */
    expectedDisbursementDate?: string | undefined
    /**
     * List of fees that should be applied at the disbursement time.
     */
    fees?: CustomPredefinedFee[] | undefined
    /**
     * The date of the expected first payment
     */
    firstRepaymentDate: string
}

/**
 * The new loan account settings, allowed on the loan account refinance
 */
export interface RefinanceLoanAccount {
    accountArrearsSettings?: RestructureAccountArrearsSettings | undefined
    disbursementDetails: RefinanceDisbursementDetails
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The guarantees associated with the refinanced loan account
     */
    guarantors?: Guarantor[] | undefined
    /**
     * Id of the new loan account.
     */
    id?: string | undefined
    interestSettings?: RestructureInterestSettings | undefined
    /**
     * The name of the new loan account.
     */
    loanName?: string | undefined
    /**
     * The loan account notes
     */
    notes?: string | undefined
    penaltySettings?: RestructurePenaltySettings | undefined
    principalPaymentSettings?: RestructurePrincipalPaymentAccountSettings | undefined
    /**
     * The key of the loan product that this account is based on
     */
    productTypeKey: string
    scheduleSettings?: RestructureScheduleSettings | undefined
}

/**
 * The request structure for performing the refinance loan account action
 */
export interface RefinanceLoanAccountAction {
    /**
     * Choose whether to keep the same account ID as the originating account. If true, the 'id' field in the 'loanAccount' object should not be provided.
     */
    keepSameAccountId?: boolean | undefined
    loanAccount: RefinanceLoanAccount
    /**
     * The top-up amount
     */
    topUpAmount: number
    writeOffAmounts?: RefinanceWriteOffAmounts | undefined
}

export const RefinanceLoanAccountAction = {
    validate: RefinanceLoanAccountActionValidator as ValidateFunction<RefinanceLoanAccountAction>,
    get schema() {
        return RefinanceLoanAccountAction.validate.schema
    },
    get errors() {
        return RefinanceLoanAccountAction.validate.errors ?? undefined
    },
    is: (o: unknown): o is RefinanceLoanAccountAction => RefinanceLoanAccountAction.validate(o) === true,
    parse: (o: unknown): { right: RefinanceLoanAccountAction } | { left: DefinedError[] } => {
        if (RefinanceLoanAccountAction.is(o)) {
            return { right: o }
        }
        return { left: (RefinanceLoanAccountAction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The write-off amounts, allowed on the loan account refinance
 */
export interface RefinanceWriteOffAmounts {
    /**
     * Fee write-off amount
     */
    fee?: number | undefined
    /**
     * Interest write-off amount
     */
    interest?: number | undefined
    interestFromArrears?: number | undefined
    /**
     * Penalty write-off amount
     */
    penalty?: number | undefined
}

/**
 * Represents the request payload for creating a transaction of type REFUND
 */
export interface RefundLoanTransactionInput {
    /**
     * The amount of the refund
     */
    amount: number
    /**
     * The booking date of the refund (as Organization Time)
     */
    bookingDate?: string | undefined
    /**
     * The external id of the refund transaction. Customizable and unique
     */
    externalId?: string | undefined
    /**
     * The disbursement key for which the refund is performed
     */
    linkedDisbursementKey: string
    /**
     * Extra notes about the refund transaction. Notes can have at most 255 characters in length.
     */
    notes?: string | undefined
    transactionDetails?: LoanTransactionDetailsInput | undefined
    /**
     * The entry date of the refund (as Organization Time)
     */
    valueDate?: string | undefined
}

export const RefundLoanTransactionInput = {
    validate: RefundLoanTransactionInputValidator as ValidateFunction<RefundLoanTransactionInput>,
    get schema() {
        return RefundLoanTransactionInput.validate.schema
    },
    get errors() {
        return RefundLoanTransactionInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is RefundLoanTransactionInput => RefundLoanTransactionInput.validate(o) === true,
    parse: (o: unknown): { right: RefundLoanTransactionInput } | { left: DefinedError[] } => {
        if (RefundLoanTransactionInput.is(o)) {
            return { right: o }
        }
        return { left: (RefundLoanTransactionInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The information specifying the payment items that are intended to settle
 */
export interface RemittanceInformation {
    structured?: Structured | undefined
    /**
     * Information supplied to match the items of the payment in an unstructured form
     */
    unstructured?: string | undefined
}

/**
 * Represents the account to remove from the credit arrangement.
 */
export interface RemoveCreditArrangementAccountInput {
    /**
     * The encoded key of the account.
     */
    accountId: string
    /**
     * The type of the account.
     */
    accountType: 'LOAN' | 'DEPOSIT'
}

export const RemoveCreditArrangementAccountInput = {
    validate: RemoveCreditArrangementAccountInputValidator as ValidateFunction<RemoveCreditArrangementAccountInput>,
    get schema() {
        return RemoveCreditArrangementAccountInput.validate.schema
    },
    get errors() {
        return RemoveCreditArrangementAccountInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is RemoveCreditArrangementAccountInput => RemoveCreditArrangementAccountInput.validate(o) === true,
    parse: (o: unknown): { right: RemoveCreditArrangementAccountInput } | { left: DefinedError[] } => {
        if (RemoveCreditArrangementAccountInput.is(o)) {
            return { right: o }
        }
        return { left: (RemoveCreditArrangementAccountInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Reopen a deposit account
 */
export interface ReopenDepositAction {
    /**
     * The notes or description attached to this object.
     */
    notes?: string | undefined
}

export const ReopenDepositAction = {
    validate: ReopenDepositActionValidator as ValidateFunction<ReopenDepositAction>,
    get schema() {
        return ReopenDepositAction.validate.schema
    },
    get errors() {
        return ReopenDepositAction.validate.errors ?? undefined
    },
    is: (o: unknown): o is ReopenDepositAction => ReopenDepositAction.validate(o) === true,
    parse: (o: unknown): { right: ReopenDepositAction } | { left: DefinedError[] } => {
        if (ReopenDepositAction.is(o)) {
            return { right: o }
        }
        return { left: (ReopenDepositAction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the request payload for creating a transaction of type REPAYMENT
 */
export interface RepaymentLoanTransactionInput {
    /**
     * The amount of the repayment
     */
    amount: number
    /**
     * The booking date of the repayment (as Organization Time)
     */
    bookingDate?: string | undefined
    /**
     * The list of custom amounts of the repayment
     */
    customPaymentAmounts?: CustomPaymentAmount[] | undefined
    /**
     * The external id of the repayment transaction, customizable, unique
     */
    externalId?: string | undefined
    /**
     * The encoded key of the schedule installment to which this repayment is associated
     */
    installmentEncodedKey?: string | undefined
    /**
     * Extra notes about the repayment transaction. Notes can have at most 255 characters in length.
     */
    notes?: string | undefined
    /**
     * The currency code for the repayment transaction
     */
    originalCurrencyCode?: string | undefined
    /**
     * The prepayment recalculation method of the repayment
     */
    prepaymentRecalculationMethod?:
        | 'NO_RECALCULATION'
        | 'RESCHEDULE_REMAINING_REPAYMENTS'
        | 'RECALCULATE_SCHEDULE_KEEP_SAME_NUMBER_OF_TERMS'
        | 'RECALCULATE_SCHEDULE_KEEP_SAME_PRINCIPAL_AMOUNT'
        | 'RECALCULATE_SCHEDULE_KEEP_SAME_TOTAL_REPAYMENT_AMOUNT'
        | 'REDUCE_AMOUNT_PER_INSTALLMENT'
        | 'REDUCE_NUMBER_OF_INSTALLMENTS'
        | 'REDUCE_NUMBER_OF_INSTALLMENTS_NEW'
        | undefined
    transactionDetails?: LoanTransactionDetailsInput | undefined
    /**
     * The entry date of the repayment (as Organization Time)
     */
    valueDate?: string | undefined
}

export const RepaymentLoanTransactionInput = {
    validate: RepaymentLoanTransactionInputValidator as ValidateFunction<RepaymentLoanTransactionInput>,
    get schema() {
        return RepaymentLoanTransactionInput.validate.schema
    },
    get errors() {
        return RepaymentLoanTransactionInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is RepaymentLoanTransactionInput => RepaymentLoanTransactionInput.validate(o) === true,
    parse: (o: unknown): { right: RepaymentLoanTransactionInput } | { left: DefinedError[] } => {
        if (RepaymentLoanTransactionInput.is(o)) {
            return { right: o }
        }
        return { left: (RepaymentLoanTransactionInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Holds Repayments Schedule Editing options
 */
export interface RepaymentScheduleEditOptionDetails {
    paymentHolidaysSettings?: PaymentHolidaysSettings | undefined
}

type RepaymentScheduleEditOptions =
    | 'ADJUST_PAYMENT_DATES'
    | 'ADJUST_PRINCIPAL_PAYMENT_SCHEDULE'
    | 'ADJUST_INTEREST_PAYMENT_SCHEDULE'
    | 'ADJUST_FEE_PAYMENT_SCHEDULE'
    | 'ADJUST_PENALTY_PAYMENT_SCHEDULE'
    | 'ADJUST_NUMBER_OF_INSTALLMENTS'
    | 'ADJUST_PAYMENT_HOLIDAYS'

/**
 * The disbursement details, allowed on the loan account restructure
 */
export interface RescheduleDisbursementDetails {
    /**
     * The date of the expected first payment
     */
    firstRepaymentDate: string
}

/**
 * The new loan account settings, allowed on the loan account reschedule
 */
export interface RescheduleLoanAccount {
    accountArrearsSettings?: RestructureAccountArrearsSettings | undefined
    disbursementDetails: RescheduleDisbursementDetails
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The guarantees associated with the rescheduled loan account
     */
    guarantors?: Guarantor[] | undefined
    /**
     * Id of the new loan account.
     */
    id?: string | undefined
    /**
     * The interest commission
     */
    interestCommission?: number | undefined
    interestSettings?: RestructureInterestSettings | undefined
    /**
     * The name of the new loan account.
     */
    loanName?: string | undefined
    /**
     * Notes for the rescheduled loan account
     */
    notes?: string | undefined
    penaltySettings?: RestructurePenaltySettings | undefined
    principalPaymentSettings?: RestructurePrincipalPaymentAccountSettings | undefined
    /**
     * The key of the loan product that this account is based on
     */
    productTypeKey: string
    scheduleSettings?: RestructureScheduleSettings | undefined
}

/**
 * The request payload for performing a reschedule loan account action
 */
export interface RescheduleLoanAccountAction {
    /**
     * Choose whether to keep the same account ID as the originating account. If true, the 'id' field in the 'loanAccount' object should not be provided.
     */
    keepSameAccountId?: boolean | undefined
    loanAccount: RescheduleLoanAccount
    writeOffAmounts?: RescheduleWriteOffAmounts | undefined
}

export const RescheduleLoanAccountAction = {
    validate: RescheduleLoanAccountActionValidator as ValidateFunction<RescheduleLoanAccountAction>,
    get schema() {
        return RescheduleLoanAccountAction.validate.schema
    },
    get errors() {
        return RescheduleLoanAccountAction.validate.errors ?? undefined
    },
    is: (o: unknown): o is RescheduleLoanAccountAction => RescheduleLoanAccountAction.validate(o) === true,
    parse: (o: unknown): { right: RescheduleLoanAccountAction } | { left: DefinedError[] } => {
        if (RescheduleLoanAccountAction.is(o)) {
            return { right: o }
        }
        return { left: (RescheduleLoanAccountAction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The write-off amounts, allowed on the loan account reschedule
 */
export interface RescheduleWriteOffAmounts {
    /**
     * Fee write-off amount
     */
    fee?: number | undefined
    /**
     * Interest write-off amount
     */
    interest?: number | undefined
    /**
     * Interest from Arrears write-off amount
     */
    interestFromArrears?: number | undefined
    /**
     * Penalty write-off amount
     */
    penalty?: number | undefined
    /**
     * Principal write-off amount
     */
    principal?: number | undefined
}

export interface RestError {
    errorCode?: number | undefined
    errorReason?: string | undefined
    errorSource?: string | undefined
}

/**
 * The arrears settings, allowed on the loan account restructure
 */
export interface RestructureAccountArrearsSettings {
    /**
     * The arrears tolerance amount
     */
    tolerancePercentageOfOutstandingPrincipal?: number | undefined
    /**
     * The arrears tolerance period value
     */
    tolerancePeriod?: number | undefined
}

/**
 * The interest settings, allowed on the loan account restructure
 */
export interface RestructureInterestSettings {
    /**
     * Adjustable interest rates settings for loan account
     */
    accountInterestRateSettings?: AccountInterestRateSettings[] | undefined
    /**
     * The interest rate for the restructured loan account
     */
    interestRate?: number | undefined
    /**
     * The interest spread for the restructured loan account
     */
    interestSpread?: number | undefined
    pmtAdjustmentThreshold?: PMTAdjustmentThreshold | undefined
}

/**
 * The penalty settings, allowed on the loan account restructure.
 */
export interface RestructurePenaltySettings {
    /**
     * The penalty rate
     */
    penaltyRate?: number | undefined
}

/**
 * The principal payment account settings, allowed on the loan account restructure
 */
export interface RestructurePrincipalPaymentAccountSettings {
    /**
     * Fixed principal payment amount
     */
    amount?: number | undefined
    /**
     * Principal payment percentage
     */
    percentage?: number | undefined
}

/**
 * The schedule settings, allowed on the loan account restructure
 */
export interface RestructureScheduleSettings {
    /**
     * The PMT is calculated as the loan would have [amortizationPeriod] installments.
     */
    amortizationPeriod?: number | undefined
    billingCycleDays?: BillingCycleDays | undefined
    /**
     * The days of the month, when the repayment due dates should be
     */
    fixedDaysOfMonth?: number[] | undefined
    /**
     * The grace period
     */
    gracePeriod?: number | undefined
    /**
     * A list of periodic payments for the current loan account.
     */
    paymentPlan?: PeriodicPayment[] | undefined
    /**
     * The periodic payment
     */
    periodicPayment?: number | undefined
    previewSchedule?: RevolvingAccountSettings | undefined
    /**
     * The number of installments
     */
    repaymentInstallments?: number | undefined
    /**
     * The payments frequency per set period of time
     */
    repaymentPeriodCount?: number | undefined
    /**
     * The period of time, within which the payments frequency is set
     */
    repaymentPeriodUnit?: 'DAYS' | 'WEEKS' | 'MONTHS' | 'YEARS' | undefined
}

/**
 * The number of previewed instalments for an account
 */
export interface RevolvingAccountSettings {
    /**
     * The number of previewed instalments
     */
    numberOfPreviewedInstalments?: number | undefined
}

/**
 * Represents a user role.
 */
export interface Role {
    access?: BaseUserAccess | undefined
    /**
     * The date when the role was created in UTC.
     */
    creationDate?: string | undefined
    /**
     * The encoded key of the entity, generated automatically, globally unique.
     */
    encodedKey?: string | undefined
    /**
     * The ID of the role, which can be generated and customized, but must be unique.
     */
    id?: string | undefined
    /**
     * The last time the role was modified in UTC.
     */
    lastModifiedDate?: string | undefined
    /**
     * The unique name of the role.
     */
    name: string
    /**
     * The notes about the role.
     */
    notes?: string | undefined
}

export const Role = {
    validate: RoleValidator as ValidateFunction<Role>,
    get schema() {
        return Role.validate.schema
    },
    get errors() {
        return Role.validate.errors ?? undefined
    },
    is: (o: unknown): o is Role => Role.validate(o) === true,
    parse: (o: unknown): { right: Role } | { left: DefinedError[] } => {
        if (Role.is(o)) {
            return { right: o }
        }
        return { left: (Role.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the role identifier.
 */
export interface RoleIdentifier {
    /**
     * The encoded key of the entity, generated automatically, globally unique.
     */
    encodedKey?: string | undefined
    /**
     * The ID of the role, which can be generated and customized, but must be unique.
     */
    id?: string | undefined
}

/**
 * Defines the rounding settings used in the loan computation.
 */
export interface RoundingSettings {
    /**
     * Specifies the repayment currency rounding method.
     */
    repaymentCurrencyRounding: 'NO_ROUNDING' | 'ROUND_TO_NEAREST_WHOLE_UNIT' | 'ROUND_UP_TO_NEAREST_WHOLE_UNIT'
    /**
     * Determines how the repayment currency rounding is handled on each element from the schedule.
     */
    repaymentElementsRoundingMethod: 'NO_ROUNDING' | 'ROUND_ALL' | 'PAYMENT_DUE'
    /**
     * Specifies the rounding repayment schedule method.
     */
    roundingRepaymentScheduleMethod:
        | 'NO_ROUNDING'
        | 'ROUND_REMAINDER_INTO_LAST_REPAYMENT'
        | 'ROUND_PRINCIPAL_AND_INTEREST_REMAINDER_INTO_LAST_REPAYMENT'
}

/**
 * The schedule settings, holds all schedule properties.
 */
export interface ScheduleSettings {
    /**
     * The PMT is calculated as the loan would have [amortizationPeriod] installments.
     */
    amortizationPeriod?: number | undefined
    billingCycle?: BillingCycleDays | undefined
    /**
     * The default first repayment due date offset, indicates how many days the first repayment due date should be extended(all other due dates from the schedule are relative to first repayment due date - they will also be affected by the offset)
     */
    defaultFirstRepaymentDueDateOffset?: number | undefined
    /**
     * Specifies the days of the month when the repayment due dates should be. Only available if the Repayment Methodology is FIXED_DAYS_OF_MONTH.
     */
    fixedDaysOfMonth?: number[] | undefined
    /**
     * The grace period. Represents the grace period for loan repayment - in number of installments.
     */
    gracePeriod: number
    /**
     * The grace period type. Representing the type of grace period which is possible for a loan account.
     */
    gracePeriodType?: 'NONE' | 'PAY_INTEREST_ONLY' | 'INTEREST_FORGIVENESS' | undefined
    /**
     * Flag used when the repayments schedule for the current account was determined by the user, by editing the due dates or the principal due
     */
    hasCustomSchedule?: boolean | undefined
    /**
     * A list of periodic payments for the current loan account.
     */
    paymentPlan?: PeriodicPayment[] | undefined
    /**
     * The periodic payment amount for the accounts which have balloon payments or Reduce Number of Installments and Optimized Payments
     */
    periodicPayment?: number | undefined
    previewSchedule?: RevolvingAccountSettings | undefined
    /**
     * The principal repayment interval. Indicates the interval of repayments that the principal has to be paid.
     */
    principalRepaymentInterval?: number | undefined
    /**
     * The repayment installments. Represents how many installments are required to pay back the loan.
     */
    repaymentInstallments?: number | undefined
    /**
     * The repayment period count. Represents how often the loan is to be repaid: stored based on the type repayment option.
     */
    repaymentPeriodCount?: number | undefined
    /**
     * The repayment period unit. Represents the frequency of loan repayment.
     */
    repaymentPeriodUnit?: 'DAYS' | 'WEEKS' | 'MONTHS' | 'YEARS' | undefined
    /**
     * The repayment schedule method. Represents the method that determines whether the schedule will be fixed all over the loan account's life cycle or will be dynamically recomputed when required.
     */
    repaymentScheduleMethod?: 'NONE' | 'FIXED' | 'DYNAMIC' | undefined
    /**
     * The schedule due dates method. Represents the methodology used by this account to compute the due dates of the repayments.
     */
    scheduleDueDatesMethod?: 'INTERVAL' | 'FIXED_DAYS_OF_MONTH' | undefined
    /**
     * The short handling method. Determines how to handle the short months, if they select a fixed day of month > 28. Will be null if no such date is selected and also for the Interval methodology. Only available if the Repayment Methodology is FIXED_DAYS_OF_MONTH.
     */
    shortMonthHandlingMethod?: 'LAST_DAY_IN_MONTH' | 'FIRST_DAY_OF_NEXT_MONTH' | undefined
}

/**
 * The schedule settings, holds all schedule properties needed for schedule preview request.
 */
export interface ScheduleSettingsForSchedulePreview {
    /**
     * The PMT is calculated as the loan would have [amortizationPeriod] installments.
     */
    amortizationPeriod?: number | undefined
    /**
     * Specifies the days of the month when the repayment due dates should be. Only available if the Repayment Methodology is FIXED_DAYS_OF_MONTH.
     */
    fixedDaysOfMonth?: number[] | undefined
    /**
     * The grace period. Represents the grace period for loan repayment - in number of installments.
     */
    gracePeriod?: number | undefined
    /**
     * A list of periodic payments for the current loan account.
     */
    paymentPlan?: PeriodicPaymentForSchedulePreview[] | undefined
    /**
     * The periodic payment amount for the accounts which have balloon payments or Reduce Number of Installments and Optimized Payments
     */
    periodicPayment?: number | undefined
    /**
     * The principal repayment interval. Indicates the interval of repayments that the principal has to be paid.
     */
    principalRepaymentInterval?: number | undefined
    /**
     * The repayment installments. Represents how many installments are required to pay back the loan.
     */
    repaymentInstallments?: number | undefined
    /**
     * The repayment period count. Represents how often the loan is to be repaid: stored based on the type repayment option.
     */
    repaymentPeriodCount?: number | undefined
    /**
     * The repayment period unit. Represents the frequency of loan repayment.
     */
    repaymentPeriodUnit?: 'DAYS' | 'WEEKS' | 'MONTHS' | 'YEARS' | undefined
}

export type Search10Response = LoanAccount[]

export const Search10Response = {
    validate: Search10ResponseValidator as ValidateFunction<Search10Response>,
    get schema() {
        return Search10Response.validate.schema
    },
    get errors() {
        return Search10Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is Search10Response => Search10Response.validate(o) === true,
    parse: (o: unknown): { right: Search10Response } | { left: DefinedError[] } => {
        if (Search10Response.is(o)) {
            return { right: o }
        }
        return { left: (Search10Response.errors ?? []) as DefinedError[] }
    },
} as const

export type Search11Response = LoanTransaction[]

export const Search11Response = {
    validate: Search11ResponseValidator as ValidateFunction<Search11Response>,
    get schema() {
        return Search11Response.validate.schema
    },
    get errors() {
        return Search11Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is Search11Response => Search11Response.validate(o) === true,
    parse: (o: unknown): { right: Search11Response } | { left: DefinedError[] } => {
        if (Search11Response.is(o)) {
            return { right: o }
        }
        return { left: (Search11Response.errors ?? []) as DefinedError[] }
    },
} as const

export type Search1Response = Client[]

export const Search1Response = {
    validate: Search1ResponseValidator as ValidateFunction<Search1Response>,
    get schema() {
        return Search1Response.validate.schema
    },
    get errors() {
        return Search1Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is Search1Response => Search1Response.validate(o) === true,
    parse: (o: unknown): { right: Search1Response } | { left: DefinedError[] } => {
        if (Search1Response.is(o)) {
            return { right: o }
        }
        return { left: (Search1Response.errors ?? []) as DefinedError[] }
    },
} as const

export type Search2Request = CommunicationMessageFilterCriteria[]

export const Search2Request = {
    validate: Search2RequestValidator as ValidateFunction<Search2Request>,
    get schema() {
        return Search2Request.validate.schema
    },
    get errors() {
        return Search2Request.validate.errors ?? undefined
    },
    is: (o: unknown): o is Search2Request => Search2Request.validate(o) === true,
    parse: (o: unknown): { right: Search2Request } | { left: DefinedError[] } => {
        if (Search2Request.is(o)) {
            return { right: o }
        }
        return { left: (Search2Request.errors ?? []) as DefinedError[] }
    },
} as const

export type Search2Response = CommunicationMessage[]

export const Search2Response = {
    validate: Search2ResponseValidator as ValidateFunction<Search2Response>,
    get schema() {
        return Search2Response.validate.schema
    },
    get errors() {
        return Search2Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is Search2Response => Search2Response.validate(o) === true,
    parse: (o: unknown): { right: Search2Response } | { left: DefinedError[] } => {
        if (Search2Response.is(o)) {
            return { right: o }
        }
        return { left: (Search2Response.errors ?? []) as DefinedError[] }
    },
} as const

export type Search3Response = CommunicationMessage[]

export const Search3Response = {
    validate: Search3ResponseValidator as ValidateFunction<Search3Response>,
    get schema() {
        return Search3Response.validate.schema
    },
    get errors() {
        return Search3Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is Search3Response => Search3Response.validate(o) === true,
    parse: (o: unknown): { right: Search3Response } | { left: DefinedError[] } => {
        if (Search3Response.is(o)) {
            return { right: o }
        }
        return { left: (Search3Response.errors ?? []) as DefinedError[] }
    },
} as const

export type Search4Response = CreditArrangement[]

export const Search4Response = {
    validate: Search4ResponseValidator as ValidateFunction<Search4Response>,
    get schema() {
        return Search4Response.validate.schema
    },
    get errors() {
        return Search4Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is Search4Response => Search4Response.validate(o) === true,
    parse: (o: unknown): { right: Search4Response } | { left: DefinedError[] } => {
        if (Search4Response.is(o)) {
            return { right: o }
        }
        return { left: (Search4Response.errors ?? []) as DefinedError[] }
    },
} as const

export type Search5Response = DepositAccount[]

export const Search5Response = {
    validate: Search5ResponseValidator as ValidateFunction<Search5Response>,
    get schema() {
        return Search5Response.validate.schema
    },
    get errors() {
        return Search5Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is Search5Response => Search5Response.validate(o) === true,
    parse: (o: unknown): { right: Search5Response } | { left: DefinedError[] } => {
        if (Search5Response.is(o)) {
            return { right: o }
        }
        return { left: (Search5Response.errors ?? []) as DefinedError[] }
    },
} as const

export type Search6Response = DepositTransaction[]

export const Search6Response = {
    validate: Search6ResponseValidator as ValidateFunction<Search6Response>,
    get schema() {
        return Search6Response.validate.schema
    },
    get errors() {
        return Search6Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is Search6Response => Search6Response.validate(o) === true,
    parse: (o: unknown): { right: Search6Response } | { left: DefinedError[] } => {
        if (Search6Response.is(o)) {
            return { right: o }
        }
        return { left: (Search6Response.errors ?? []) as DefinedError[] }
    },
} as const

export type Search7Response = GLJournalEntry[]

export const Search7Response = {
    validate: Search7ResponseValidator as ValidateFunction<Search7Response>,
    get schema() {
        return Search7Response.validate.schema
    },
    get errors() {
        return Search7Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is Search7Response => Search7Response.validate(o) === true,
    parse: (o: unknown): { right: Search7Response } | { left: DefinedError[] } => {
        if (Search7Response.is(o)) {
            return { right: o }
        }
        return { left: (Search7Response.errors ?? []) as DefinedError[] }
    },
} as const

export type Search8Response = Group[]

export const Search8Response = {
    validate: Search8ResponseValidator as ValidateFunction<Search8Response>,
    get schema() {
        return Search8Response.validate.schema
    },
    get errors() {
        return Search8Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is Search8Response => Search8Response.validate(o) === true,
    parse: (o: unknown): { right: Search8Response } | { left: DefinedError[] } => {
        if (Search8Response.is(o)) {
            return { right: o }
        }
        return { left: (Search8Response.errors ?? []) as DefinedError[] }
    },
} as const

export type Search9Response = InterestAccrualBreakdown[]

export const Search9Response = {
    validate: Search9ResponseValidator as ValidateFunction<Search9Response>,
    get schema() {
        return Search9Response.validate.schema
    },
    get errors() {
        return Search9Response.validate.errors ?? undefined
    },
    is: (o: unknown): o is Search9Response => Search9Response.validate(o) === true,
    parse: (o: unknown): { right: Search9Response } | { left: DefinedError[] } => {
        if (Search9Response.is(o)) {
            return { right: o }
        }
        return { left: (Search9Response.errors ?? []) as DefinedError[] }
    },
} as const

export type SearchResponse = ArchivedDepositTransaction[]

export const SearchResponse = {
    validate: SearchResponseValidator as ValidateFunction<SearchResponse>,
    get schema() {
        return SearchResponse.validate.schema
    },
    get errors() {
        return SearchResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is SearchResponse => SearchResponse.validate(o) === true,
    parse: (o: unknown): { right: SearchResponse } | { left: DefinedError[] } => {
        if (SearchResponse.is(o)) {
            return { right: o }
        }
        return { left: (SearchResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Representation of an API Consumer's Secret Key
 */
export interface SecretKey {
    /**
     * The secret key
     */
    secretKey?: string | undefined
}

export const SecretKey = {
    validate: SecretKeyValidator as ValidateFunction<SecretKey>,
    get schema() {
        return SecretKey.validate.schema
    },
    get errors() {
        return SecretKey.validate.errors ?? undefined
    },
    is: (o: unknown): o is SecretKey => SecretKey.validate(o) === true,
    parse: (o: unknown): { right: SecretKey } | { left: DefinedError[] } => {
        if (SecretKey.is(o)) {
            return { right: o }
        }
        return { left: (SecretKey.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The settings and constraints for securities.
 */
export interface SecuritySettings {
    /**
     * Shows whether collateral (assets or other goods) are accepted in order to reach required securities percentage from loan amount, as defined in this product.
     */
    isCollateralEnabled?: boolean | undefined
    /**
     * Shows whether guarantors (other clients) are accepted in order to reach the required securities percentage from loan amount, as defined in this product.
     */
    isGuarantorsEnabled?: boolean | undefined
    /**
     * The securities percentage from loan amount that is needed in order for this account to be approved. Null if the securities are not required.
     */
    requiredGuaranties?: number | undefined
}

/**
 * Represents the information for seizing a block amount on a deposit account.
 */
export interface SeizeBlockAmount {
    /**
     * The amount of the block fund
     */
    amount?: number | undefined
    /**
     * The id of the block fund
     */
    blockId: string
    /**
     * The external id of the current transaction, customizable, unique
     */
    externalId?: string | undefined
    /**
     * Extra notes about the current transaction
     */
    notes?: string | undefined
    /**
     * The id of the channel through which the transaction is done.
     */
    transactionChannelId: string
}

export const SeizeBlockAmount = {
    validate: SeizeBlockAmountValidator as ValidateFunction<SeizeBlockAmount>,
    get schema() {
        return SeizeBlockAmount.validate.schema
    },
    get errors() {
        return SeizeBlockAmount.validate.errors ?? undefined
    },
    is: (o: unknown): o is SeizeBlockAmount => SeizeBlockAmount.validate(o) === true,
    parse: (o: unknown): { right: SeizeBlockAmount } | { left: DefinedError[] } => {
        if (SeizeBlockAmount.is(o)) {
            return { right: o }
        }
        return { left: (SeizeBlockAmount.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Allows specifying sell function source action details
 */
export interface SellFundingSourceAction {
    /**
     * Funding source purchase list
     */
    purchases?: FundingSourcePurchase[] | undefined
}

export const SellFundingSourceAction = {
    validate: SellFundingSourceActionValidator as ValidateFunction<SellFundingSourceAction>,
    get schema() {
        return SellFundingSourceAction.validate.schema
    },
    get errors() {
        return SellFundingSourceAction.validate.errors ?? undefined
    },
    is: (o: unknown): o is SellFundingSourceAction => SellFundingSourceAction.validate(o) === true,
    parse: (o: unknown): { right: SellFundingSourceAction } | { left: DefinedError[] } => {
        if (SellFundingSourceAction.is(o)) {
            return { right: o }
        }
        return { left: (SellFundingSourceAction.errors ?? []) as DefinedError[] }
    },
} as const

export type SellResponse = DepositTransaction[]

export const SellResponse = {
    validate: SellResponseValidator as ValidateFunction<SellResponse>,
    get schema() {
        return SellResponse.validate.schema
    },
    get errors() {
        return SellResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is SellResponse => SellResponse.validate(o) === true,
    parse: (o: unknown): { right: SellResponse } | { left: DefinedError[] } => {
        if (SellResponse.is(o)) {
            return { right: o }
        }
        return { left: (SellResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The rules under which the transaction should be processed
 */
export interface ServiceLevel {
    /**
     * The code for a pre-agreed service or level of service between the parties
     */
    code?: string | undefined
}

/**
 * The action to start the maturity period for a deposit account
 */
export interface StartMaturityAction {
    /**
     * The date when the maturity period starts.
     */
    maturityDate?: string | undefined
    /**
     * The notes or description attached to this object.
     */
    notes?: string | undefined
}

export const StartMaturityAction = {
    validate: StartMaturityActionValidator as ValidateFunction<StartMaturityAction>,
    get schema() {
        return StartMaturityAction.validate.schema
    },
    get errors() {
        return StartMaturityAction.validate.errors ?? undefined
    },
    is: (o: unknown): o is StartMaturityAction => StartMaturityAction.validate(o) === true,
    parse: (o: unknown): { right: StartMaturityAction } | { left: DefinedError[] } => {
        if (StartMaturityAction.is(o)) {
            return { right: o }
        }
        return { left: (StartMaturityAction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The information specifying the payment items that are intended to settle
 */
export interface Structured {
    creditorReferenceInformation?: CreditorReferenceInformation | undefined
}

/**
 * Represents a human task that can be assigned by one user to another. When a task is created, it's status is set to `OPEN`.
 */
export interface Task {
    /**
     * The key of the user this task is assigned to.
     */
    assignedUserKey?: string | undefined
    /**
     * The name of the user who created the task.
     */
    createdByFullName?: string | undefined
    /**
     * The key of the user that created this task. The value is not editable and it is populated at task creation with the current user key.
     */
    createdByUserKey?: string | undefined
    /**
     * The date when the task was created.
     */
    creationDate?: string | undefined
    /**
     * The description of the task.
     */
    description?: string | undefined
    /**
     * The due date when the task has to be completed.
     */
    dueDate: string
    /**
     * The encoded key of the task, which is auto generated, and must be unique.
     */
    encodedKey?: string | undefined
    /**
     * The ID of the task, which is uniquely generated for the task.
     */
    id?: number | undefined
    /**
     * The last date when the task was modified.
     */
    lastModifiedDate?: string | undefined
    /**
     * The status of this task, a new task always has an `OPEN` status.
     */
    status?: 'OPEN' | 'COMPLETED' | undefined
    /**
     * The individual linked to this task. If null, it means nobody is linked to this task.
     */
    taskLinkKey?: string | undefined
    /**
     * The type of the owner represented by the task link key.
     */
    taskLinkType?:
        | 'CLIENT'
        | 'GROUP'
        | 'LOAN_PRODUCT'
        | 'SAVINGS_PRODUCT'
        | 'CENTRE'
        | 'BRANCH'
        | 'USER'
        | 'LOAN_ACCOUNT'
        | 'DEPOSIT_ACCOUNT'
        | 'ID_DOCUMENT'
        | 'LINE_OF_CREDIT'
        | 'GL_JOURNAL_ENTRY'
        | undefined
    /**
     * The template key used to create the task.
     */
    templateKey?: string | undefined
    /**
     * The title of the task.
     */
    title?: string | undefined
}

export const Task = {
    validate: TaskValidator as ValidateFunction<Task>,
    get schema() {
        return Task.validate.schema
    },
    get errors() {
        return Task.validate.errors ?? undefined
    },
    is: (o: unknown): o is Task => Task.validate(o) === true,
    parse: (o: unknown): { right: Task } | { left: DefinedError[] } => {
        if (Task.is(o)) {
            return { right: o }
        }
        return { left: (Task.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The taxes applied within a transaction.
 */
export interface Taxes {
    /**
     * How much taxes on the interest that was pre-paid were added/removed in account, within this transaction. If there is any deferred tax on interest amount set in this transaction, that amount should be included in this field.
     */
    deferredTaxOnInterestAmount?: number | undefined
    /**
     * How much taxes on the fees that were paid in this transaction were added/removed in account, within this transaction.
     */
    taxOnFeesAmount?: number | undefined
    /**
     * How much taxes on the interest that was paid in this transaction were added/removed in account, within this transaction.
     */
    taxOnInterestAmount?: number | undefined
    /**
     * The amount of taxes on the interest from arrears that were applied/paid in account, within this transaction.
     */
    taxOnInterestFromArrearsAmount?: number | undefined
    /**
     * The amount of taxes on the Payment Holidays interest that were added/removed in account, within this transaction.
     */
    taxOnPaymentHolidaysInterest?: number | undefined
    /**
     * How much taxes on the penalties that were paid in this transaction were added/removed in account, within this transaction.
     */
    taxOnPenaltyAmount?: number | undefined
    /**
     * The tax rate that was set or changed in this transaction.
     */
    taxRate?: number | undefined
}

/**
 * Tax settings, defines some settings for taxes on the loan product
 */
export interface TaxSettings {
    /**
     * Shows whether the tax is added on top of the target amount or not.
     */
    taxCalculationMethod?: 'INCLUSIVE' | 'EXCLUSIVE' | undefined
    /**
     * Shows whether taxes on fees are enabled for this product or not.
     */
    taxesOnFeesEnabled?: boolean | undefined
    /**
     * Shows whether taxes on interest are enabled for this product or not.
     */
    taxesOnInterestEnabled?: boolean | undefined
    /**
     * Shows whether taxes on penalties are enabled for this product or not.
     */
    taxesOnPenaltyEnabled?: boolean | undefined
    /**
     * The tax source from where the loan account taxes will be updated.
     */
    taxSourceKey?: string | undefined
}

type TemplateTypes = 'EMAIL' | 'SMS' | 'WEB_HOOK' | 'EVENT_STREAM' | 'TASK'

/**
 * Represents the request payload for the terminate a loan account action
 */
export interface TerminateLoanAccountInput {
    /**
     * The notes for the terminate action performed on the loan account
     */
    notes?: string | undefined
    /**
     * The date when terminate the loan account
     */
    valueDate: string
}

export const TerminateLoanAccountInput = {
    validate: TerminateLoanAccountInputValidator as ValidateFunction<TerminateLoanAccountInput>,
    get schema() {
        return TerminateLoanAccountInput.validate.schema
    },
    get errors() {
        return TerminateLoanAccountInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is TerminateLoanAccountInput => TerminateLoanAccountInput.validate(o) === true,
    parse: (o: unknown): { right: TerminateLoanAccountInput } | { left: DefinedError[] } => {
        if (TerminateLoanAccountInput.is(o)) {
            return { right: o }
        }
        return { left: (TerminateLoanAccountInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The disbursement details regarding a loan tranche.
 */
export interface TrancheDisbursementDetails {
    /**
     * The key of the disbursement transaction logged when this tranche was disbursed. This field will be null until the tranche disbursement
     */
    disbursementTransactionKey?: string | undefined
    /**
     * The date when this tranche is supposed to be disbursed (as Organization Time)
     */
    expectedDisbursementDate?: string | undefined
}

/**
 * The tranche settings, indicates the settings regarding tranches in case the product is configured to support tranches.
 */
export interface TrancheSettings {
    /**
     * The number of tranches supported by the loan product
     */
    maxNumberOfTranches?: number | undefined
}

/**
 * The balances changed within a transaction.
 */
export interface TransactionBalances {
    /**
     * Captures the advance (prepaid) amount.
     */
    advancePosition?: number | undefined
    /**
     * Captures the arrears position amount for the account in arrears.
     */
    arrearsPosition?: number | undefined
    /**
     * The difference between principal balance and redraw balance after each transaction performed on the loan account.
     */
    expectedPrincipalRedraw?: number | undefined
    /**
     * The account redraw balance captured after the transaction update.
     */
    principalBalance?: number | undefined
    /**
     * The account redraw balance captured after the transaction update.
     */
    redrawBalance?: number | undefined
    /**
     * The running balance still owed for the loan.
     */
    totalBalance?: number | undefined
}

/**
 * Represents a transaction channel.
 */
export interface TransactionChannel {
    /**
     * `TRUE` if the transaction channel is available for all users, `FALSE` otherwise.
     */
    availableForAll?: boolean | undefined
    depositConstraints: Constraint
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The general ledger (GL) account associated with the transaction channel.
     */
    glAccount?: string | undefined
    /**
     * The ID of the transaction channel.
     */
    id: string
    /**
     * `TRUE` if the transaction channel is set as the default, `FALSE` otherwise.
     */
    isDefault?: boolean | undefined
    loanConstraints: Constraint
    /**
     * The name of the transaction channel.
     */
    name: string
    /**
     * The state of the transaction channel.
     */
    state?: 'ACTIVE' | 'INACTIVE' | undefined
    /**
     * The usage rights that describe the transaction channel.
     */
    usageRights?: string[] | undefined
}

export const TransactionChannel = {
    validate: TransactionChannelValidator as ValidateFunction<TransactionChannel>,
    get schema() {
        return TransactionChannel.validate.schema
    },
    get errors() {
        return TransactionChannel.validate.errors ?? undefined
    },
    is: (o: unknown): o is TransactionChannel => TransactionChannel.validate(o) === true,
    parse: (o: unknown): { right: TransactionChannel } | { left: DefinedError[] } => {
        if (TransactionChannel.is(o)) {
            return { right: o }
        }
        return { left: (TransactionChannel.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The constraints applied on the transaction channel
 */
export interface TransactionChannelConstraint {
    /**
     * Defines the criteria on which the constraint is applied
     */
    criteria: 'AMOUNT' | 'TYPE' | 'PRODUCT'
    /**
     * Defines the constraint operator. Example: in 'Amount Equals 100' it is the 'Equals'
     */
    operator: 'EQUALS' | 'EMPTY' | 'NOT_EMPTY' | 'MORE_THAN' | 'LESS_THAN' | 'BETWEEN' | 'IN'
    /**
     * The second filtering value of the filter parameter (constraint). It might not exist. Example: it represents '500' from 'Amount Between 100 and 500'
     */
    secondValue?: string | undefined
    /**
     * The first filtering value of the filter constraint. Example: it represents 'Disbursement' from 'Type equals Disbursement' and it also represents 100 from 'Amount Between 100 and 500'
     */
    value?: string | undefined
    /**
     * Filtering values used for the Product and Type criteria, where filtering might be applied on one or more values
     */
    values?: string[] | undefined
}

/**
 * Contains the details about transaction including fields like transaction channel key and channel id
 */
export interface TransactionDetails {
    /**
     * The id of the transaction channel associated with the transaction details.
     */
    transactionChannelId?: string | undefined
    /**
     * The encoded key of the transaction channel associated with the transaction details.
     */
    transactionChannelKey?: string | undefined
}

/**
 * Contains the details about transaction including fields like transaction channel key and channel ID
 */
export interface TransactionDetailsInput {
    /**
     * The id of the transaction channel associated with the transaction details.
     */
    transactionChannelId?: string | undefined
    /**
     * The encoded key of the transaction channel associated with the transaction details.
     */
    transactionChannelKey?: string | undefined
}

/**
 * The interest settings, holds all the properties regarding interests for the loan account.
 */
export interface TransactionInterestSettings {
    /**
     * The value of the index interest rate
     */
    indexInterestRate?: number | undefined
    /**
     * The interest rate. Represents the interest rate for the loan account. The interest on loans is accrued on a daily basis, which allows charging the clients only for the days they actually used the loan amount.
     */
    interestRate?: number | undefined
}

/**
 * Represents the input for a transfer deposit transaction.
 */
export interface TransferDepositTransactionInput {
    /**
     * The amount to transfer from account
     */
    amount: number
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The external id of the transfer transaction, customizable, unique
     */
    externalId?: string | undefined
    /**
     * Extra notes about this deposit transaction
     */
    notes?: string | undefined
    paymentDetails?: PaymentDetails | undefined
    /**
     * The payment order id of the transfer transaction, customizable
     */
    paymentOrderId?: string | undefined
    transferDetails: TransferDetailsInput
    /**
     * The entry date of the transfer. If not specified it is considered the current date (as Organization Time)
     */
    valueDate?: string | undefined
}

export const TransferDepositTransactionInput = {
    validate: TransferDepositTransactionInputValidator as ValidateFunction<TransferDepositTransactionInput>,
    get schema() {
        return TransferDepositTransactionInput.validate.schema
    },
    get errors() {
        return TransferDepositTransactionInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is TransferDepositTransactionInput => TransferDepositTransactionInput.validate(o) === true,
    parse: (o: unknown): { right: TransferDepositTransactionInput } | { left: DefinedError[] } => {
        if (TransferDepositTransactionInput.is(o)) {
            return { right: o }
        }
        return { left: (TransferDepositTransactionInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the transfer details, such as the linked transaction key
 */
export interface TransferDetails {
    /**
     * The key of the related deposit transaction
     */
    linkedDepositTransactionKey?: string | undefined
    /**
     * The key of the related loan transaction
     */
    linkedLoanTransactionKey?: string | undefined
}

/**
 * Represents the input for the transfer details for a transfer transaction
 */
export interface TransferDetailsInput {
    /**
     * The id of the linked account
     */
    linkedAccountId?: string | undefined
    /**
     * The encoded key of the linked account
     */
    linkedAccountKey?: string | undefined
    /**
     * The type of the linked account. Can be LOAN or DEPOSIT
     */
    linkedAccountType: 'LOAN' | 'DEPOSIT'
}

/**
 * Transfer the account ownership from current account holder to a new one (client/group).
 */
export interface TransferOwnershipAction {
    /**
     * The ID or encoded key of the new account holder.
     */
    targetHolderKey: string
}

export const TransferOwnershipAction = {
    validate: TransferOwnershipActionValidator as ValidateFunction<TransferOwnershipAction>,
    get schema() {
        return TransferOwnershipAction.validate.schema
    },
    get errors() {
        return TransferOwnershipAction.validate.errors ?? undefined
    },
    is: (o: unknown): o is TransferOwnershipAction => TransferOwnershipAction.validate(o) === true,
    parse: (o: unknown): { right: TransferOwnershipAction } | { left: DefinedError[] } => {
        if (TransferOwnershipAction.is(o)) {
            return { right: o }
        }
        return { left: (TransferOwnershipAction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents a request for triggering a database backup.
 */
export interface TriggerDatabaseBackupRequest {
    /**
     * If provided, it needs to be a valid URL. It will be a webhook call that will later execute when the backup is complete.
     */
    callback?: string | undefined
    /**
     * If provided, it needs to be a date time from which the backup should include data. If not provided, the backup will include all the data.
     */
    createBackupFromDate?: string | undefined
    /**
     * If provided, it needs to be a list of tables that exist in the database schema. The backup will only include the specified tables. If not provided, the backup will include all tables.
     */
    tables?: string[] | undefined
}

export const TriggerDatabaseBackupRequest = {
    validate: TriggerDatabaseBackupRequestValidator as ValidateFunction<TriggerDatabaseBackupRequest>,
    get schema() {
        return TriggerDatabaseBackupRequest.validate.schema
    },
    get errors() {
        return TriggerDatabaseBackupRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is TriggerDatabaseBackupRequest => TriggerDatabaseBackupRequest.validate(o) === true,
    parse: (o: unknown): { right: TriggerDatabaseBackupRequest } | { left: DefinedError[] } => {
        if (TriggerDatabaseBackupRequest.is(o)) {
            return { right: o }
        }
        return { left: (TriggerDatabaseBackupRequest.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents a response for triggering a database backup
 */
export interface TriggerDatabaseBackupResponse {
    /**
     * The state of the database backup process
     */
    state?:
        | 'QUEUED'
        | 'IN_PROGRESS'
        | 'COMPLETE'
        | 'NOT_FOUND'
        | 'CANCEL'
        | 'TO_BE_CANCELED'
        | 'TIMED_OUT'
        | 'ERROR'
        | 'TRANSIENT_ERROR'
        | 'OVERRIDDEN'
        | 'RECOVERABLE_ERROR'
        | undefined
}

export const TriggerDatabaseBackupResponse = {
    validate: TriggerDatabaseBackupResponseValidator as ValidateFunction<TriggerDatabaseBackupResponse>,
    get schema() {
        return TriggerDatabaseBackupResponse.validate.schema
    },
    get errors() {
        return TriggerDatabaseBackupResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is TriggerDatabaseBackupResponse => TriggerDatabaseBackupResponse.validate(o) === true,
    parse: (o: unknown): { right: TriggerDatabaseBackupResponse } | { left: DefinedError[] } => {
        if (TriggerDatabaseBackupResponse.is(o)) {
            return { right: o }
        }
        return { left: (TriggerDatabaseBackupResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the response for triggering hourly and end of day processing
 */
export interface TriggerHourlyAndEndOfDayProcessingResponse {
    /**
     * The state of the hourly end of day processing
     */
    state?:
        | 'QUEUED'
        | 'IN_PROGRESS'
        | 'COMPLETE'
        | 'NOT_FOUND'
        | 'CANCEL'
        | 'TO_BE_CANCELED'
        | 'TIMED_OUT'
        | 'ERROR'
        | 'TRANSIENT_ERROR'
        | 'OVERRIDDEN'
        | 'RECOVERABLE_ERROR'
        | undefined
}

export const TriggerHourlyAndEndOfDayProcessingResponse = {
    validate: TriggerHourlyAndEndOfDayProcessingResponseValidator as ValidateFunction<TriggerHourlyAndEndOfDayProcessingResponse>,
    get schema() {
        return TriggerHourlyAndEndOfDayProcessingResponse.validate.schema
    },
    get errors() {
        return TriggerHourlyAndEndOfDayProcessingResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is TriggerHourlyAndEndOfDayProcessingResponse =>
        TriggerHourlyAndEndOfDayProcessingResponse.validate(o) === true,
    parse: (o: unknown): { right: TriggerHourlyAndEndOfDayProcessingResponse } | { left: DefinedError[] } => {
        if (TriggerHourlyAndEndOfDayProcessingResponse.is(o)) {
            return { right: o }
        }
        return { left: (TriggerHourlyAndEndOfDayProcessingResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * The action to undo the maturity period for a deposit account
 */
export interface UndoMaturityAction {
    /**
     * The notes or description attached to this object.
     */
    notes?: string | undefined
}

export const UndoMaturityAction = {
    validate: UndoMaturityActionValidator as ValidateFunction<UndoMaturityAction>,
    get schema() {
        return UndoMaturityAction.validate.schema
    },
    get errors() {
        return UndoMaturityAction.validate.errors ?? undefined
    },
    is: (o: unknown): o is UndoMaturityAction => UndoMaturityAction.validate(o) === true,
    parse: (o: unknown): { right: UndoMaturityAction } | { left: DefinedError[] } => {
        if (UndoMaturityAction.is(o)) {
            return { right: o }
        }
        return { left: (UndoMaturityAction.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the request payload for unlocking an account
 */
export interface UnlockLoanAccountInput {
    /**
     * Extra notes about the current unlocking of account
     */
    notes?: string | undefined
}

export const UnlockLoanAccountInput = {
    validate: UnlockLoanAccountInputValidator as ValidateFunction<UnlockLoanAccountInput>,
    get schema() {
        return UnlockLoanAccountInput.validate.schema
    },
    get errors() {
        return UnlockLoanAccountInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is UnlockLoanAccountInput => UnlockLoanAccountInput.validate(o) === true,
    parse: (o: unknown): { right: UnlockLoanAccountInput } | { left: DefinedError[] } => {
        if (UnlockLoanAccountInput.is(o)) {
            return { right: o }
        }
        return { left: (UnlockLoanAccountInput.errors ?? []) as DefinedError[] }
    },
} as const

export type UpdateLoanAccountFundingSourcesRequest = InvestorFund[]

export const UpdateLoanAccountFundingSourcesRequest = {
    validate: UpdateLoanAccountFundingSourcesRequestValidator as ValidateFunction<UpdateLoanAccountFundingSourcesRequest>,
    get schema() {
        return UpdateLoanAccountFundingSourcesRequest.validate.schema
    },
    get errors() {
        return UpdateLoanAccountFundingSourcesRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is UpdateLoanAccountFundingSourcesRequest => UpdateLoanAccountFundingSourcesRequest.validate(o) === true,
    parse: (o: unknown): { right: UpdateLoanAccountFundingSourcesRequest } | { left: DefinedError[] } => {
        if (UpdateLoanAccountFundingSourcesRequest.is(o)) {
            return { right: o }
        }
        return { left: (UpdateLoanAccountFundingSourcesRequest.errors ?? []) as DefinedError[] }
    },
} as const

export type UpdateLoanAccountFundingSourcesResponse = InvestorFund[]

export const UpdateLoanAccountFundingSourcesResponse = {
    validate: UpdateLoanAccountFundingSourcesResponseValidator as ValidateFunction<UpdateLoanAccountFundingSourcesResponse>,
    get schema() {
        return UpdateLoanAccountFundingSourcesResponse.validate.schema
    },
    get errors() {
        return UpdateLoanAccountFundingSourcesResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is UpdateLoanAccountFundingSourcesResponse =>
        UpdateLoanAccountFundingSourcesResponse.validate(o) === true,
    parse: (o: unknown): { right: UpdateLoanAccountFundingSourcesResponse } | { left: DefinedError[] } => {
        if (UpdateLoanAccountFundingSourcesResponse.is(o)) {
            return { right: o }
        }
        return { left: (UpdateLoanAccountFundingSourcesResponse.errors ?? []) as DefinedError[] }
    },
} as const

export type UpdatePlannedFeesRequest = PlannedInstallmentFee[]

export const UpdatePlannedFeesRequest = {
    validate: UpdatePlannedFeesRequestValidator as ValidateFunction<UpdatePlannedFeesRequest>,
    get schema() {
        return UpdatePlannedFeesRequest.validate.schema
    },
    get errors() {
        return UpdatePlannedFeesRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is UpdatePlannedFeesRequest => UpdatePlannedFeesRequest.validate(o) === true,
    parse: (o: unknown): { right: UpdatePlannedFeesRequest } | { left: DefinedError[] } => {
        if (UpdatePlannedFeesRequest.is(o)) {
            return { right: o }
        }
        return { left: (UpdatePlannedFeesRequest.errors ?? []) as DefinedError[] }
    },
} as const

export type UpdatePlannedFeesResponse = PlannedInstallmentFee[]

export const UpdatePlannedFeesResponse = {
    validate: UpdatePlannedFeesResponseValidator as ValidateFunction<UpdatePlannedFeesResponse>,
    get schema() {
        return UpdatePlannedFeesResponse.validate.schema
    },
    get errors() {
        return UpdatePlannedFeesResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is UpdatePlannedFeesResponse => UpdatePlannedFeesResponse.validate(o) === true,
    parse: (o: unknown): { right: UpdatePlannedFeesResponse } | { left: DefinedError[] } => {
        if (UpdatePlannedFeesResponse.is(o)) {
            return { right: o }
        }
        return { left: (UpdatePlannedFeesResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents a user.
 */
export interface User {
    access: UserAccess
    /**
     * The encoded key of the branch this user is assigned to.
     */
    assignedBranchKey?: string | undefined
    /**
     * The date the user was created in UTC.
     */
    creationDate?: string | undefined
    /**
     * The user email address. Used by Mambu for sending automated notifications or for getting passwords.
     */
    email?: string | undefined
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The first name of the user.
     */
    firstName: string
    /**
     * The user's home phone number, which can also contain characters.
     */
    homePhone?: string | undefined
    /**
     * The ID of the user, which is generated automatically, but must be unique.
     */
    id?: string | undefined
    /**
     * The Mambu display language for the user. The Mambu UI will be displayed in the selected language. Please note: for portuguese, you must use the incorrect spelling `PORTUGESE`.
     */
    language?:
        | 'ENGLISH'
        | 'PORTUGESE'
        | 'SPANISH'
        | 'RUSSIAN'
        | 'FRENCH'
        | 'GEORGIAN'
        | 'CHINESE'
        | 'INDONESIAN'
        | 'ROMANIAN'
        | 'BURMESE'
        | 'GERMAN'
        | 'PORTUGUESE_BRAZIL'
        | 'VIETNAMESE'
        | 'ITALIAN'
        | 'THAI'
        | 'NORWEGIAN'
        | 'PHRASE'
        | undefined
    /**
     * The last time the user logged in in UTC.
     */
    lastLoggedInDate?: string | undefined
    /**
     * The last time the user was modified in UTC.
     */
    lastModifiedDate?: string | undefined
    /**
     * The last name of the user.
     */
    lastName?: string | undefined
    /**
     * The user's mobile phone number, which can also contain characters.
     */
    mobilePhone?: string | undefined
    /**
     * The additional information for the user.
     */
    notes?: string | undefined
    role?: RoleIdentifier | undefined
    /**
     * The user title.
     */
    title?: string | undefined
    /**
     * The user transaction limits.
     */
    transactionLimits?:
        | {
              [k: string]: number | undefined
          }
        | undefined
    /**
     * `TRUE` if the user has two-factor authentication setup, `FALSE` otherwise. If two-factor authentication is enabled, a user will be sent an SMS to their registered mobile number, which they will need to enter in the Mambu login screen, in addition to their password.
     */
    twoFactorAuthentication?: boolean | undefined
    /**
     * The Mambu login user name.
     */
    username: string
    /**
     * The current state of the user.
     */
    userState?: 'ACTIVE' | 'INACTIVE' | 'LOCKED' | undefined
}

export const User = {
    validate: UserValidator as ValidateFunction<User>,
    get schema() {
        return User.validate.schema
    },
    get errors() {
        return User.validate.errors ?? undefined
    },
    is: (o: unknown): o is User => User.validate(o) === true,
    parse: (o: unknown): { right: User } | { left: DefinedError[] } => {
        if (User.is(o)) {
            return { right: o }
        }
        return { left: (User.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Allows the creation of a user
 */
export interface UserRequest {
    access: UserAccess
    /**
     * The encoded key of the branch this user is assigned to.
     */
    assignedBranchKey?: string | undefined
    /**
     * The user email address. Used by Mambu for sending automated notifications or for getting passwords.
     */
    email?: string | undefined
    /**
     * The encoded key of the entity, generated, globally unique
     */
    encodedKey?: string | undefined
    /**
     * The first name of the user.
     */
    firstName: string
    /**
     * The user's home phone number, which can also contain characters.
     */
    homePhone?: string | undefined
    /**
     * The Mambu display language for the user. The Mambu UI will be displayed in the selected language. Please note: for portuguese, you must use the incorrect spelling `PORTUGESE`.
     */
    language?:
        | 'ENGLISH'
        | 'PORTUGESE'
        | 'SPANISH'
        | 'RUSSIAN'
        | 'FRENCH'
        | 'GEORGIAN'
        | 'CHINESE'
        | 'INDONESIAN'
        | 'ROMANIAN'
        | 'BURMESE'
        | 'GERMAN'
        | 'PORTUGUESE_BRAZIL'
        | 'VIETNAMESE'
        | 'ITALIAN'
        | 'THAI'
        | 'NORWEGIAN'
        | 'PHRASE'
        | undefined
    /**
     * The last name of the user.
     */
    lastName?: string | undefined
    /**
     * The user's mobile phone number, which can also contain characters.
     */
    mobilePhone?: string | undefined
    /**
     * The additional information for the user.
     */
    notes?: string | undefined
    /**
     * Password used by the user
     */
    password: string
    role?: RoleIdentifier | undefined
    /**
     * The user title.
     */
    title?: string | undefined
    /**
     * The user transaction limits.
     */
    transactionLimits?:
        | {
              [k: string]: number | undefined
          }
        | undefined
    /**
     * `TRUE` if the user has two-factor authentication setup, `FALSE` otherwise. If two-factor authentication is enabled, a user will be sent an SMS to their registered mobile number, which they will need to enter in the Mambu login screen, in addition to their password.
     */
    twoFactorAuthentication?: boolean | undefined
    /**
     * The Mambu login user name.
     */
    username: string
}

export const UserRequest = {
    validate: UserRequestValidator as ValidateFunction<UserRequest>,
    get schema() {
        return UserRequest.validate.schema
    },
    get errors() {
        return UserRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is UserRequest => UserRequest.validate(o) === true,
    parse: (o: unknown): { right: UserRequest } | { left: DefinedError[] } => {
        if (UserRequest.is(o)) {
            return { right: o }
        }
        return { left: (UserRequest.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the user permissions and access rights.
 */
export interface UserAccess {
    /**
     * `TRUE` if the user has the administrator user type, `FALSE` otherwise. Administrators (admins) have all permissions and can perform any action in Mambu.
     */
    administratorAccess?: boolean | undefined
    /**
     * `TRUE` if the user can authenticate and interact with Mambu APIs, `FALSE` otherwise. The user may still require additional permissions for specific API requests.
     */
    apiAccess?: boolean | undefined
    /**
     * `TRUE` if the user has access to all branches, `FALSE` if the user only has access to specific branches.
     */
    canManageAllBranches: boolean
    /**
     * `TRUE` if a credit officer user can access entities (for example, clients or accounts) assigned to other credit officers, `FALSE` otherwise.
     */
    canManageEntitiesAssignedToOtherOfficers: boolean
    /**
     * `TRUE` if the user has the credit officer user type, `FALSE` otherwise. Credit officers have the option of having clients and groups assigned to them.
     */
    creditOfficerAccess?: boolean | undefined
    /**
     * `TRUE` if the user is part of the Mambu delivery team, `FALSE` otherwise.
     */
    deliveryAccess?: boolean | undefined
    /**
     * TRUE` if the user can log in to the Mambu UI using their login credentials, `FALSE` otherwise.
     */
    mambuAccess?: boolean | undefined
    /**
     * The list of branches that can be managed by the user. If the user has the `canManageAllBranches` property set to `TRUE`, this list does not apply.
     */
    managedBranches?: UserManagedBranch[] | undefined
    /**
     * Permissions for the user. The non-admin users are authorized to do actions based a set of permissions in order to access Mambu features. Permissions may be relevant for the API and/or the Mambu UI.
     */
    permissions?: Permissions2[] | undefined
    /**
     * `TRUE` if the user can provide Mambu technical support, `FALSE` otherwise.
     */
    supportAccess?: boolean | undefined
    /**
     * `TRUE` if the user has the teller user type, `FALSE` otherwise. Tellers have access to the teller module and specific tellering permissions, which allow them to take actions such as opening or closing tills, posting transactions on a till, and adding and removing cash from a till.
     */
    tellerAccess?: boolean | undefined
}

/**
 * Represents a branch that can be managed by the user or API consumer.
 */
export interface UserManagedBranch {
    /**
     * The encoded key of the branch, it is automatically generated.
     */
    branchKey?: string | undefined
}

/**
 * Represents the input for a withdrawal transaction.
 */
export interface WithdrawalDepositTransactionInput {
    /**
     * The amount to withdraw from account
     */
    amount: number
    /**
     * The date of the withdrawal when the transaction is logged into accounting. If not specified it is considered the value date
     */
    bookingDate?: string | undefined
    /**
     * The external id of the withdrawal transaction, customizable, unique
     */
    externalId?: string | undefined
    /**
     * The external id of an account authorization hold
     */
    holdExternalReferenceId?: string | undefined
    /**
     * Extra notes about this deposit transaction
     */
    notes?: string | undefined
    paymentDetails?: PaymentDetails | undefined
    /**
     * The payment order id of the withdrawal transaction, customizable
     */
    paymentOrderId?: string | undefined
    transactionDetails?: TransactionDetailsInput | undefined
    /**
     * The entry date of the withdrawal. If not specified it is considered the current date (as Organization Time)
     */
    valueDate?: string | undefined
}

export const WithdrawalDepositTransactionInput = {
    validate: WithdrawalDepositTransactionInputValidator as ValidateFunction<WithdrawalDepositTransactionInput>,
    get schema() {
        return WithdrawalDepositTransactionInput.validate.schema
    },
    get errors() {
        return WithdrawalDepositTransactionInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is WithdrawalDepositTransactionInput => WithdrawalDepositTransactionInput.validate(o) === true,
    parse: (o: unknown): { right: WithdrawalDepositTransactionInput } | { left: DefinedError[] } => {
        if (WithdrawalDepositTransactionInput.is(o)) {
            return { right: o }
        }
        return { left: (WithdrawalDepositTransactionInput.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * Represents the request payload for creating a transaction of type WITHDRAWAL_REDRAW
 */
export interface WithdrawalRedrawTransactionInput {
    /**
     * The amount to be withdrawn from redraw balance
     */
    amount: number
    /**
     * The booking date of the withdrawal transaction (as Organization Time)
     */
    bookingDate?: string | undefined
    /**
     * The external id of the withdrawal transaction, customizable, unique
     */
    externalId?: string | undefined
    /**
     * Extra notes about the withdrawal transaction. Notes can have at most 255 characters in length.
     */
    notes?: string | undefined
    /**
     * The currency code for the transaction
     */
    originalCurrencyCode?: string | undefined
    transactionDetails?: LoanTransactionDetailsInput | undefined
    /**
     * The value date of the withdrawal transaction (as Organization Time)
     */
    valueDate?: string | undefined
}

export const WithdrawalRedrawTransactionInput = {
    validate: WithdrawalRedrawTransactionInputValidator as ValidateFunction<WithdrawalRedrawTransactionInput>,
    get schema() {
        return WithdrawalRedrawTransactionInput.validate.schema
    },
    get errors() {
        return WithdrawalRedrawTransactionInput.validate.errors ?? undefined
    },
    is: (o: unknown): o is WithdrawalRedrawTransactionInput => WithdrawalRedrawTransactionInput.validate(o) === true,
    parse: (o: unknown): { right: WithdrawalRedrawTransactionInput } | { left: DefinedError[] } => {
        if (WithdrawalRedrawTransactionInput.is(o)) {
            return { right: o }
        }
        return { left: (WithdrawalRedrawTransactionInput.errors ?? []) as DefinedError[] }
    },
} as const
