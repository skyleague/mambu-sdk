/**
 * Generated by @skyleague/therefore
 * Do not manually touch this
 */
/* eslint-disable */

import { z } from 'zod'

export const Document = z
    .object({
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The creation date of the document, stored as UTC')
            .optional(),
        encodedKey: z.string().describe('The document encodedKey').optional(),
        fileName: z.string().describe('The original file name of the document').optional(),
        fileSize: z.number().int().describe('The file size of the document').optional(),
        id: z.number().int().describe('The document id'),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last modified date of the document, stored as UTC')
            .optional(),
        location: z.string().describe('Location where the document can be found, eg /myfiles/mypicture.jpeg').optional(),
        name: z.string().describe('The name of the document'),
        notes: z.string().describe('Detailed notes about the document').optional(),
        ownerKey: z
            .string()
            .describe('Represents the holder of this document. If null, means nobody is the owner of this document')
            .optional(),
        ownerType: z
            .enum([
                'CLIENT',
                'GROUP',
                'LOAN_PRODUCT',
                'SAVINGS_PRODUCT',
                'CENTRE',
                'BRANCH',
                'USER',
                'LOAN_ACCOUNT',
                'DEPOSIT_ACCOUNT',
                'ID_DOCUMENT',
                'LINE_OF_CREDIT',
                'GL_JOURNAL_ENTRY',
            ])
            .describe('Determines the owner type of the document')
            .optional(),
        type: z.string().describe('The extension of the document'),
    })
    .describe('Holds information regarding the documents uploaded as attachments')

export type Document = z.infer<typeof Document>

export const PortalSettings = z
    .object({
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        lastLoggedInDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last date the client logged in to the portal.')
            .optional(),
        portalState: z.enum(['ENABLED', 'DISABLED']).describe(`The state of the client's portal preferences.`).optional(),
    })
    .describe('Represents portal settings for an individual client.')

export type PortalSettings = z.infer<typeof PortalSettings>

export const IdentificationDocument = z
    .object({
        attachments: Document.array()
            .describe('A list containing information about the attached files for this document')
            .optional(),
        clientKey: z.string().describe('The encoded key of the client that owns this document').optional(),
        documentId: z.string().describe('The id of the document'),
        documentType: z.string().describe('The type of the document, Passport, Id card Drivers license, etc.'),
        encodedKey: z.string().describe('The encoded key of the document, generated, unique').optional(),
        identificationDocumentTemplateKey: z.string().describe('Encoded key of the template used for this document').optional(),
        indexInList: z.number().int().describe(`This document's index in the list of documents`).optional(),
        issuingAuthority: z.string().describe('Authority that issued the document, eg. Police').optional(),
        validUntil: z.string().date().describe('Date when the validity of the document ends').optional(),
    })
    .describe(
        'An Id document represents a document that can be used to identify a person like a passport, a drivers license an id card etc.',
    )

export type IdentificationDocument = z.infer<typeof IdentificationDocument>

export const Address = z
    .object({
        city: z.string().describe('The city for the address.').optional(),
        country: z.string().describe('The country.').optional(),
        encodedKey: z.string().describe('The address encoded key, which is unique and generated.').optional(),
        indexInList: z.number().int().describe('The index of this address in the list of addresses.').optional(),
        latitude: z
            .number()
            .describe(
                'The GPS latitude of this address in signed degrees format (DDD.dddd) with 6 decimal positions, ranging from -90 to +90.',
            )
            .optional(),
        line1: z.string().describe('The first line of the address.').optional(),
        line2: z.string().describe('The second line of the address.').optional(),
        longitude: z
            .number()
            .describe(
                'The GPS longitude of this address in signed degrees format (DDD.dddd) with 6 decimal positions, ranging from -180 to +180.',
            )
            .optional(),
        parentKey: z
            .string()
            .describe('The address parent key indicating the object owning this address. For example: client, centre, or branch.')
            .optional(),
        postcode: z.string().describe('The post code.').optional(),
        region: z.string().describe('The region for the address.').optional(),
    })
    .describe('Represents an address.')

export type Address = z.infer<typeof Address>

export const Currency = z
    .object({
        code: z
            .enum([
                'AED',
                'AFN',
                'ALL',
                'AMD',
                'ANG',
                'AOA',
                'ARS',
                'AUD',
                'AWG',
                'AZN',
                'BAM',
                'BBD',
                'BDT',
                'BGN',
                'BHD',
                'BIF',
                'BMD',
                'BND',
                'BOB',
                'BOV',
                'BRL',
                'BSD',
                'BTN',
                'BWP',
                'BYR',
                'BYN',
                'BZD',
                'CAD',
                'CDF',
                'CHE',
                'CHF',
                'CHW',
                'CLF',
                'CLP',
                'CNY',
                'COP',
                'COU',
                'CRC',
                'CUC',
                'CUP',
                'CVE',
                'CZK',
                'DJF',
                'DKK',
                'DOP',
                'DZD',
                'EGP',
                'ERN',
                'ETB',
                'EUR',
                'FJD',
                'FKP',
                'GBP',
                'GEL',
                'GHS',
                'GIP',
                'GMD',
                'GNF',
                'GTQ',
                'GYD',
                'HKD',
                'HNL',
                'HRK',
                'HTG',
                'HUF',
                'IDR',
                'ILS',
                'INR',
                'IQD',
                'IRR',
                'ISK',
                'JMD',
                'JOD',
                'JPY',
                'KES',
                'KGS',
                'KHR',
                'KMF',
                'KPW',
                'KRW',
                'KWD',
                'KYD',
                'KZT',
                'LAK',
                'LBP',
                'LKR',
                'LRD',
                'LSL',
                'LTL',
                'LVL',
                'LYD',
                'MAD',
                'MDL',
                'MGA',
                'MKD',
                'MMK',
                'MNT',
                'MOP',
                'MRO',
                'MRU',
                'MUR',
                'MVR',
                'MWK',
                'MXN',
                'MXV',
                'MYR',
                'MZN',
                'NAD',
                'NGN',
                'NIO',
                'NOK',
                'NPR',
                'NZD',
                'OMR',
                'PAB',
                'PEN',
                'PGK',
                'PHP',
                'PKR',
                'PLN',
                'PYG',
                'QAR',
                'RON',
                'RSD',
                'RUB',
                'RWF',
                'SAR',
                'SBD',
                'SCR',
                'SDG',
                'SEK',
                'SGD',
                'SHP',
                'SLL',
                'SOS',
                'SRD',
                'STD',
                'STN',
                'SVC',
                'SYP',
                'SZL',
                'THB',
                'TJS',
                'TMT',
                'TND',
                'TOP',
                'TRY',
                'TTD',
                'TWD',
                'TZS',
                'UAH',
                'UGX',
                'USD',
                'USN',
                'UYI',
                'UYU',
                'UYW',
                'UZS',
                'VED',
                'VEF',
                'VES',
                'VND',
                'VUV',
                'WST',
                'XAG',
                'XAU',
                'XAF',
                'XBA',
                'XBB',
                'XBC',
                'XBD',
                'XCD',
                'XDR',
                'XOF',
                'XPD',
                'XPF',
                'XPT',
                'XSU',
                'XTS',
                'XUA',
                'XXX',
                'YER',
                'ZAR',
                'ZIG',
                'ZMK',
                'ZWL',
                'ZMW',
                'SSP',
                'NON_FIAT',
            ])
            .describe('Fiat(ISO-4217) currency code or NON_FIAT for non fiat currencies.')
            .optional(),
        currencyCode: z.string().describe('Currency code for NON_FIAT currency.').optional(),
    })
    .describe('Represents a currency eg. USD, EUR.')

export type Currency = z.infer<typeof Currency>

export const ClientSortingCriteria = z
    .object({
        field: z
            .enum([
                'encodedKey',
                'id',
                'fullName',
                'firstName',
                'middleName',
                'lastName',
                'creationDate',
                'lastModifiedDate',
                'depositsBalance',
                'loansBalance',
                'pendingLoanAmount',
                'approvedLoanAmount',
                'totalBalance',
                'totalDue',
                'homePhoneNumber',
                'mobilePhoneNumber',
                'mobilePhoneNumber2',
                'emailAddress',
                'birthdate',
                'loanCycle',
                'groupLoanCycle',
                'portalState',
            ])
            .describe(
                'The field to sort by. It can be native (one from the provided list) or otherwise can specify a custom field definition using the format [customFieldSetId].[customFieldId].',
            ),
        order: z.enum(['ASC', 'DESC']).describe('The sorting order: `ASC` or `DESC`. The default order is `DESC`.').optional(),
    })
    .describe('The sorting criteria used for Clients')

export type ClientSortingCriteria = z.infer<typeof ClientSortingCriteria>

export const ClientFilterCriteria = z
    .object({
        field: z.union([
            z
                .enum([
                    'encodedKey',
                    'creditOfficerKey',
                    'clientRoleKey',
                    'branchKey',
                    'centreKey',
                    'groupKey',
                    'fullName',
                    'firstName',
                    'middleName',
                    'lastName',
                    'creationDate',
                    'lastModifiedDate',
                    'id',
                    'depositsBalance',
                    'loansBalance',
                    'pendingLoanAmount',
                    'approvedLoanAmount',
                    'totalBalance',
                    'totalDue',
                    'homePhoneNumber',
                    'mobilePhoneNumber',
                    'mobilePhoneNumber2',
                    'emailAddress',
                    'clientAddress',
                    'birthdate',
                    'gender',
                    'loanCycle',
                    'groupLoanCycle',
                    'clientState',
                    'portalState',
                    'preferredLanguage',
                    'groupId',
                ])
                .describe(
                    'The fields to perform the search. They can be native (one from the provided list) or otherwise can specify a custom field definition using the format [customFieldSetId].[customFieldId].\\n',
                ),
            z.string(),
        ]),
        operator: z
            .enum([
                'EQUALS',
                'EQUALS_CASE_SENSITIVE',
                'DIFFERENT_THAN',
                'MORE_THAN',
                'LESS_THAN',
                'BETWEEN',
                'ON',
                'AFTER',
                'AFTER_INCLUSIVE',
                'BEFORE',
                'BEFORE_INCLUSIVE',
                'STARTS_WITH',
                'STARTS_WITH_CASE_SENSITIVE',
                'IN',
                'TODAY',
                'THIS_WEEK',
                'THIS_MONTH',
                'THIS_YEAR',
                'LAST_DAYS',
                'EMPTY',
                'NOT_EMPTY',
            ])
            .describe(
                '| **Operator**                | **Affected values**  | **Available for**                                                    |\\n|---------------               |----------------------|----------------------------------------------------------------------|\\n| EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |\\n| EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |\\n| MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |\\n| ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| STARTS_WITH                  | ONE_VALUE            | STRING                                                               |\\n| STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |\\n| IN                           | LIST                 | ENUM,KEY                                                             |\\n| TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |\\n| EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |\\n| NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |',
            ),
        secondValue: z
            .string()
            .describe('The second value to match the searching criteria, when the `BETWEEN` operator is used.')
            .optional(),
        value: z.string().describe('The value to match the searching criteria.').optional(),
        values: z.string().array().describe('List of values when the `IN` operator is used.').optional(),
    })
    .describe('The unit that composes the list used for Clients searching')

export type ClientFilterCriteria = z.infer<typeof ClientFilterCriteria>

export const RestError = z.object({
    errorCode: z.number().int().optional(),
    errorReason: z.string().optional(),
    errorSource: z.string().optional(),
})

export type RestError = z.infer<typeof RestError>

export const Client = z
    .object({
        activationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when a client was set as active for the first time.')
            .optional(),
        addresses: Address.array().describe('The addresses associated with this client.').optional(),
        approvedDate: z.string().datetime({ offset: true }).describe('The date when a client was approved.').optional(),
        assignedBranchKey: z.string().describe('The encoded key of the branch a client is assigned to.').optional(),
        assignedCentreKey: z.string().describe('The encoded key of the centre a client is assigned to.').optional(),
        assignedUserKey: z.string().describe('The encoded key of the user a client is assigned to.').optional(),
        birthDate: z.string().date().describe(`The client's date of birth.`).optional(),
        clientRoleKey: z.string().describe('A role which describes the intended use of a client in the system.').optional(),
        closedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when the client state was changed to closed.')
            .optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The date a client was created.').optional(),
        emailAddress: z.string().describe(`The client's email address.`).optional(),
        encodedKey: z.string().describe('The encoded key of the client, which is unique and generated.').optional(),
        firstName: z.string().describe('The first name, personal name, given name, or forename of the client.'),
        gender: z.enum(['MALE', 'FEMALE']).describe(`The client's gender, the options are male or female.`).optional(),
        groupKeys: z.string().array().describe('The groups to which this client belongs.').optional(),
        groupLoanCycle: z
            .number()
            .int()
            .describe(
                `Number of paid and closed (with 'obligations met') accounts for a client's group; when the closing operation is reverted, this is reduced.`,
            )
            .optional(),
        homePhone: z.string().describe(`The client's home phone number.`).optional(),
        id: z.string().describe('The ID of the client, which can be generated and customized - but must be unique.').optional(),
        idDocuments: IdentificationDocument.array().describe('The identification documents for this client.').optional(),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('The last date a client was modified.').optional(),
        lastName: z.string().describe('The last name, surname, or family name of the client.'),
        loanCycle: z
            .number()
            .int()
            .describe(
                `Number of paid and closed (with 'obligations met') accounts for a client; when the closing operation is reverted, this is reduced.`,
            )
            .optional(),
        middleName: z.string().describe('The middle name of the client.').optional(),
        migrationEventKey: z.string().describe('The migration event encoded key associated with a client.').optional(),
        mobilePhone: z.string().describe(`The client's mobile phone number.`).optional(),
        mobilePhone2: z.string().describe(`The client's second mobile phone number.`).optional(),
        notes: z.string().describe('The additional notes about a client.').optional(),
        portalSettings: PortalSettings.optional(),
        preferredLanguage: z
            .enum([
                'ENGLISH',
                'PORTUGESE',
                'SPANISH',
                'RUSSIAN',
                'FRENCH',
                'GEORGIAN',
                'CHINESE',
                'INDONESIAN',
                'ROMANIAN',
                'BURMESE',
                'GERMAN',
                'PORTUGUESE_BRAZIL',
                'VIETNAMESE',
                'ITALIAN',
                'THAI',
                'NORWEGIAN',
                'PHRASE',
            ])
            .describe(
                `The client's preferred language. This will determine the language for the reports, schedules, and account statements you generate for the client.`,
            )
            .optional(),
        profilePictureKey: z.string().describe(`The encoded key of a client's profile picture.`).optional(),
        profileSignatureKey: z.string().describe(`The encoded key of the client's profile signature.`).optional(),
        state: z
            .enum(['PENDING_APPROVAL', 'INACTIVE', 'ACTIVE', 'EXITED', 'BLACKLISTED', 'REJECTED'])
            .describe('The state of a client. It shows where the client is in the client life cycle.')
            .optional(),
    })
    .passthrough()
    .describe('Represents a client.')

export type Client = z.infer<typeof Client>

export const CreditArrangement = z
    .object({
        amount: z.number().describe('The maximum credit amount the client can be exposed to.'),
        approvedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when the credit arrangement was approved.')
            .optional(),
        availableCreditAmount: z.number().describe('The available amount of the credit arrangement.').optional(),
        closedDate: z.string().datetime({ offset: true }).describe('The date when the credit arrangement was closed.').optional(),
        consumedCreditAmount: z
            .number()
            .describe(
                'The consumed amount of the credit arrangement, which is calculated as the difference between the amount and available amount.',
            )
            .optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when the credit arrangement was created.')
            .optional(),
        currency: Currency.optional(),
        encodedKey: z
            .string()
            .describe('The encoded key of the credit arrangement, it is auto generated, and unique.')
            .optional(),
        expireDate: z.string().datetime({ offset: true }).describe('The date when the credit arrangement expires.'),
        exposureLimitType: z
            .enum(['APPROVED_AMOUNT', 'OUTSTANDING_AMOUNT'])
            .describe('The type of exposure limit calculation method used for the credit arrangement.')
            .optional(),
        holderKey: z
            .string()
            .describe('The encoded key of the credit arrangement holder (individual client or group).')
            .optional(),
        holderType: z
            .enum(['CLIENT', 'GROUP'])
            .describe('The type of the credit arrangement holder (individual client or group).'),
        id: z.string().describe('The ID of credit arrangement, can be generated and customized, and must be unique.').optional(),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last date when the credit arrangement was modified.')
            .optional(),
        notes: z.string().describe('The notes or description of the credit arrangement.').optional(),
        startDate: z
            .string()
            .datetime({ offset: true })
            .describe('The start date from which the credit arrangement became active.'),
        state: z
            .enum(['PENDING_APPROVAL', 'APPROVED', 'ACTIVE', 'CLOSED', 'WITHDRAWN', 'REJECTED'])
            .describe('The state of the credit arrangement.')
            .optional(),
        subState: z
            .enum(['PENDING_APPROVAL', 'APPROVED', 'ACTIVE', 'CLOSED', 'WITHDRAWN', 'REJECTED'])
            .describe('The substate of credit arrangement.')
            .optional(),
    })
    .passthrough()
    .describe('Represents a credit arrangement.')

export type CreditArrangement = z.infer<typeof CreditArrangement>

export const PatchOperation = z
    .object({
        from: z.string().describe('The field from where a value should be moved, when using move').optional(),
        op: z.enum(['ADD', 'REPLACE', 'REMOVE', 'MOVE']).describe('The change to perform'),
        path: z.string().describe('The field to perform the operation on'),
        value: z.unknown().describe('The value of the field, can be null').optional(),
    })
    .describe('A single change that needs to be made to a resource')

export type PatchOperation = z.infer<typeof PatchOperation>

export const ClientRole = z
    .object({
        canGuarantee: z
            .boolean()
            .describe('`TRUE` if clients with this client role can be used as guarantors, `FALSE` otherwise.')
            .optional(),
        canOpenAccounts: z
            .boolean()
            .describe('`TRUE` if new accounts for this client type can be created, `FALSE` otherwise.')
            .optional(),
        clientType: z.enum(['CLIENT', 'GROUP']).describe('The type of the client for which this role was created.').optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The creation date of the client role.').optional(),
        description: z.string().describe('The text description for this client role.').optional(),
        encodedKey: z.string().describe('The encoded key of the client, which is unique and generated.').optional(),
        id: z
            .string()
            .describe('The ID of the client role, which can be generated and customized - but must be unique.')
            .optional(),
        idPattern: z.string().describe('The pattern used in generating the client ID.').optional(),
        name: z.string().describe('The name of the client role.').optional(),
        requireID: z
            .boolean()
            .describe(
                '`TRUE` if identification documents must be provided for the client to be created, `FALSE` otherwise. Does not apply for groups.',
            )
            .optional(),
        useDefaultAddress: z
            .boolean()
            .describe('`TRUE` if the Mambu default address section is available, `FALSE` otherwise.')
            .optional(),
    })
    .describe('Represents a client or group role.')

export type ClientRole = z.infer<typeof ClientRole>

export const ClientSearchCriteria = z
    .object({
        filterCriteria: ClientFilterCriteria.array().describe('The list of filtering criteria'),
        sortingCriteria: ClientSortingCriteria.optional(),
    })
    .describe('Wrapper that holds a list of filtering criteria and a sorting criteria for clients')

export type ClientSearchCriteria = z.infer<typeof ClientSearchCriteria>

export const ErrorResponse = z.object({
    errors: RestError.array().optional(),
})

export type ErrorResponse = z.infer<typeof ErrorResponse>

export const GetAllResponse = Client.array()

export type GetAllResponse = z.infer<typeof GetAllResponse>

export const GetCreditArrangementsByClientIdOrKeyResponse = CreditArrangement.array()

export type GetCreditArrangementsByClientIdOrKeyResponse = z.infer<typeof GetCreditArrangementsByClientIdOrKeyResponse>

export const PatchRequest = PatchOperation.array()

export type PatchRequest = z.infer<typeof PatchRequest>

export const SearchResponse = Client.array()

export type SearchResponse = z.infer<typeof SearchResponse>
