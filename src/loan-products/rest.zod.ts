/**
 * Generated by @skyleague/therefore
 * Do not manually touch this
 */
/* eslint-disable */

import { z } from 'zod'

export const PaymentHolidaysSettings = z
    .object({
        paymentHolidaysLoanTermOption: z
            .enum(['EXTEND_LOAN_TERM', 'KEEP_THE_SAME_LOAN_TERM'])
            .describe('payment holiday option')
            .optional(),
    })
    .describe('Holds Payment Holidays Settings')

export type PaymentHolidaysSettings = z.infer<typeof PaymentHolidaysSettings>

export const DecimalConstraints = z
    .object({
        defaultValue: z
            .number()
            .describe('The default value, will be used in case no other value was filled in by the user.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the decimal constraint, auto generated, unique').optional(),
        maxValue: z.number().describe('The maximum value.').optional(),
        minValue: z.number().describe('The minimum value.').optional(),
    })
    .describe('Decimal constraints, like min/max/default.')

export type DecimalConstraints = z.infer<typeof DecimalConstraints>

export const AmountDecimalConstraints = z
    .object({
        defaultValue: z
            .number()
            .describe('The default value, will be used in case no other value was filled in by the user.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the decimal constraint, auto generated, unique').optional(),
        maxValue: z.number().describe('The maximum value.').optional(),
        minValue: z.number().describe('The minimum value.').optional(),
    })
    .describe('Decimal constraints, like min/max/default.')

export type AmountDecimalConstraints = z.infer<typeof AmountDecimalConstraints>

export const DecimalInterval = z
    .object({
        defaultValue: z
            .number()
            .describe('The default value, will be used in case no other value was filled in by the user.')
            .optional(),
        maxValue: z.number().describe('The maximum value.').optional(),
        minValue: z.number().describe('The minimum value.').optional(),
    })
    .describe('Decimal constraints, like min/max/default.')

export type DecimalInterval = z.infer<typeof DecimalInterval>

export const InterestRateTier = z
    .object({
        encodedKey: z.string().describe('The encoded key of the interest rate tier, auto generated, unique').optional(),
        endingBalance: z
            .number()
            .describe('The top-limit value for the account balance in order to determine if this tier is used or not')
            .optional(),
        interestRate: z
            .number()
            .describe(
                'The rate used for computing the interest for an account which has the balance less than the ending balance',
            ),
    })
    .describe('Used or TIERED interest rates, holds the values to define how the interest is computed')

export type InterestRateTier = z.infer<typeof InterestRateTier>

export const FeeTaxSettings = z
    .object({
        taxableCalculationMethod: z
            .enum(['DEFAULT', 'NON_TAXABLE', 'CUSTOM_TAX'])
            .describe(
                'Marks a specific fee as non-taxable (taxes are not calculated for it).Feature is in the Early Stage. To be enabled by request.',
            )
            .optional(),
    })
    .describe('Tax settings for a specific Predefined fee that overrides the tax settings of Loan Product')

export type FeeTaxSettings = z.infer<typeof FeeTaxSettings>

export const PeriodIntervalSettings = z
    .object({
        amortizationProfile: z
            .enum(['NONE', 'SUM_OF_YEARS_DIGITS', 'STRAIGHT_LINE', 'EFFECTIVE_INTEREST_RATE'])
            .describe('Type of amortization profile used for fee')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the period interval settings, auto generated, unique.').optional(),
        feeAmortizationUponRescheduleRefinanceOption: z
            .enum(['END_AMORTIZATION_ON_THE_ORIGINAL_ACCOUNT', 'CONTINUE_AMORTIZATION_ON_THE_RESCHEDULED_REFINANCED_ACCOUNT'])
            .describe('Flag for signaling if fee amortization should be continued or finished at account reschedule/refinance')
            .optional(),
        frequency: z
            .enum(['ACCOUNT_INSTALLMENTS_DUE_DATES', 'ACCOUNT_INSTALLMENTS_DUE_DATES_DAILY_BOOKING', 'CUSTOM_INTERVAL'])
            .describe('Frequency settings of the fee amortization')
            .optional(),
        intervalCount: z.number().int().describe('Total number of intervals').optional(),
        intervalType: z.enum(['PREDEFINED_INTERVALS', 'FULL_TERM']).describe('Defines the options for an interval').optional(),
        periodCount: z
            .number()
            .int()
            .describe('Period count used in conjunction with periodUnit to determine the next date of the interval')
            .optional(),
        periodUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS', 'YEARS'])
            .describe('Amortization unit to determine the interval between amortizations')
            .optional(),
    })
    .describe('The settings for defining period intervals.')

export type PeriodIntervalSettings = z.infer<typeof PeriodIntervalSettings>

export const GLAccountingRule = z
    .object({
        encodedKey: z.string().describe('The encoded key of the accounting rule, auto generated, unique.').optional(),
        financialResource: z
            .enum([
                'PORTFOLIO_CONTROL',
                'FUND_SOURCE',
                'WRITE_OFF_EXPENSE',
                'INTEREST_INCOME',
                'PAYMENT_HOLIDAY_INTEREST_INCOME',
                'TAXES_PAYABLE',
                'FEE_INCOME',
                'PENALTY_INCOME',
                'NEGATIVE_INTEREST_PAYABLE_RECEIVABLE',
                'NEGATIVE_INTEREST_PAYABLE',
                'INTEREST_RECEIVABLE',
                'PAYMENT_HOLIDAY_INTEREST_RECEIVABLE',
                'FEE_RECEIVABLE',
                'PENALTY_RECEIVABLE',
                'TAXES_RECEIVABLE',
                'DEFERRED_INTERESTS_INCOME',
                'DEFERRED_FEE_INCOME',
                'DEFERRED_TAXES',
                'DEPOSIT_REFERENCE',
                'SAVINGS_CONTROL',
                'INTEREST_EXPENSE',
                'INTEREST_PAYABLE',
                'NEGATIVE_INTEREST_INCOME',
                'NEGATIVE_INTEREST_RECEIVABLE',
                'OVERDRAFT_PORTFOLIO_CONTROL',
                'OVERDRAFT_INTEREST_INCOME',
                'OVERDRAFT_WRITE_OFF_EXPENSE',
                'OVERDRAFT_INTEREST_RECEIVABLE',
                'INTER_BRANCH_TRANSFER',
                'INTEREST_FROM_ARREARS_INCOME',
                'INTEREST_FROM_ARREARS_RECEIVABLE',
                'INTEREST_FROM_ARREARS_WRITE_OFF_EXPENSE',
            ])
            .describe(
                'General Ledger Financial Resources used to setup the product accounting rules and determine the credit and debit accounts when logging journal entries',
            ),
        glAccountKey: z.string().describe('The encoded key of the account that is mapped to the financialResource'),
        transactionChannelKey: z.string().describe('The key of the transaction rule that uses this rule').optional(),
    })
    .describe(
        'The GL accounting rule, it maps a financial resource with a GL account for a specific product (i.e loan or saving).',
    )

export type GLAccountingRule = z.infer<typeof GLAccountingRule>

export const RepaymentScheduleEditOptionDetails = z
    .object({
        paymentHolidaysSettings: PaymentHolidaysSettings.optional(),
    })
    .describe('Holds Repayments Schedule Editing options')

export type RepaymentScheduleEditOptionDetails = z.infer<typeof RepaymentScheduleEditOptionDetails>

export const RoundingSettings = z
    .object({
        repaymentCurrencyRounding: z
            .enum(['NO_ROUNDING', 'ROUND_TO_NEAREST_WHOLE_UNIT', 'ROUND_UP_TO_NEAREST_WHOLE_UNIT'])
            .describe('Specifies the repayment currency rounding method.'),
        repaymentElementsRoundingMethod: z
            .enum(['NO_ROUNDING', 'ROUND_ALL', 'PAYMENT_DUE'])
            .describe('Determines how the repayment currency rounding is handled on each element from the schedule.'),
        roundingRepaymentScheduleMethod: z
            .enum([
                'NO_ROUNDING',
                'ROUND_REMAINDER_INTO_LAST_REPAYMENT',
                'ROUND_PRINCIPAL_AND_INTEREST_REMAINDER_INTO_LAST_REPAYMENT',
            ])
            .describe('Specifies the rounding repayment schedule method.'),
    })
    .describe('Defines the rounding settings used in the loan computation.')

export type RoundingSettings = z.infer<typeof RoundingSettings>

export const PreviewScheduleSettings = z
    .object({
        numberOfPreviewedInstalments: z.number().int().describe('Number of Previewed Instalments.').optional(),
        previewScheduleEnabled: z.boolean().describe('Preview Schedule status.').optional(),
    })
    .describe('Defines the Preview Schedule settings for revolving products')

export type PreviewScheduleSettings = z.infer<typeof PreviewScheduleSettings>

export const IntegerIntervalConstraints = z
    .object({
        defaultValue: z
            .number()
            .int()
            .describe('The default value, will be used in case no other value was filled in by the user.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the integer constraint, auto generated, unique').optional(),
        maxValue: z.number().int().describe('The maximum value.').optional(),
        minValue: z.number().int().describe('The minimum value.').optional(),
    })
    .describe('Decimal integer, like min/max/default.')

export type IntegerIntervalConstraints = z.infer<typeof IntegerIntervalConstraints>

export const BillingCyclesProductSettings = z
    .object({
        enabled: z.boolean().describe('The billing cycle status if it is enabled or disabled').optional(),
        startDays: z.number().int().array().describe('The billing cycle start days in case it is enabled').optional(),
    })
    .describe('Defines the billing cycles settings for revolving credit products')

export type BillingCyclesProductSettings = z.infer<typeof BillingCyclesProductSettings>

export const ProductAmortizationPeriod = z
    .object({
        defaultValue: z.number().int().describe('default value').optional(),
        maxValue: z.number().int().describe('max value').optional(),
        minValue: z.number().int().describe('min value').optional(),
    })
    .describe(
        'It holds information about the loan product amortization period. The PMT is calculated as the loan would have [amortisationPeriod] instalments',
    )

export type ProductAmortizationPeriod = z.infer<typeof ProductAmortizationPeriod>

export const PrincipalPaymentProductSettings = z
    .object({
        amount: AmountDecimalConstraints.optional(),
        defaultPrincipalRepaymentInterval: z
            .number()
            .int()
            .describe('How many repayments the principal has to be paid')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the settings, auto generated, unique').optional(),
        includeFeesInFloorAmount: z
            .boolean()
            .describe(
                'If true, the fees will be included along with the principal in the repayment floor amount, for a revolving credit account',
            )
            .optional(),
        includeInterestInFloorAmount: z
            .boolean()
            .describe(
                'If true, the interest will be included along with the principal in the repayment floor amount, for a revolving credit account',
            )
            .optional(),
        percentage: DecimalConstraints.optional(),
        principalCeilingValue: z
            .number()
            .describe('The maximum principal due amount a repayment made with this settings can have')
            .optional(),
        principalFloorValue: z
            .number()
            .describe('The minimum principal due amount a repayment made with this settings can have')
            .optional(),
        principalPaymentMethod: z
            .enum([
                'FLAT',
                'OUTSTANDING_PRINCIPAL_PERCENTAGE',
                'PRINCIPAL_PERCENTAGE_LAST_DISB',
                'TOTAL_BALANCE_PERCENTAGE',
                'TOTAL_BALANCE_FLAT',
                'TOTAL_PRINCIPAL_PERCENTAGE',
            ])
            .describe('The method of principal payment for revolving credit')
            .optional(),
        totalDueAmountFloor: z
            .number()
            .describe('The minimum total due amount a repayment made with this settings can have')
            .optional(),
        totalDuePayment: z
            .enum([
                'FLAT',
                'OUTSTANDING_PRINCIPAL_PERCENTAGE',
                'PRINCIPAL_PERCENTAGE_LAST_DISB',
                'TOTAL_BALANCE_PERCENTAGE',
                'TOTAL_BALANCE_FLAT',
                'TOTAL_PRINCIPAL_PERCENTAGE',
            ])
            .describe('The method of total due payment for revolving credit')
            .optional(),
    })
    .describe('Defines the principal payment settings constraints for the loans that will be created based on this product.')

export type PrincipalPaymentProductSettings = z.infer<typeof PrincipalPaymentProductSettings>

export const ProductPrepaymentSettings = z
    .object({
        applyInterestOnPrepaymentMethod: z
            .enum(['AUTOMATIC', 'MANUAL'])
            .describe('Whether the interest on prepayment is applied manual or automatic.')
            .optional(),
        elementsRecalculationMethod: z
            .enum(['PRINCIPAL_EXPECTED_FIXED', 'TOTAL_EXPECTED_FIXED'])
            .describe(
                'The elements recalculation method, indicates how the declining balance with equal installments repayments are recalculated',
            )
            .optional(),
        ercFreeAllowance: z.number().describe('ERC free allowance in percentage').optional(),
        futurePaymentsAcceptance: z
            .enum(['NO_FUTURE_PAYMENTS', 'ACCEPT_FUTURE_PAYMENTS', 'ACCEPT_OVERPAYMENTS'])
            .describe(
                'Shows whether the future payments are allowed or not for this product (repayment transactions with entry date set in the future)',
            ),
        prepaymentAcceptance: z
            .enum(['ACCEPT_PREPAYMENTS', 'NO_PREPAYMENTS'])
            .describe('Shows whether the pre-payments are allowed or not for this product.')
            .optional(),
        prepaymentRecalculationMethod: z
            .enum([
                'NO_RECALCULATION',
                'RESCHEDULE_REMAINING_REPAYMENTS',
                'RECALCULATE_SCHEDULE_KEEP_SAME_NUMBER_OF_TERMS',
                'RECALCULATE_SCHEDULE_KEEP_SAME_PRINCIPAL_AMOUNT',
                'RECALCULATE_SCHEDULE_KEEP_SAME_TOTAL_REPAYMENT_AMOUNT',
                'REDUCE_AMOUNT_PER_INSTALLMENT',
                'REDUCE_NUMBER_OF_INSTALLMENTS',
                'REDUCE_NUMBER_OF_INSTALLMENTS_NEW',
            ])
            .describe('Prepayment recalculation method copied from the loan product on which this account is based')
            .optional(),
        principalPaidInstallmentStatus: z
            .enum(['PARTIALLY_PAID', 'PAID', 'ORIGINAL_TOTAL_EXPECTED_PAID'])
            .describe('Installment status for the case when principal is paid off (copied from loan product)')
            .optional(),
    })
    .describe('Defines the prepayment settings for the product')

export type ProductPrepaymentSettings = z.infer<typeof ProductPrepaymentSettings>

export const TrancheSettings = z
    .object({
        maxNumberOfTranches: z.number().int().describe('The number of tranches supported by the loan product').optional(),
    })
    .describe(
        'The tranche settings, indicates the settings regarding tranches in case the product is configured to support tranches.',
    )

export type TrancheSettings = z.infer<typeof TrancheSettings>

export const LockSettings = z
    .object({
        cappingConstraintType: z
            .enum(['SOFT_CAP', 'HARD_CAP'])
            .describe('Specifies constraint types for capping charges.')
            .optional(),
        cappingMethod: z
            .enum(['OUTSTANDING_PRINCIPAL_PERCENTAGE', 'ORIGINAL_PRINCIPAL_PERCENTAGE'])
            .describe('Specifies how principal will be used when calculating capping charges.')
            .optional(),
        cappingPercentage: z
            .number()
            .describe(
                'Specifies the percentage of principal that cannot be exceeded by the sum of interest, fees and penalty balances.',
            )
            .optional(),
        lockPeriodDays: z
            .number()
            .int()
            .describe('Specifies the number of days for in which the account will be locked if it stays in arrears.')
            .optional(),
    })
    .describe('Settings applied when transitioning accounts to Locked state')

export type LockSettings = z.infer<typeof LockSettings>

export const FourEyesPrinciple = z
    .object({
        activeForLoanApproval: z.boolean().describe('Requires separate users to create and approve loan accounts').optional(),
    })
    .describe('Settings for Four Eyes Principle')

export type FourEyesPrinciple = z.infer<typeof FourEyesPrinciple>

export const PMTAdjustmentThreshold = z
    .object({
        method: z
            .enum(['WORKING_DAYS', 'CALENDAR_DAYS'])
            .describe('The method used to calculate the PMT Adjustment threshold. Supported value is CALENDAR_DAYS')
            .optional(),
        numberOfDays: z.number().int().describe('The number of days that trigger a PMT Adjustment.').optional(),
    })
    .describe('Represents PMT Adjustment threshold settings for loan accounts and loan products.')

export type PMTAdjustmentThreshold = z.infer<typeof PMTAdjustmentThreshold>

export const ProductInterestRateSettings = z
    .object({
        encodedKey: z.string().describe('The encoded key of the interest rate settings, auto generated, unique').optional(),
        indexSourceKey: z.string().describe('Index rate source key.').optional(),
        interestRate: DecimalInterval.optional(),
        interestRateCeilingValue: z
            .number()
            .describe('Maximum value allowed for index based interest rate. Valid only for index interest rate.')
            .optional(),
        interestRateFloorValue: z
            .number()
            .describe('Minimum value allowed for index based interest rate. Valid only for index interest rate.')
            .optional(),
        interestRateReviewCount: z
            .number()
            .int()
            .describe('Interest rate review frequency unit count. Valid only for index interest rate.')
            .optional(),
        interestRateReviewUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS'])
            .describe('Interest rate review frequency measurement unit. Valid only for index interest rate.')
            .optional(),
        interestRateSource: z
            .enum(['FIXED_INTEREST_RATE', 'INDEX_INTEREST_RATE'])
            .describe('Interest calculation method: fixed or indexed(interest spread + active organization index interest rate)'),
    })
    .describe('Adjustable interest rates settings')

export type ProductInterestRateSettings = z.infer<typeof ProductInterestRateSettings>

export const DaysInMonth = z
    .object({
        daysInMonth: z
            .number()
            .int()
            .array()
            .describe(
                ' Specifies the day(s) of the month when the interest application dates should be. Only available if the Interest Application Method is InterestApplicationMethodDTO#FIXED_DAYS_OF_MONTH. Currently only 1 value can be specified.',
            )
            .optional(),
        shortMonthHandlingMethod: z
            .enum(['LAST_DAY_IN_MONTH', 'FIRST_DAY_OF_NEXT_MONTH'])
            .describe(
                'Determines how to handle the short months, if they select a fixed day of month > 28. Will be null if no such date is selected. Only available if the Interest Application Method is InterestApplicationMethodDTO#FIXED_DAYS_OF_MONTH.',
            )
            .optional(),
    })
    .describe('Enumeration for days of month and method of handling shorter months.')

export type DaysInMonth = z.infer<typeof DaysInMonth>

export const InterestProductSettings = z
    .object({
        accrueInterestAfterMaturity: z
            .boolean()
            .describe(
                'If the product supports this option, specify if the interest should be accrued after the account maturity date',
            )
            .optional(),
        allowNegativeInterestRate: z
            .boolean()
            .describe('Indicator whether the loan product allows negative values for interest rate or interest spread')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the interest rate tier, auto generated, unique').optional(),
        indexSourceKey: z.string().describe('Index rate source key.').optional(),
        interestChargeFrequency: z
            .enum(['ANNUALIZED', 'EVERY_MONTH', 'EVERY_FOUR_WEEKS', 'EVERY_WEEK', 'EVERY_DAY', 'EVERY_X_DAYS'])
            .describe('The interval used for determining how often is interest charged')
            .optional(),
        interestChargeFrequencyCount: z.number().int().describe('the count of units to apply over the interval').optional(),
        interestRate: DecimalInterval.optional(),
        interestRateCeilingValue: z
            .number()
            .describe(
                `Interest spread + index interest rate can't be more than this amount (valid only for index interest rate products).`,
            )
            .optional(),
        interestRateFloorValue: z
            .number()
            .describe(
                `Interest spread + index interest rate can't be less than this amount (valid only for index interest rate products).`,
            )
            .optional(),
        interestRateReviewCount: z.number().int().describe('Interest rate review frequency unit count').optional(),
        interestRateReviewUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS'])
            .describe('Interest rate review frequency measurement unit')
            .optional(),
        interestRateSource: z
            .enum(['FIXED_INTEREST_RATE', 'INDEX_INTEREST_RATE'])
            .describe('Interest calculation method: fixed or (interest spread + active organization index interest rate)')
            .optional(),
        interestRateTerms: z
            .enum(['FIXED', 'TIERED', 'TIERED_PERIOD', 'TIERED_BAND'])
            .describe('The option for how is the interest rate determined when being accrued for an account')
            .optional(),
        interestRateTiers: InterestRateTier.array()
            .describe('The list of interest rate tiers available for the current settings instance')
            .optional(),
    })
    .describe(
        'The interest settings, defines constraints regarding interest that will be used on the loan account created based on this product.',
    )

export type InterestProductSettings = z.infer<typeof InterestProductSettings>

export const PredefinedFee = z
    .object({
        accountingRules: GLAccountingRule.array()
            .describe('A list of accounting rules defined for this fee. If null, product default rules are selected.')
            .optional(),
        amortizationSettings: PeriodIntervalSettings.optional(),
        amount: z.number().describe('The amount of the fee').optional(),
        amountCalculationFunctionName: z.string().describe('Mambu Function name used for the fee calculation').optional(),
        amountCalculationMethod: z
            .enum([
                'FLAT',
                'LOAN_AMOUNT_PERCENTAGE',
                'REPAYMENT_PRINCIPAL_AMOUNT_PERCENTAGE',
                'LOAN_AMOUNT_PERCENTAGE_NUMBER_OF_INSTALLMENTS',
                'FLAT_NUMBER_OF_INSTALLMENTS',
                'IOF_PERCENTAGE_OF_DISBURSED_AMOUNT',
                'IOF_PERCENTAGE_OF_INSTALLMENT_PRINCIPAL',
                'IOF_PERCENTAGE_OF_LATE_INSTALLMENT_PRINCIPAL',
                'MAMBU_FUNCTION',
                'FEE_RATE_ON_OUTSTANDING_PRINCIPAL',
            ])
            .describe('The amount from which the fee is calculated using percentageAmount')
            .optional(),
        applyDateMethod: z
            .enum(['MONTHLY_FROM_ACTIVATION', 'FIRST_OF_EVERY_MONTH'])
            .describe('Shows when a fee should be applied; to be used with monthly deposit fees')
            .optional(),
        creationDate: z.string().datetime({ offset: true }).describe('Shows the creation date of the fee').optional(),
        encodedKey: z.string().describe('The encoded key of the predefined fee, auto generated, unique').optional(),
        feeApplication: z.enum(['REQUIRED', 'OPTIONAL']).describe('The type of fee application when disbursement is applied'),
        id: z.string().describe('The id of the fee').optional(),
        interestBearing: z.boolean().describe('Indication if the fee bears interest').optional(),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('Shows the last modified date of the fee').optional(),
        name: z.string().describe('The name of the fee').optional(),
        percentageAmount: z.number().describe('The amount of the fee in percents applied to percentSource').optional(),
        scheduleAllocationMethod: z
            .enum(['ON_INSTALLMENT', 'NO_ALLOCATION'])
            .describe('Method to allocate a fee to installments on the schedule')
            .optional(),
        state: z.enum(['ACTIVE', 'INACTIVE']).describe('Indicates the state of the fee'),
        taxSettings: FeeTaxSettings.optional(),
        trigger: z
            .enum([
                'MANUAL',
                'MANUAL_PLANNED',
                'DISBURSEMENT',
                'CAPITALIZED_DISBURSEMENT',
                'UPFRONT_DISBURSEMENT',
                'LATE_REPAYMENT',
                'PAYMENT_DUE',
                'PAYMENT_DUE_APPLIED_ON_DUE_DATES',
                'ARBITRARY',
                'IOF',
                'EARLY_REPAYMENT_CHARGE',
                'FEE_INCLUDED_IN_PMT',
            ])
            .describe('Shows the event that will trigger a fee'),
    })
    .describe('The response representation of the PredefinedFee. Represents a fee with a defined name and a fixed value.')

export type PredefinedFee = z.infer<typeof PredefinedFee>

export const BranchSettings = z
    .object({
        availableProductBranches: z
            .string()
            .array()
            .describe('Holds the encoded keys of the branches this product should be available for.')
            .optional(),
        forAllBranches: z.boolean().describe('Indicates if this product should be available for all branches').optional(),
    })
    .describe('Holds information about branch availability for the product.')

export type BranchSettings = z.infer<typeof BranchSettings>

export const DocumentTemplate = z
    .object({
        creationDate: z.string().datetime({ offset: true }).describe('The creation date of the document').optional(),
        encodedKey: z.string().describe('The document encodedKey').optional(),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('The last modified date of the document').optional(),
        name: z.string().describe('The name the document').optional(),
        type: z.enum(['ACCOUNT', 'TRANSACTION', 'ACCOUNT_WITH_TRANSACTIONS']).describe('The type of the template').optional(),
    })
    .describe('Template documents of the product.')

export type DocumentTemplate = z.infer<typeof DocumentTemplate>

export const TaxSettings = z
    .object({
        taxCalculationMethod: z
            .enum(['INCLUSIVE', 'EXCLUSIVE'])
            .describe('Shows whether the tax is added on top of the target amount or not.')
            .optional(),
        taxesOnFeesEnabled: z.boolean().describe('Shows whether taxes on fees are enabled for this product or not.').optional(),
        taxesOnInterestEnabled: z
            .boolean()
            .describe('Shows whether taxes on interest are enabled for this product or not.')
            .optional(),
        taxesOnPenaltyEnabled: z
            .boolean()
            .describe('Shows whether taxes on penalties are enabled for this product or not.')
            .optional(),
        taxSourceKey: z.string().describe('The tax source from where the loan account taxes will be updated.').optional(),
    })
    .describe('Tax settings, defines some settings for taxes on the loan product')

export type TaxSettings = z.infer<typeof TaxSettings>

export const SecuritySettings = z
    .object({
        isCollateralEnabled: z
            .boolean()
            .describe(
                'Shows whether collateral (assets or other goods) are accepted in order to reach required securities percentage from loan amount, as defined in this product.',
            )
            .optional(),
        isGuarantorsEnabled: z
            .boolean()
            .describe(
                'Shows whether guarantors (other clients) are accepted in order to reach the required securities percentage from loan amount, as defined in this product.',
            )
            .optional(),
        requiredGuaranties: z
            .number()
            .describe(
                'The securities percentage from loan amount that is needed in order for this account to be approved. Null if the securities are not required.',
            )
            .optional(),
    })
    .describe('The settings and constraints for securities.')

export type SecuritySettings = z.infer<typeof SecuritySettings>

export const LoanProductScheduleSettings = z
    .object({
        amortizationPeriod: ProductAmortizationPeriod.optional(),
        billingCycles: BillingCyclesProductSettings.optional(),
        defaultRepaymentPeriodCount: z.number().int().describe('Interval Repayment Methodology Settings.').optional(),
        firstRepaymentDueDateOffset: IntegerIntervalConstraints.optional(),
        fixedDaysOfMonth: z
            .number()
            .int()
            .array()
            .describe(
                ' Specifies the days of the month when the repayment due dates should be. Only available if the Repayment Methodology is ScheduleDueDatesMethodDTO#FIXED_DAYS_OF_MONTH.',
            )
            .optional(),
        interestAccrualSince: z
            .enum(['DISBURSEMENT', 'DUE_DATE'])
            .describe('Represents the moment the interest will start getting accrued.')
            .optional(),
        keepInstallmentsEqualIfLongFirstPeriod: z
            .boolean()
            .describe(
                'For optimized payments only, indicates whether the installments should remain equal when the first period is long',
            )
            .optional(),
        numInstallments: IntegerIntervalConstraints.optional(),
        previewSchedule: PreviewScheduleSettings.optional(),
        repaymentMethod: z.enum(['AMOUNT', 'INSTALLMENTS']).describe('The repayment method value').optional(),
        repaymentPeriodUnit: z
            .enum(['DAYS', 'WEEKS', 'MONTHS', 'YEARS'])
            .describe('The frequency of the loan repayment.')
            .optional(),
        repaymentReschedulingMethod: z
            .enum(['NONE', 'NEXT_WORKING_DAY', 'PREVIOUS_WORKING_DAY', 'EXTEND_SCHEDULE'])
            .describe('The repayment rescheduling method used in calculations.'),
        repaymentScheduleEditOptions: z
            .enum([
                'ADJUST_PAYMENT_DATES',
                'ADJUST_PRINCIPAL_PAYMENT_SCHEDULE',
                'ADJUST_INTEREST_PAYMENT_SCHEDULE',
                'ADJUST_FEE_PAYMENT_SCHEDULE',
                'ADJUST_PENALTY_PAYMENT_SCHEDULE',
                'ADJUST_NUMBER_OF_INSTALLMENTS',
                'ADJUST_PAYMENT_HOLIDAYS',
            ])
            .array()
            .describe('Shows the properties from the repayment schedule can be edited.')
            .optional(),
        repaymentScheduleMethod: z
            .enum(['NONE', 'FIXED', 'DYNAMIC'])
            .describe(
                `The repayment schedule method. Represents the method that determines whether the schedule will be fixed all over the loan account's life cycle or will be dynamically recomputed when required.`,
            ),
        roundingSettings: RoundingSettings.optional(),
        scheduleDueDatesMethod: z
            .enum(['INTERVAL', 'FIXED_DAYS_OF_MONTH'])
            .describe('The methodology used by this product to compute the due dates of the repayments.'),
        scheduleEditOptionDetails: RepaymentScheduleEditOptionDetails.optional(),
        shortMonthHandlingMethod: z
            .enum(['LAST_DAY_IN_MONTH', 'FIRST_DAY_OF_NEXT_MONTH'])
            .describe(
                'Determines how to handle the short months, if they select a fixed day of month > 28. Will be null if no such date is selected and also for the Interval methodology. Only available if the Schedule Due Dates Method is ScheduleDueDatesMethodDTO#FIXED_DAYS_OF_MONTHs.',
            )
            .optional(),
    })
    .describe('Defines the settings and constraints for schedule for the loans that are created based on this product.')

export type LoanProductScheduleSettings = z.infer<typeof LoanProductScheduleSettings>

export const ProductRedrawSettings = z
    .object({
        allowRedraw: z
            .boolean()
            .describe(
                'Indicates whether the product support redraw (prepayments which are stored at loan account level as a Redrawable balance)',
            ),
    })
    .describe('The redraw settings for the product.')

export type ProductRedrawSettings = z.infer<typeof ProductRedrawSettings>

export const ProductPenaltySettings = z
    .object({
        loanPenaltyCalculationMethod: z
            .enum(['NONE', 'OVERDUE_BALANCE', 'OVERDUE_BALANCE_AND_INTEREST', 'OUTSTANDING_PRINCIPAL'])
            .describe('The penalty calculation method'),
        loanPenaltyGracePeriod: z
            .number()
            .int()
            .describe('Number of days to wait before applying the loan penalty amounts')
            .optional(),
        penaltyRate: DecimalConstraints.optional(),
    })
    .describe('Defines the penalty settings for the product that will be used by the loan accounts based on this product')

export type ProductPenaltySettings = z.infer<typeof ProductPenaltySettings>

export const PaymentSettings = z
    .object({
        amortizationMethod: z
            .enum(['STANDARD_PAYMENTS', 'BALLOON_PAYMENTS', 'OPTIMIZED_PAYMENTS', 'PAYMENT_PLAN'])
            .describe('Payments Method used by loan accounts for repayments schedule generation.')
            .optional(),
        latePaymentsRecalculationMethod: z
            .enum(['OVERDUE_INSTALLMENTS_INCREASE', 'LAST_INSTALLMENT_INCREASE', 'NO_RECALCULATION'])
            .describe('Recalculate the schedule when late payments are posted on dynamic Equal Installments loans.'),
        paymentMethod: z
            .enum(['HORIZONTAL', 'VERTICAL'])
            .describe(
                'The payment method. Represents the interest payment method that determines whether the payments are made Horizontally (on the Repayments) or Vertically (on the Loan Account)',
            ),
        prepaymentSettings: ProductPrepaymentSettings.optional(),
        principalPaymentSettings: PrincipalPaymentProductSettings.optional(),
        repaymentAllocationOrder: z
            .enum(['PRINCIPAL', 'INTEREST', 'FEE', 'PENALTY'])
            .array()
            .describe('A list of basic repayment allocation elements such as the principal, interest & fees.'),
    })
    .describe('Defines the payment settings for the loan product and for loans crated based on this product.')

export type PaymentSettings = z.infer<typeof PaymentSettings>

export const OffsetSettings = z
    .object({
        allowOffset: z.boolean().describe('Indicates whether the product supports offset').optional(),
    })
    .describe('The offset settings, holds information about offset.')

export type OffsetSettings = z.infer<typeof OffsetSettings>

export const NewAccountSettings = z
    .object({
        accountInitialState: z
            .enum(['PARTIAL_APPLICATION', 'PENDING_APPROVAL', 'APPROVED', 'ACTIVE', 'ACTIVE_IN_ARREARS', 'CLOSED'])
            .describe('The initial state of the account when is created.'),
        idGeneratorType: z
            .enum(['INCREMENTAL_NUMBER', 'RANDOM_PATTERN'])
            .describe('The type of generator used for IDs creation.'),
        idPattern: z.string().describe('The pattern that will be used for ID validation (as referred to as an input mask).'),
    })
    .describe(
        'The new account settings, defines the settings and constraints used by new loan account created based on this product.',
    )

export type NewAccountSettings = z.infer<typeof NewAccountSettings>

export const LoanAmountSettings = z
    .object({
        loanAmount: AmountDecimalConstraints.optional(),
        trancheSettings: TrancheSettings.optional(),
    })
    .describe('The amount settings, holds all amount properties.')

export type LoanAmountSettings = z.infer<typeof LoanAmountSettings>

export const InternalControls = z
    .object({
        dormancyPeriodDays: z
            .number()
            .int()
            .describe('Specifies the number of days for an account to be fully paid in order to auto close it.')
            .optional(),
        fourEyesPrinciple: FourEyesPrinciple.optional(),
        lockSettings: LockSettings.optional(),
    })
    .describe('Constraints and automated actions and that will be applied on the accounts.')

export type InternalControls = z.infer<typeof InternalControls>

export const ProductInterestSettings = z
    .object({
        accrueLateInterest: z.boolean().describe('Whether late interest should be accrued, applied and paid').optional(),
        compoundingFrequency: z
            .enum(['DAILY', 'SEMI_ANNUALLY'])
            .describe(
                'The frequency on which the accrued interest will be added to the principal for interest calculation. It is used only for InterestType.COMPOUNDING_INTEREST',
            )
            .optional(),
        daysInYear: z
            .enum(['ACTUAL_365_FIXED', 'ACTUAL_364', 'ACTUAL_360', 'ACTUAL_ACTUAL_ISDA', 'E30_360', 'BUS_252', 'E30_42_365'])
            .describe('The days in year that should be used for loan calculations.'),
        decoupleInterestFromArrears: z
            .boolean()
            .describe(
                'Whether interest from arrears is decoupled from regular interest. (Only accepted or returned if the feature is enabled.)',
            )
            .optional(),
        indexRateSettings: InterestProductSettings.optional(),
        interestApplicationDays: DaysInMonth.optional(),
        interestApplicationMethod: z
            .enum(['AFTER_DISBURSEMENT', 'REPAYMENT_DUE_DATE', 'FIXED_DAYS_OF_MONTH'])
            .describe(
                `The interest application method. Represents the interest application method that determines whether the interest gets applied on the account's disbursement or on each repayment.`,
            )
            .optional(),
        interestBalanceCalculationMethod: z
            .enum(['ONLY_PRINCIPAL', 'PRINCIPAL_AND_INTEREST'])
            .describe(
                `The interest balance calculation method. Represents the option which determines the way the balance for the account's interest is computed.`,
            )
            .optional(),
        interestCalculationMethod: z
            .enum(['FLAT', 'DECLINING_BALANCE', 'DECLINING_BALANCE_DISCOUNTED', 'EQUAL_INSTALLMENTS'])
            .describe('The interest calculation method. Holds the type of interest calculation method.'),
        interestRateSettings: ProductInterestRateSettings.array().describe('Adjustable interest rates settings').optional(),
        interestType: z
            .enum(['SIMPLE_INTEREST', 'CAPITALIZED_INTEREST', 'COMPOUNDING_INTEREST'])
            .describe('The possible values for how we compute and apply the interest')
            .optional(),
        pmtAdjustmentThreshold: PMTAdjustmentThreshold.optional(),
        scheduleInterestDaysCountMethod: z
            .enum(['REPAYMENT_PERIODICITY', 'ACTUAL_DAYS_COUNT'])
            .describe(
                'Shows  whether all the installments should compute the interest based on the actual number of days or based on the defined repayment periodicity.',
            ),
    })
    .describe(
        'The interest settings, defines constraints regarding interest that will be used on the loan account crated based on this product.',
    )

export type ProductInterestSettings = z.infer<typeof ProductInterestSettings>

export const GracePeriodSettings = z
    .object({
        gracePeriod: IntegerIntervalConstraints.optional(),
        gracePeriodType: z
            .enum(['NONE', 'PAY_INTEREST_ONLY', 'INTEREST_FORGIVENESS'])
            .describe('The grace period type. Representing the type of grace period which is possible for a loan account.')
            .optional(),
    })
    .describe('The funding settings, holds the settings regarding the funding for the loan product.')

export type GracePeriodSettings = z.infer<typeof GracePeriodSettings>

export const FundingSettings = z
    .object({
        enabled: z.boolean().describe('Indicates whether the product has the investor funds enabled or not.').optional(),
        funderInterestCommission: DecimalConstraints.optional(),
        funderInterestCommissionAllocationType: z
            .enum(['PERCENTAGE_OF_LOAN_FUNDING', 'FIXED_INTEREST_COMMISSIONS'])
            .describe(
                'Define how the Interest is allocated to the investors(if the investors can define their own percentages for their own contribution to the loan, or if all of them are using the same percentage).',
            )
            .optional(),
        lockFundsAtApproval: z
            .boolean()
            .describe(`Shows whether investor funds are locked or not at the loan account's approval.`)
            .optional(),
        organizationInterestCommission: DecimalConstraints.optional(),
        requiredFunds: z
            .number()
            .describe(
                'The required investor funds percentage, for opening an account with external funding. If null, the investor funds are not enabled.',
            )
            .optional(),
    })
    .describe('The funding settings, holds the settings regarding the funding for the loan product.')

export type FundingSettings = z.infer<typeof FundingSettings>

export const FeesSettings = z
    .object({
        allowArbitraryFees: z
            .boolean()
            .describe(
                `Only if true users will be able to apply fees, for current object, of type 'Other'; these fees can have any amount.`,
            )
            .optional(),
        fees: PredefinedFee.array()
            .describe('List of all fees that can be applied for accounts of this loan product.')
            .optional(),
    })
    .describe('Defines fees settings for the product.')

export type FeesSettings = z.infer<typeof FeesSettings>

export const Currency = z
    .object({
        code: z
            .enum([
                'AED',
                'AFN',
                'ALL',
                'AMD',
                'ANG',
                'AOA',
                'ARS',
                'AUD',
                'AWG',
                'AZN',
                'BAM',
                'BBD',
                'BDT',
                'BGN',
                'BHD',
                'BIF',
                'BMD',
                'BND',
                'BOB',
                'BOV',
                'BRL',
                'BSD',
                'BTN',
                'BWP',
                'BYR',
                'BYN',
                'BZD',
                'CAD',
                'CDF',
                'CHE',
                'CHF',
                'CHW',
                'CLF',
                'CLP',
                'CNY',
                'COP',
                'COU',
                'CRC',
                'CUC',
                'CUP',
                'CVE',
                'CZK',
                'DJF',
                'DKK',
                'DOP',
                'DZD',
                'EGP',
                'ERN',
                'ETB',
                'EUR',
                'FJD',
                'FKP',
                'GBP',
                'GEL',
                'GHS',
                'GIP',
                'GMD',
                'GNF',
                'GTQ',
                'GYD',
                'HKD',
                'HNL',
                'HRK',
                'HTG',
                'HUF',
                'IDR',
                'ILS',
                'INR',
                'IQD',
                'IRR',
                'ISK',
                'JMD',
                'JOD',
                'JPY',
                'KES',
                'KGS',
                'KHR',
                'KMF',
                'KPW',
                'KRW',
                'KWD',
                'KYD',
                'KZT',
                'LAK',
                'LBP',
                'LKR',
                'LRD',
                'LSL',
                'LTL',
                'LVL',
                'LYD',
                'MAD',
                'MDL',
                'MGA',
                'MKD',
                'MMK',
                'MNT',
                'MOP',
                'MRO',
                'MRU',
                'MUR',
                'MVR',
                'MWK',
                'MXN',
                'MXV',
                'MYR',
                'MZN',
                'NAD',
                'NGN',
                'NIO',
                'NOK',
                'NPR',
                'NZD',
                'OMR',
                'PAB',
                'PEN',
                'PGK',
                'PHP',
                'PKR',
                'PLN',
                'PYG',
                'QAR',
                'RON',
                'RSD',
                'RUB',
                'RWF',
                'SAR',
                'SBD',
                'SCR',
                'SDG',
                'SEK',
                'SGD',
                'SHP',
                'SLL',
                'SOS',
                'SRD',
                'STD',
                'STN',
                'SVC',
                'SYP',
                'SZL',
                'THB',
                'TJS',
                'TMT',
                'TND',
                'TOP',
                'TRY',
                'TTD',
                'TWD',
                'TZS',
                'UAH',
                'UGX',
                'USD',
                'USN',
                'UYI',
                'UYU',
                'UYW',
                'UZS',
                'VED',
                'VEF',
                'VES',
                'VND',
                'VUV',
                'WST',
                'XAG',
                'XAU',
                'XAF',
                'XBA',
                'XBB',
                'XBC',
                'XBD',
                'XCD',
                'XDR',
                'XOF',
                'XPD',
                'XPF',
                'XPT',
                'XSU',
                'XTS',
                'XUA',
                'XXX',
                'YER',
                'ZAR',
                'ZIG',
                'ZMK',
                'ZWL',
                'ZMW',
                'SSP',
                'NON_FIAT',
            ])
            .describe('Fiat(ISO-4217) currency code or NON_FIAT for non fiat currencies.')
            .optional(),
        currencyCode: z.string().describe('Currency code for NON_FIAT currency.').optional(),
    })
    .describe('Represents a currency eg. USD, EUR.')

export type Currency = z.infer<typeof Currency>

export const CreditArrangementSettings = z
    .object({
        creditArrangementRequirement: z
            .enum(['OPTIONAL', 'REQUIRED', 'NOT_REQUIRED'])
            .describe('Shows whether accounts created after this product can/should be part of a line of credit.')
            .optional(),
    })
    .describe('The funding settings, holds the settings regarding the funding for the loan product.')

export type CreditArrangementSettings = z.infer<typeof CreditArrangementSettings>

export const ProductAvailabilitySettings = z
    .object({
        availableFor: z
            .enum(['INDIVIDUALS', 'PURE_GROUPS', 'SOLIDARITY_GROUPS'])
            .array()
            .describe('Holds the entities this product is available for. i.e Individuals')
            .optional(),
        branchSettings: BranchSettings.optional(),
    })
    .describe('Holds information about product availability.')

export type ProductAvailabilitySettings = z.infer<typeof ProductAvailabilitySettings>

export const ProductArrearsSettings = z
    .object({
        dateCalculationMethod: z
            .enum(['ACCOUNT_FIRST_WENT_TO_ARREARS', 'LAST_LATE_REPAYMENT', 'ACCOUNT_FIRST_BREACHED_MATERIALITY_THRESHOLD'])
            .describe('The arrears date calculation method.')
            .optional(),
        encodedKey: z.string().describe('The encoded key of the arrears base settings, auto generated, unique.').optional(),
        monthlyToleranceDay: z.number().int().describe('Defines the tolerance monthly date').optional(),
        nonWorkingDaysMethod: z
            .enum(['INCLUDED', 'EXCLUDED'])
            .describe(
                'Shows whether the non working days are taken in consideration or not when applying penaltees/late fees or when setting an account into arrears',
            )
            .optional(),
        toleranceCalculationMethod: z
            .enum(['ARREARS_TOLERANCE_PERIOD', 'MONTHLY_ARREARS_TOLERANCE_DAY'])
            .describe('Defines the tolerance calculation method')
            .optional(),
        toleranceFloorAmount: z.number().describe('The tolerance floor amount.').optional(),
        tolerancePercentageOfOutstandingPrincipal: DecimalInterval.optional(),
        tolerancePeriod: IntegerIntervalConstraints.optional(),
    })
    .describe(
        'The product arrears settings, shows whether the non working days are taken in consideration or not when applying penalties/late fees or when setting an account into arrears',
    )

export type ProductArrearsSettings = z.infer<typeof ProductArrearsSettings>

export const AccountLinkSettings = z
    .object({
        enabled: z
            .boolean()
            .describe('Shows whether the loan accounts created using this product can be linked to a savings account.'),
        linkableDepositProductKey: z
            .string()
            .describe(
                'Loan accounts created for this product can only be linked the the savings accounts that use the savings product with this key. If null, the loan accounts for this product can be linked to any savings account.',
            )
            .optional(),
        linkedAccountOptions: z
            .enum(['AUTO_LINK_ACCOUNTS', 'AUTO_CREATE_LINKED_ACCOUNTS'])
            .array()
            .describe('A set of linked account options.')
            .optional(),
        settlementMethod: z
            .enum(['FULL_DUE_AMOUNTS', 'PARTIAL_DUE_AMOUNTS', 'NO_AUTOMATED_TRANSFERS'])
            .describe(
                'Set the option of automated transfer that should be made from linked deposit accounts into loan accounts create from this product.',
            )
            .optional(),
    })
    .describe('Defines the settings for account linking.')

export type AccountLinkSettings = z.infer<typeof AccountLinkSettings>

export const AccountingSettings = z
    .object({
        accountingMethod: z.enum(['NONE', 'CASH', 'ACCRUAL']).describe('The calculation method used for accounting.'),
        accountingRules: GLAccountingRule.array().describe('A list of accounting rules for the product.').optional(),
        interestAccrualCalculation: z
            .enum(['NONE', 'AGGREGATED_AMOUNT', 'BREAKDOWN_PER_ACCOUNT'])
            .describe('The accounting interest calculation option selected for the product.')
            .optional(),
        interestAccruedAccountingMethod: z
            .enum(['NONE', 'DAILY', 'END_OF_MONTH'])
            .describe('The interval defined for a product when the interest accrues should be maintained.')
            .optional(),
    })
    .describe('Accounting settings, defines the accounting settings for the product.')

export type AccountingSettings = z.infer<typeof AccountingSettings>

export const RestError = z.object({
    errorCode: z.number().int().optional(),
    errorReason: z.string().optional(),
    errorSource: z.string().optional(),
})

export type RestError = z.infer<typeof RestError>

export const LoanProduct = z
    .object({
        accountingSettings: AccountingSettings.optional(),
        accountLinkSettings: AccountLinkSettings.optional(),
        adjustInterestForFirstInstallment: z
            .boolean()
            .describe(
                '`TRUE` if it is possible to adjust the interest for the first repayment when the first repayment period is different than the repayment frequency, `FALSE` otherwise.',
            )
            .optional(),
        adjustTotalDueForInstallmentsWithDifferentInterval: z
            .boolean()
            .describe(
                '`TRUE` if it is possible to adjust the total due for the repayment when the repayment period is different than the repayment frequency, `FALSE` otherwise.',
            )
            .optional(),
        allowCustomRepaymentAllocation: z
            .boolean()
            .describe(
                '`TRUE` if an additional payment may be allocated on the account, ignoring the default repayment allocation order, `FALSE` otherwise.',
            )
            .optional(),
        arrearsSettings: ProductArrearsSettings.optional(),
        availabilitySettings: ProductAvailabilitySettings.optional(),
        category: z
            .enum(['PERSONAL_LENDING', 'PURCHASE_FINANCING', 'RETAIL_MORTGAGES', 'SME_LENDING', 'COMMERCIAL', 'UNCATEGORIZED'])
            .describe('The category of the loan product.')
            .optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The date the loan product was created.').optional(),
        creditArrangementSettings: CreditArrangementSettings,
        currency: Currency.optional(),
        encodedKey: z.string().describe('The encoded key of the loan product, it is auto generated, and unique.').optional(),
        feesSettings: FeesSettings.optional(),
        fundingSettings: FundingSettings.optional(),
        gracePeriodSettings: GracePeriodSettings.optional(),
        id: z.string().describe('The ID of the loan product, can be generated and customized, and must be unique.'),
        interestSettings: ProductInterestSettings.optional(),
        internalControls: InternalControls.optional(),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last date the loan product was updated.')
            .optional(),
        loanAmountSettings: LoanAmountSettings.optional(),
        name: z.string().describe('The name of the loan product.'),
        newAccountSettings: NewAccountSettings.optional(),
        notes: z.string().describe('The notes or description of the loan product.').optional(),
        offsetSettings: OffsetSettings.optional(),
        paymentSettings: PaymentSettings.optional(),
        penaltySettings: ProductPenaltySettings.optional(),
        redrawSettings: ProductRedrawSettings.optional(),
        scheduleSettings: LoanProductScheduleSettings.optional(),
        securitySettings: SecuritySettings.optional(),
        state: z.enum(['ACTIVE', 'INACTIVE']).describe('The current state of the loan product.').optional(),
        taxSettings: TaxSettings.optional(),
        templates: DocumentTemplate.array().describe('The template documents of the loan product.').optional(),
        type: z
            .enum([
                'FIXED_TERM_LOAN',
                'DYNAMIC_TERM_LOAN',
                'INTEREST_FREE_LOAN',
                'TRANCHED_LOAN',
                'REVOLVING_CREDIT',
                'INTEREST_ONLY_EQUAL_INSTALLMENTS',
                'DYNAMIC_MORTGAGE',
            ])
            .describe('The type of the loan product.'),
    })
    .describe('Represents a loan product.')

export type LoanProduct = z.infer<typeof LoanProduct>

export const PatchOperation = z
    .object({
        from: z.string().describe('The field from where a value should be moved, when using move').optional(),
        op: z.enum(['ADD', 'REPLACE', 'REMOVE', 'MOVE']).describe('The change to perform'),
        path: z.string().describe('The field to perform the operation on'),
        value: z.unknown().describe('The value of the field, can be null').optional(),
    })
    .describe('A single change that needs to be made to a resource')

export type PatchOperation = z.infer<typeof PatchOperation>

export const ErrorResponse = z.object({
    errors: RestError.array().optional(),
})

export type ErrorResponse = z.infer<typeof ErrorResponse>

export const GetAllResponse = LoanProduct.array()

export type GetAllResponse = z.infer<typeof GetAllResponse>

export const PatchRequest = PatchOperation.array()

export type PatchRequest = z.infer<typeof PatchRequest>
