/**
 * Generated by @skyleague/therefore
 * Do not manually touch this
 */
/* eslint-disable */

import { z } from 'zod'

export const TransactionChannelConstraint = z
    .object({
        criteria: z.enum(['AMOUNT', 'TYPE', 'PRODUCT']).describe('Defines the criteria on which the constraint is applied'),
        operator: z
            .enum(['EQUALS', 'EMPTY', 'NOT_EMPTY', 'MORE_THAN', 'LESS_THAN', 'BETWEEN', 'IN'])
            .describe(`Defines the constraint operator. Example: in 'Amount Equals 100' it is the 'Equals'`),
        secondValue: z
            .string()
            .describe(
                `The second filtering value of the filter parameter (constraint). It might not exist. Example: it represents '500' from 'Amount Between 100 and 500'`,
            )
            .optional(),
        value: z
            .string()
            .describe(
                `The first filtering value of the filter constraint. Example: it represents 'Disbursement' from 'Type equals Disbursement' and it also represents 100 from 'Amount Between 100 and 500'`,
            )
            .optional(),
        values: z
            .string()
            .array()
            .describe(
                'Filtering values used for the Product and Type criteria, where filtering might be applied on one or more values',
            )
            .optional(),
    })
    .describe('The constraints applied on the transaction channel')

export type TransactionChannelConstraint = z.infer<typeof TransactionChannelConstraint>

export const Constraint = z
    .object({
        constraints: TransactionChannelConstraint.array()
            .describe(
                'Holds the custom constraints, only for the limited usage case. For the unconstrainedcase, no constraints are applied',
            )
            .optional(),
        matchFiltersOption: z
            .enum(['ALL', 'ANY'])
            .describe(
                'Holds the match filter option for the constraints. It can be ALL so all the constraints must match, or ANY so at least one must match',
            )
            .optional(),
        usage: z
            .enum(['UNCONSTRAINED', 'LIMITED'])
            .describe('States the limited/unconstrained usage of the transaction channel')
            .optional(),
    })
    .describe('The constraints applied to the transaction channel')

export type Constraint = z.infer<typeof Constraint>

export const RestError = z.object({
    errorCode: z.number().int().optional(),
    errorReason: z.string().optional(),
    errorSource: z.string().optional(),
})

export type RestError = z.infer<typeof RestError>

export const TransactionChannel = z
    .object({
        availableForAll: z
            .boolean()
            .describe('`TRUE` if the transaction channel is available for all users, `FALSE` otherwise.')
            .optional(),
        depositConstraints: Constraint,
        encodedKey: z.string().describe('The encoded key of the entity, generated, globally unique').optional(),
        glAccount: z.string().describe('The general ledger (GL) account associated with the transaction channel.').optional(),
        id: z.string().describe('The ID of the transaction channel.'),
        isDefault: z.boolean().describe('`TRUE` if the transaction channel is set as the default, `FALSE` otherwise.').optional(),
        loanConstraints: Constraint,
        name: z.string().describe('The name of the transaction channel.'),
        state: z.enum(['ACTIVE', 'INACTIVE']).describe('The state of the transaction channel.').optional(),
        usageRights: z.string().array().describe('The usage rights that describe the transaction channel.').optional(),
    })
    .describe('Represents a transaction channel.')

export type TransactionChannel = z.infer<typeof TransactionChannel>

export const ErrorResponse = z.object({
    errors: RestError.array().optional(),
})

export type ErrorResponse = z.infer<typeof ErrorResponse>

export const GetAllResponse = TransactionChannel.array()

export type GetAllResponse = z.infer<typeof GetAllResponse>
