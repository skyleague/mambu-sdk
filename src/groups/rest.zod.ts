/**
 * Generated by @skyleague/therefore
 * Do not manually touch this
 */
/* eslint-disable */

import { z } from 'zod'

export const GroupRole = z
    .object({
        encodedKey: z
            .string()
            .describe('The encoded key of the group role name, which is auto generated, and unique.')
            .optional(),
        groupRoleNameKey: z.string().describe('The group role name key.'),
        roleName: z.string().describe('The group role name.').optional(),
        roleNameId: z.string().describe('The group role name ID.').optional(),
    })
    .describe(
        'Represents a group role. A group role, or group role name, is the role of a group member within the group - for example, money collector. One member could have many roles within a group.',
    )

export type GroupRole = z.infer<typeof GroupRole>

export const GroupMember = z
    .object({
        clientKey: z.string().describe('The encoded key of the client assigned as member of the group.'),
        roles: GroupRole.array().describe('The group role name associated with a group member.').optional(),
    })
    .describe(
        'Represents a group member. A group member is person that uses the services of the bank and is member of a group. Group members may have associated information, such as their client key and a list of roles they have within the group.',
    )

export type GroupMember = z.infer<typeof GroupMember>

export const Address = z
    .object({
        city: z.string().describe('The city for the address.').optional(),
        country: z.string().describe('The country.').optional(),
        encodedKey: z.string().describe('The address encoded key, which is unique and generated.').optional(),
        indexInList: z.number().int().describe('The index of this address in the list of addresses.').optional(),
        latitude: z
            .number()
            .describe(
                'The GPS latitude of this address in signed degrees format (DDD.dddd) with 6 decimal positions, ranging from -90 to +90.',
            )
            .optional(),
        line1: z.string().describe('The first line of the address.').optional(),
        line2: z.string().describe('The second line of the address.').optional(),
        longitude: z
            .number()
            .describe(
                'The GPS longitude of this address in signed degrees format (DDD.dddd) with 6 decimal positions, ranging from -180 to +180.',
            )
            .optional(),
        parentKey: z
            .string()
            .describe('The address parent key indicating the object owning this address. For example: client, centre, or branch.')
            .optional(),
        postcode: z.string().describe('The post code.').optional(),
        region: z.string().describe('The region for the address.').optional(),
    })
    .describe('Represents an address.')

export type Address = z.infer<typeof Address>

export const Currency = z
    .object({
        code: z
            .enum([
                'AED',
                'AFN',
                'ALL',
                'AMD',
                'ANG',
                'AOA',
                'ARS',
                'AUD',
                'AWG',
                'AZN',
                'BAM',
                'BBD',
                'BDT',
                'BGN',
                'BHD',
                'BIF',
                'BMD',
                'BND',
                'BOB',
                'BOV',
                'BRL',
                'BSD',
                'BTN',
                'BWP',
                'BYR',
                'BYN',
                'BZD',
                'CAD',
                'CDF',
                'CHE',
                'CHF',
                'CHW',
                'CLF',
                'CLP',
                'CNY',
                'COP',
                'COU',
                'CRC',
                'CUC',
                'CUP',
                'CVE',
                'CZK',
                'DJF',
                'DKK',
                'DOP',
                'DZD',
                'EGP',
                'ERN',
                'ETB',
                'EUR',
                'FJD',
                'FKP',
                'GBP',
                'GEL',
                'GHS',
                'GIP',
                'GMD',
                'GNF',
                'GTQ',
                'GYD',
                'HKD',
                'HNL',
                'HRK',
                'HTG',
                'HUF',
                'IDR',
                'ILS',
                'INR',
                'IQD',
                'IRR',
                'ISK',
                'JMD',
                'JOD',
                'JPY',
                'KES',
                'KGS',
                'KHR',
                'KMF',
                'KPW',
                'KRW',
                'KWD',
                'KYD',
                'KZT',
                'LAK',
                'LBP',
                'LKR',
                'LRD',
                'LSL',
                'LTL',
                'LVL',
                'LYD',
                'MAD',
                'MDL',
                'MGA',
                'MKD',
                'MMK',
                'MNT',
                'MOP',
                'MRO',
                'MRU',
                'MUR',
                'MVR',
                'MWK',
                'MXN',
                'MXV',
                'MYR',
                'MZN',
                'NAD',
                'NGN',
                'NIO',
                'NOK',
                'NPR',
                'NZD',
                'OMR',
                'PAB',
                'PEN',
                'PGK',
                'PHP',
                'PKR',
                'PLN',
                'PYG',
                'QAR',
                'RON',
                'RSD',
                'RUB',
                'RWF',
                'SAR',
                'SBD',
                'SCR',
                'SDG',
                'SEK',
                'SGD',
                'SHP',
                'SLL',
                'SOS',
                'SRD',
                'STD',
                'STN',
                'SVC',
                'SYP',
                'SZL',
                'THB',
                'TJS',
                'TMT',
                'TND',
                'TOP',
                'TRY',
                'TTD',
                'TWD',
                'TZS',
                'UAH',
                'UGX',
                'USD',
                'USN',
                'UYI',
                'UYU',
                'UYW',
                'UZS',
                'VED',
                'VEF',
                'VES',
                'VND',
                'VUV',
                'WST',
                'XAG',
                'XAU',
                'XAF',
                'XBA',
                'XBB',
                'XBC',
                'XBD',
                'XCD',
                'XDR',
                'XOF',
                'XPD',
                'XPF',
                'XPT',
                'XSU',
                'XTS',
                'XUA',
                'XXX',
                'YER',
                'ZAR',
                'ZIG',
                'ZMK',
                'ZWL',
                'ZMW',
                'SSP',
                'NON_FIAT',
            ])
            .describe('Fiat(ISO-4217) currency code or NON_FIAT for non fiat currencies.')
            .optional(),
        currencyCode: z.string().describe('Currency code for NON_FIAT currency.').optional(),
    })
    .describe('Represents a currency eg. USD, EUR.')

export type Currency = z.infer<typeof Currency>

export const RestError = z.object({
    errorCode: z.number().int().optional(),
    errorReason: z.string().optional(),
    errorSource: z.string().optional(),
})

export type RestError = z.infer<typeof RestError>

export const Group = z
    .object({
        addresses: Address.array().describe('The addresses associated with this group.').optional(),
        assignedBranchKey: z.string().describe('Key of the branch this group is assigned to.').optional(),
        assignedCentreKey: z.string().describe('Key of the centre this group is assigned to.').optional(),
        assignedUserKey: z.string().describe('Key of the user this group is assigned to.').optional(),
        creationDate: z.string().datetime({ offset: true }).describe('The date the group was created.').optional(),
        emailAddress: z.string().describe('The email address associated with the group.').optional(),
        encodedKey: z.string().describe('The encoded key of the group, which is auto generated, and must be unique.').optional(),
        groupMembers: GroupMember.array().describe('The members of this group.').optional(),
        groupName: z.string().describe('The name of the group.'),
        groupRoleKey: z.string().describe('A role which describes the intended use of a group in the system.').optional(),
        homePhone: z.string().describe('The home phone number associated with the group.').optional(),
        id: z.string().describe('The ID of the group, which can be generated and customized, but must be unique.').optional(),
        lastModifiedDate: z.string().datetime({ offset: true }).describe('The last date the group was updated.').optional(),
        loanCycle: z
            .number()
            .int()
            .describe(
                `Number of paid and closed (with 'obligations met') accounts for this client. When the closing operation is reverted, this is reduced.`,
            )
            .optional(),
        migrationEventKey: z.string().describe('The migration event encoded key associated with this group.').optional(),
        mobilePhone: z.string().describe('The mobile phone number associated with the group.').optional(),
        notes: z.string().describe('Extra notes about this group.').optional(),
        preferredLanguage: z
            .enum([
                'ENGLISH',
                'PORTUGESE',
                'SPANISH',
                'RUSSIAN',
                'FRENCH',
                'GEORGIAN',
                'CHINESE',
                'INDONESIAN',
                'ROMANIAN',
                'BURMESE',
                'GERMAN',
                'PORTUGUESE_BRAZIL',
                'VIETNAMESE',
                'ITALIAN',
                'THAI',
                'NORWEGIAN',
                'PHRASE',
            ])
            .describe('The preferred language associated with the group (used for the notifications).')
            .optional(),
    })
    .passthrough()
    .describe(
        'Represents a group. A group is a type of client that can represent a non-physical person such as a company client or a grouping of individual clients. A group can have its own accounts and can optionally have individual clients as members, in which case they also need to have an individual profile in Mambu.',
    )

export type Group = z.infer<typeof Group>

export const CreditArrangement = z
    .object({
        amount: z.number().describe('The maximum credit amount the client can be exposed to.'),
        approvedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when the credit arrangement was approved.')
            .optional(),
        availableCreditAmount: z.number().describe('The available amount of the credit arrangement.').optional(),
        closedDate: z.string().datetime({ offset: true }).describe('The date when the credit arrangement was closed.').optional(),
        consumedCreditAmount: z
            .number()
            .describe(
                'The consumed amount of the credit arrangement, which is calculated as the difference between the amount and available amount.',
            )
            .optional(),
        creationDate: z
            .string()
            .datetime({ offset: true })
            .describe('The date when the credit arrangement was created.')
            .optional(),
        currency: Currency.optional(),
        encodedKey: z
            .string()
            .describe('The encoded key of the credit arrangement, it is auto generated, and unique.')
            .optional(),
        expireDate: z.string().datetime({ offset: true }).describe('The date when the credit arrangement expires.'),
        exposureLimitType: z
            .enum(['APPROVED_AMOUNT', 'OUTSTANDING_AMOUNT'])
            .describe('The type of exposure limit calculation method used for the credit arrangement.')
            .optional(),
        holderKey: z
            .string()
            .describe('The encoded key of the credit arrangement holder (individual client or group).')
            .optional(),
        holderType: z
            .enum(['CLIENT', 'GROUP'])
            .describe('The type of the credit arrangement holder (individual client or group).'),
        id: z.string().describe('The ID of credit arrangement, can be generated and customized, and must be unique.').optional(),
        lastModifiedDate: z
            .string()
            .datetime({ offset: true })
            .describe('The last date when the credit arrangement was modified.')
            .optional(),
        notes: z.string().describe('The notes or description of the credit arrangement.').optional(),
        startDate: z
            .string()
            .datetime({ offset: true })
            .describe('The start date from which the credit arrangement became active.'),
        state: z
            .enum(['PENDING_APPROVAL', 'APPROVED', 'ACTIVE', 'CLOSED', 'WITHDRAWN', 'REJECTED'])
            .describe('The state of the credit arrangement.')
            .optional(),
        subState: z
            .enum(['PENDING_APPROVAL', 'APPROVED', 'ACTIVE', 'CLOSED', 'WITHDRAWN', 'REJECTED'])
            .describe('The substate of credit arrangement.')
            .optional(),
    })
    .passthrough()
    .describe('Represents a credit arrangement.')

export type CreditArrangement = z.infer<typeof CreditArrangement>

export const GroupSortingCriteria = z
    .object({
        field: z
            .enum([
                'encodedKey',
                'id',
                'creationDate',
                'groupName',
                'lastModifiedDate',
                'depositsBalance',
                'loansBalance',
                'totalBalance',
                'loanCycle',
            ])
            .describe(
                'The field to sort by. It can be a native field (one from the provided list) or otherwise can specify a custom field definitionusing the format [customFieldSetId].[customFieldId].',
            ),
        order: z.enum(['ASC', 'DESC']).describe('The sorting order: `ASC` or `DESC`. The default order is `DESC`.').optional(),
    })
    .describe('The sorting criteria used for Groups search')

export type GroupSortingCriteria = z.infer<typeof GroupSortingCriteria>

export const GroupFilterCriteria = z
    .object({
        field: z.union([
            z
                .enum([
                    'encodedKey',
                    'id',
                    'creationDate',
                    'groupRoleKey',
                    'branchKey',
                    'centreKey',
                    'creditOfficerKey',
                    'groupName',
                    'lastModifiedDate',
                    'preferredLanguage',
                    'depositsBalance',
                    'loansBalance',
                    'totalBalance',
                    'numberOfMembers',
                    'loanCycle',
                ])
                .describe(
                    'The fields to perform the search. They can be native (one from the provided list) or otherwise can specify a custom field definition using the format [customFieldSetId].[customFieldId].\\n',
                ),
            z.string(),
        ]),
        operator: z
            .enum([
                'EQUALS',
                'EQUALS_CASE_SENSITIVE',
                'DIFFERENT_THAN',
                'MORE_THAN',
                'LESS_THAN',
                'BETWEEN',
                'ON',
                'AFTER',
                'AFTER_INCLUSIVE',
                'BEFORE',
                'BEFORE_INCLUSIVE',
                'STARTS_WITH',
                'STARTS_WITH_CASE_SENSITIVE',
                'IN',
                'TODAY',
                'THIS_WEEK',
                'THIS_MONTH',
                'THIS_YEAR',
                'LAST_DAYS',
                'EMPTY',
                'NOT_EMPTY',
            ])
            .describe(
                '| **Operator**                | **Affected values**  | **Available for**                                                    |\\n|---------------               |----------------------|----------------------------------------------------------------------|\\n| EQUALS                       | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY        |\\n| EQUALS_CASE_SENSITIVE        | ONE_VALUE            | BIG_DECIMAL,BOOLEAN,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY 		  |\\n| MORE_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| LESS_THAN                    | ONE_VALUE            | BIG_DECIMAL,NUMBER,MONEY                                             |\\n| BETWEEN                      | TWO_VALUES           | BIG_DECIMAL,NUMBER,MONEY,DATE,DATE_TIME                              |\\n| ON                           | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| AFTER                        | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE                       | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| BEFORE_INCLUSIVE             | ONE_VALUE            | DATE,DATE_TIME                                                       |\\n| STARTS_WITH                  | ONE_VALUE            | STRING                                                               |\\n| STARTS_WITH_CASE_SENSITIVE   | ONE_VALUE            | STRING                                                               |\\n| IN                           | LIST                 | ENUM,KEY                                                             |\\n| TODAY                        | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_WEEK                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_MONTH                   | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| THIS_YEAR                    | NO_VALUE             | DATE,DATE_TIME                                                       |\\n| LAST_DAYS                    | ONE_VALUE            | NUMBER                                                               |\\n| EMPTY                        | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |\\n| NOT_EMPTY                    | NO_VALUE             | BIG_DECIMAL,LONG,MONEY,NUMBER,PERCENT,STRING,ENUM,KEY,DATE,DATE_TIME |',
            ),
        secondValue: z
            .string()
            .describe('The second value to match the searching criteria, when the `BETWEEN` operator is used.')
            .optional(),
        value: z.string().describe('The value to match the searching criteria.').optional(),
        values: z.string().array().describe('List of values when the `IN` operator is used.').optional(),
    })
    .describe('The unit that composes the list used for Groups searching')

export type GroupFilterCriteria = z.infer<typeof GroupFilterCriteria>

export const PatchOperation = z
    .object({
        from: z.string().describe('The field from where a value should be moved, when using move').optional(),
        op: z.enum(['ADD', 'REPLACE', 'REMOVE', 'MOVE']).describe('The change to perform'),
        path: z.string().describe('The field to perform the operation on'),
        value: z.unknown().describe('The value of the field, can be null').optional(),
    })
    .describe('A single change that needs to be made to a resource')

export type PatchOperation = z.infer<typeof PatchOperation>

export const ErrorResponse = z.object({
    errors: RestError.array().optional(),
})

export type ErrorResponse = z.infer<typeof ErrorResponse>

export const GetAllResponse = Group.array()

export type GetAllResponse = z.infer<typeof GetAllResponse>

export const GetCreditArrangementsByGroupIdOrKeyResponse = CreditArrangement.array()

export type GetCreditArrangementsByGroupIdOrKeyResponse = z.infer<typeof GetCreditArrangementsByGroupIdOrKeyResponse>

export const GroupSearchCriteria = z
    .object({
        filterCriteria: GroupFilterCriteria.array().describe('The list of filtering criteria'),
        sortingCriteria: GroupSortingCriteria.optional(),
    })
    .describe('Wrapper that holds a list of filtering criteria and a sorting criteria for Groups client directed query')

export type GroupSearchCriteria = z.infer<typeof GroupSearchCriteria>

export const PatchRequest = PatchOperation.array()

export type PatchRequest = z.infer<typeof PatchRequest>

export const SearchResponse = Group.array()

export type SearchResponse = z.infer<typeof SearchResponse>
